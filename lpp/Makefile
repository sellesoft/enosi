app_name := lpp

build_mode ?= debug
build_dir := build/${build_mode}

# final output path
final := ${build_dir}/${app_name}

# default rule (because it is the first one)
# to build the final output path
all: ${final}

# set verbose to false unless it was already specified 
# on cmdline
verbose ?= false

ifeq (${verbose},false)
	v := @
endif

compiler := clang
linker   := clang

compiler_flags :=     \
	-std=gnu2x        \
	-Iinclude         \
	-Isrc             \
	-ggdb3            \
	-Wno-pointer-sign \
	-Wno-gnu-folding-constant

ifeq ($(build_mode),debug)
	compiler_flags += -O0 -ggdb3
else ifeq ($(build_mode),release)
	compiler_flags += -O2
endif

linker_flags := \
	-Llib       \
	-lluajit    \
	-lm         \
	-Wl,--export-dynamic

# gather all c files from src/
c_files := $(wildcard src/*.c)
# turn each c file into its respective object file
o_files := $(c_files:src/%.c=${build_dir}/%.o)
# turn each c file into a dependency file'
# these are make rules generated by the compiler
# that create deps on the header file each cpp
# includes
d_files := $(c_files:src/%.c=${build_dir}/%.d)

reset := \033[0m
green := \033[0;32m
blue  := \033[0;34m

define print
	@printf "$(green)$(1)$(reset) -> $(blue)$(2)$(reset)\n"
endef

# final output is dependent on all the object files
${final}: ${o_files}
	$(v)${compiler} $^ ${linker_flags} -o $@
	@printf "$(blue)$@$(reset)\n"

# all the object files are dependent on their respective c files
${build_dir}/%.o: src/%.c
	$(v)${compiler} -c $< ${compiler_flags} -MMD -MP -o $@
	$(call print,$<,$@)

# include the dep files that will be generated by the compiler
-include $(d_files)

# the lpp c file is dependent on the metaenv carray
src/lpp.c: src/metaenv.carray

# transform the metaenv into a c array
src/metaenv.carray: src/metaenv.lua
	$(v)xxd -i $^ > $@
	$(call print,$^,$@)

clean:
	rm -r build/debug/*
	rm src/metaenv.carray
