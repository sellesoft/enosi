build_mode ?= "debug"
verbose    ?= false

build_dir := "build" / build_mode

lpp       := build_dir / "lpp"
commonlua := build_dir / "commonlua"

common_c_files := lake.find("src/*.c")
common_o_files := lake.replace(common_c_files, "src/%.c", build_dir / "obj/%.o")

lpp_c_files := lake.find("src/lpp/*.c")
lpp_o_files := lake.replace(lpp_c_files, "src/lpp/%.c", build_dir / "obj/%.o")

commonlua_c_files := lake.find("src/commonlua/*.c")
commonlua_o_files := lake.replace(commonlua_o_files, "src/common/%.c", build_dir / "obj/%.o")

c_files := [ common_c_files lpp_c_files commonlua_c_files ]
o_files := [ common_o_files lpp_o_files commonlua_o_files ]

compiler     := "clang"
linker       := "clang"
preprocessor := "cpp"

compiler_flags := [   
	-Iinclude
	-Isrc
	-std=gnu2x
	-Wno-pointer-sign
	-Wno-gnu-folding-constant
	-Wno-switch
]

if build_mode == "debug" then
	compiler_flags += [ -O0 -ggdb3 ]
else
	compiler_flags += "-O2"
end  

linker_flags := [
	-Llib
	-lluajit
	-lm
	-Wl,--export-dynamic
]

exe_recipe := fn(inputs, output)
	result := ` $(linker) $(inputs) $(linker_flags) -o $(output) `
	
	io.write(result.stderr)
	
	if result then
		print(lake.color("blue", output))
	end
end

lake.target(lpp)
	:uses(common_o_files, lpp_o_files)
	:recipe(exe_recipe)

lake.target(commonlua)
	:uses(common_o_files, commonlua_o_files)
	:recipe(exe_recipe)

print_success := fn(input, output)
	io.write(lake.color.green(input), " -> ", lake.color.blue(output))
end

make_obj_targets := fn(c_files, o_files)
	for c_file,o_file in c_files:zip(o_files)
		lake.target(o_file)
			:uses(c_file)
			:recipe(fn(input, output)
				result := ` $(compiler) -c $(input) $(compiler_flags) -o $(input) `
				
				io.write(result.stderr)

				if result then
					io.write(lake.color("green", input), " -> ", lake.color("blue", output), "\n")
				end
			end)
	end
end

make_obj_targets(   common_c_files,    common_o_files)
make_obj_targets(      lpp_c_files,       lpp_o_files)
make_obj_targets(commonlua_c_files, commonlua_o_files)

lake.target( "src/generated/metaenv.h" )
	:depends_on( "src/lpp/metaenv.lua", $(commonlua) )
	:recipe(fn()
		result := ` $(commonlua) src/scripts/metaenv2c.lua `

		io.write(result.stderr)

		if result then print_success("src/lpp/metaenv.lua", "src/generated/metaenv.h") end
	end)

token_targets := [
	token.map.h
	token.enum.h
	token.strings.h
	token.stringmap.h
]

for i=1,token_targets:len() do
	token_targets[i] = "src/generated" / token_targets[i]
end

lake.target(token_targets)
	:uses("src/scripts/tokens.lua")
	:depends_on(commonlua)
	:recipe(fn(input, outputs)
		result := ` $(commonlua) $(input) `

		io.write(result.stderr)

		if result then
			for output in outputs do
				print_success(input, output)
			end
		end
	end)

lake.c.autodependencies(c_files, compiler_flags)
