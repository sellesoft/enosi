mode    ?= "debug"
verbose ?= false

build_dir := "build/"..mode.."/"

lakeexe := lake.target(build_dir.."lake")

c_files := lake.find("src/*.cpp")
o_files := lake.replace(c_files, "src/(.-).cpp", build_dir.."%1.o")
d_files := lake.replace(c_files, "src/(.-).cpp", build_dir.."%1.d")

compiler     := "clang++"
linker       := "clang++"
preprocessor := "cpp"

compiler_flags := $[
	-std=c++20
	-Iinclude
	-Isrc
	-Wno-switch
	-fcolor-diagnostics
	-Wno-#warnings
]

if mode == "debug" then
	compiler_flags ..= $[ -O0 -ggdb3 ]
else
	compiler_flags ..= "-O2"
end

linker_flags := $[
	-Llib
	-lluajit
	-lm
	-Wl,--export-dynamic
]

reset := string.char(27).."[0m"
green := string.char(27).."[0;32m"
blue  := string.char(27).."[0;34m"

print_success := function(from, to, time)
	if to then
		io.write(green, from, reset, " -> ", blue, to, reset, " ", time, "s\n")
	else
		io.write(blue, from, reset, " ", time, "s\n")
	end
end

lakeexe
	:uses(o_files)
	:recipe(function()
		start := lake.get_highres_clock()
		result := ` $(linker) $(o_files) $(linker_flags) -o $(lakeexe) `
		time_took := (lake.get_highres_clock() - start) / 1000000

		if result.exit_status == 0 then
			print_success(output, nil, time_took)
		end

		io.write(result.stdout)
	end)

for c_file, o_file in lake.zip(c_files, o_files) do
	lake.target( o_file )
		:uses(c_file)
		:recipe(function()
			start := lake.get_highres_clock()
			result := ` $(compiler) -c $(c_file) $(compiler_flags) -o $(o_file) `
			time_took := (lake.get_highres_clock() - start) / 1000000

			if result.exit_status == 0 then
				print_success(input[1], output, time_took)
			end

			io.write(result.stdout)
		end)
end

-- create dependency files based on the make rule cpp generates for each cpp file.
-- we reformat them to just be a newline separated list of files each cpp files depends on
-- and the lake dependencies are created below this for loop
for c_file, d_file in lake.zip(c_files, d_files) do
	lake.target( d_file )
		:uses( c_file )
		:recipe(function(input, output)
			result := ` cpp $(input) $(compiler_flags) -MM -MG -MT $(lake.replace(output, "(.-)%.d", "%1.o")) `

			if result.exit_status ~= 0 then
				error("failed to create dep file '"..output..":\n"..result.stdout)
			end

			result = lake.replace(result.stderr:get(), "\\\n", "")
			
			out := ""

			for file in result:gmatch("%S+") do
				if file:sub(-1) ~= ":" then
					out = out..file.."\n"
				end
			end

			file := io.open(output, "w")

			if not file then
				error("failed to open dep file for writing: '"..output.."'")
			end
			
			file:write(out)
			file:close()
		end)
end

-- load the dependency files that may or may not exist and 
-- create dependencies between the o file they refer to 
-- and the files in the file
for o_file, d_file in lake.zip(o_files, d_files) do
	file := io.open(d_file, "r")

	if file then
		str := file:read("*a")

		for file in str:gmatch("%S+") do
			lake.target(o_file):depends_on(file)
		end	
	end
end

lake.targets("apple", "banana")
	:depends_on("orange")
	:recipe(function(inputs, outputs)
		for _,output in ipairs(outputs) do
			file := io.open(output, "w")
			file:close()
		end
	end)

lake.target("orange")
	:recipe(function()
		io.open("orange", "w"):close()
	end)
