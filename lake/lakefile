mode    ?= "debug"
verbose ?= false

lake.maxjobs(8)

build_dir := "buildtest/"..mode.."/"

lake.mkdir(build_dir, {make_parents = true})

lakeexe := lake.target(build_dir.."lake")

files := {}

files.c = lake.find("src/**/*.cpp")
files.o = lake.replace(files.c, "(src/.-)%.cpp", build_dir.."%1.o")
files.d = lake.replace(files.o, "(.-)%.o", "%1.d")

compiler     := "clang++"
linker       := "clang++"
preprocessor := "cpp"

string.starts_with = function(self, s)
	return self:sub(1,#s) == s
end

compiler_flags := 
$[
	
	-std=c++20
	-Iinclude
	-Isrc
	-Isrc/iro
	-Wno-switch
	-fcolor-diagnostics
	-fno-caret-diagnostics
	-Wno-#warnings

]

if mode == "debug" then
	compiler_flags ..= $[ 
		-O0 
		-ggdb3 
		-DLAKE_DEBUG=1
	]
else
	compiler_flags ..= "-O2"
end

linker_flags := 
$[
	
	-Llib
	-lluajit
	-lexplain
	-Wl,--export-dynamic
]

reset := "\027[0m"
green := "\027[0;32m"
blue  := "\027[0;34m"
red   := "\027[0;31m"

print_success := function(from, to, time)
	if to then
		io.write(green, from, reset, " -> ", blue, to, reset, " ", time, "s\n")
	else
		io.write(blue, from, reset, " ", time, "s\n")
	end
end

linker_recipe := function(input, output)
	if output == nil or input == nil then
		error("linker_recipe passed a nil input or output", 2)
	end

    return function()
        -- make sure the output path exists
        dir := tostring(output):match("(.*)/")
        lake.mkdir(dir, {make_parents = true})

        start := lake.get_highres_clock()
        result := ` $(linker) $(input) $(linker_flags) -o $(output) `
        time_took := (lake.get_highres_clock() - start) / 1000000

        if result.exit_code == 0 then
            io.write(blue, tostring(output), reset, " ", time_took, "s\n")
			io.write(result.stdout)
        else
            io.write(red, "compiling ", blue, tostring(output), red, " failed", reset, ":\n")
			io.write(result.stdout, result.stderr)
			error(red.."linker failed"..reset)
        end
    end
end

compiler_recipe := function(input, output)
    return function()
        dir := tostring(output):match("(.*)/")
        lake.mkdir(dir, {make_parents = true})

        start := lake.get_highres_clock()
        result := ` $(compiler) -c $(compiler_flags) $(input) -o $(output) `
        time_took := (lake.get_highres_clock() - start) / 1000000

        if result.exit_code == 0 then
            io.write(green, input, reset, " -> ", blue, output, reset, " ", time_took, "s\n")
			io.write(result.stdout)
        else
            io.write(red, "compiling ", blue, output, red, " failed", reset, ":\n")
			io.write(result.stdout, result.stderr)
			-- error(red.."compiler failed"..reset)
        end
    end
end



-- create dependency files based on the make rule cpp generates for each cpp file.
-- we reformat them to just be a newline separated list of files each cpp files depends on
-- and the lake dependencies are created below this for loop
for c_file, d_file in lake.zip(files.c, files.d) do
	lake.target( d_file )
		:uses( c_file )
		:recipe(function()
            dir := tostring(d_file):match("(.*)/")
            lake.mkdir(dir, {make_parents = true})

			-- cflags_str := os.getenv("NIX_CFLAGS_COMPILE")
			-- cflags := {}
			-- for word in cflags_str:gmatch("%S+") do table.insert(cflags, word) end

			print(c_file)

			result := ` clang++ $(c_file) $(compiler_flags) -MM -MG -MT $(lake.replace(d_file, "(.-)%.d", "%1.o")) `

			if result.exit_code ~= 0 then
				error("failed to create dep file '"..d_file.."':\n"..result.stdout..result.stderr)
			end

			result = lake.replace(result.stderr, "\\\n", "")
			
			out := ""

			for file in result:gmatch("%S+") do
				if file:sub(-1) ~= ":" then
					-- need to manually filter out 'new' because cpp doesn't find that its a 
					-- system header for whatever reason
					if file:starts_with("generated") then
						out = out.."src/"
					end
					out = out..file.."\n"
				end
			end

			file := io.open(d_file, "w")

			if not file then
				error("failed to open dep file for writing: '"..d_file.."'")
			end
			
			file:write(out)
			file:close()
		end)
end

-- load the dependency files that may or may not exist and 
-- create dependencies between the o file they refer to 
-- and the files in the file
for o_file, d_file in lake.zip(files.o, files.d) do
	file := io.open(d_file, "r")

	lake.target(o_file):depends_on(d_file)

	if file then
		str := file:read("*a")

		for file in str:gmatch("%S+") do
			if file ~= "\\" then
				lake.target(o_file):depends_on(file)
			end
		end	
	end
end

dep_file_recipe := function(input, output)
	if not input or not output then
		error("nil input or output passed to dep_file_recipe()", 2)
	end

	return function()
		dir := tostring(output):match("(.*)/")
		lake.mkdir(dir, {make_parents = true})

		result := ` clang++ $(input) $(compiler_flags) -MM -MG -MT $(lake.replace(output, "(.-)%.d", "%1.o")) `

		if result.exit_code ~= 0 then
			error("failed to create dep file '"..output.."':\n"..result.stdout..result.stderr)
		end

		result = lake.replace(result.stderr, "\\\n", "")
		
		out := ""

		for file in result:gmatch("%S+") do
			if file:sub(-1) ~= ":" then
				out = out..file.."\n"
			end
		end

		file := io.open(output, "w")

		if not file then
			error("failed to open dep file for writing: '"..output.."'")
		end
		
		file:write(out)
		file:close()
	end
end

iro_o_files := {}

lake.import "src/iro/lakemodule" 
{ 
	mode = mode, 
	report_o_file = function(o_file)
		-- correct the given file's path
		print("src/iro/"..tostring(o_file))
		table.insert(iro_o_files, "src/iro/"..tostring(o_file))
	end,
	compiler_recipe = compiler_recipe,
	dep_file_recipe = dep_file_recipe,
}

lakeexe:depends_on(files.o):recipe(linker_recipe({files.o, iro_o_files}, lakeexe))

for c_file, o_file in lake.zip(files.c, files.o) do
    lake.target(o_file):depends_on(c_file):recipe(compiler_recipe(c_file, o_file))
end

generated_target := function(source, output)
	target := nil

	if type(output) == "table" then
		target = lake.targets(output)
	else
		target = lake.target(output)
	end

	target:depends_on(source)
	 	:recipe(function()
			start := lake.get_highres_clock()
			result := ` luajit $(source) `
			time_took := (lake.get_highres_clock() - start) / 1000000

			if result.exit_status == 0 then
				print_success(source, nil, time_took)
			end

			io.write(result.stdout, "\n", result.stderr)
		end)
end

generated_target("src/cliargs.lua", "src/generated/cliargparser.h")

generated_target("src/tokens.lua", $[
	src/generated/token.kwmap.h 
	src/generated/token.enum.h 
	src/generated/token.strings.h])

lake.target("src/generated/lakeluacompiled.h")
	:depends_on "src/lake.lua"
	:recipe(function()
		start := lake.get_highres_clock()
		result := ` luajit -b src/lake.lua src/generated/lakeluacompiled.h `
		time_took := (lake.get_highres_clock() - start) / 1000000

		if result.exit_status == 0 then
			print_success("src/generated/lakeluacompiled.h", nil, time_took)
		end

		io.write(result.stdout, "\n", result.stderr)
	end)
  
