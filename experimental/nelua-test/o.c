/* Generated by Nelua 0.2.0-dev */
/* Compile command: gcc -x c "o.c" -x none -fwrapv -fno-strict-aliasing -g -o "o" */
/* Compile hash: 2Q9XkxyiYRbSty3aJSRnYgJiGv5n */
/* ------------------------------ DIRECTIVES -------------------------------- */
/* Disable some warnings that the generated code can trigger. */
#if defined(__clang__) && __clang_major__ >= 3
  #pragma clang diagnostic ignored "-Wtype-limits"
  #pragma clang diagnostic ignored "-Wwrite-strings"
  #pragma clang diagnostic ignored "-Wunused"
  #pragma clang diagnostic ignored "-Wunused-parameter"
  #pragma clang diagnostic ignored "-Wmissing-field-initializers"
  #pragma clang diagnostic ignored "-Wparentheses-equality"
  #pragma clang diagnostic ignored "-Wtautological-compare"
  #pragma clang diagnostic ignored "-Wmissing-braces"
  #ifndef __cplusplus
    #pragma clang diagnostic ignored "-Wincompatible-pointer-types"
    #pragma clang diagnostic error   "-Wimplicit-function-declaration"
    #pragma clang diagnostic error   "-Wimplicit-int"
  #else
    #pragma clang diagnostic ignored "-Wnarrowing"
    #pragma clang diagnostic ignored "-Wc99-designator"
  #endif
#elif defined(__GNUC__) && __GNUC__ >= 5
  #pragma GCC diagnostic ignored "-Wtype-limits"
  #pragma GCC diagnostic ignored "-Wwrite-strings"
  #pragma GCC diagnostic ignored "-Wunused-parameter"
  #pragma GCC diagnostic ignored "-Wunused-value"
  #pragma GCC diagnostic ignored "-Wunused-variable"
  #pragma GCC diagnostic ignored "-Wunused-function"
  #pragma GCC diagnostic ignored "-Wunused-but-set-variable"
  #pragma GCC diagnostic ignored "-Wmissing-field-initializers"
  #ifndef __cplusplus
    #pragma GCC diagnostic ignored "-Wmissing-braces"
    #pragma GCC diagnostic ignored "-Wincompatible-pointer-types"
    #pragma GCC diagnostic ignored "-Wdiscarded-qualifiers"
    #pragma GCC diagnostic error   "-Wimplicit-function-declaration"
    #pragma GCC diagnostic error   "-Wimplicit-int"
  #else
    #pragma GCC diagnostic ignored "-Wnarrowing"
  #endif
#endif
#if defined(_WIN32) && !defined(_CRT_SECURE_NO_WARNINGS)
  #define _CRT_SECURE_NO_WARNINGS
#endif
/* Macro used to perform compile-time checks. */
#if __STDC_VERSION__ >= 201112L
  #define NELUA_STATIC_ASSERT _Static_assert
#elif __cplusplus >= 201103L
  #define NELUA_STATIC_ASSERT static_assert
#else
  #define NELUA_STATIC_ASSERT(x, y)
#endif
/* Macro used to get alignment of a type. */
#if __STDC_VERSION__ >= 201112L
  #define NELUA_ALIGNOF _Alignof
#elif __cplusplus >= 201103L
  #define NELUA_ALIGNOF alignof
#elif defined(__GNUC__)
  #define NELUA_ALIGNOF __alignof__
#elif defined(_MSC_VER)
  #define NELUA_ALIGNOF __alignof
#else
  #define NELUA_ALIGNOF(x)
#endif
/* Checks if Nelua and C agrees on pointer size. */
NELUA_STATIC_ASSERT(sizeof(void*) == 8 && NELUA_ALIGNOF(void*) == 8, "Nelua and C disagree on pointer size or alignment");
/* Enable 64 bit offsets for stdio APIs. */
#if !defined(_FILE_OFFSET_BITS) && __SIZEOF_LONG__ >= 8
  #define _FILE_OFFSET_BITS 64
#endif
/* Enable POSIX APIs in included headers. */
#if !defined(_POSIX_C_SOURCE) && !defined(_XOPEN_SOURCE) && !defined(_GNU_SOURCE) && !defined(_DEFAULT_SOURCE)
  #if defined(__gnu_linux__)
    #define _GNU_SOURCE
  #else
    #define _XOPEN_SOURCE 600
  #endif
#endif
#include <string.h>
/* Macro used to force inlining a function. */
#ifdef __GNUC__
  #define NELUA_INLINE __attribute__((always_inline)) inline
#elif defined(_MSC_VER)
  #define NELUA_INLINE __forceinline
#elif __STDC_VERSION__ >= 199901L
  #define NELUA_INLINE inline
#else
  #define NELUA_INLINE
#endif
#include <stdint.h>
/* Macro used for branch prediction. */
#if defined(__GNUC__) || defined(__clang__)
  #define NELUA_UNLIKELY(x) __builtin_expect(x, 0)
#else
  #define NELUA_UNLIKELY(x) (x)
#endif
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
/* Macro used to import/export extern C functions. */
#ifdef __cplusplus
  #define NELUA_EXTERN extern "C"
#else
  #define NELUA_EXTERN extern
#endif
/* Macro used to generate traceback on aborts when sanitizing. */
#if defined(__clang__) && defined(__has_feature)
  #if __has_feature(undefined_behavior_sanitizer)
    #define NELUA_UBSAN_UNREACHABLE __builtin_unreachable
  #endif
#elif defined(__gnu_linux__) && defined(__GNUC__) && __GNUC__ >= 5
  NELUA_EXTERN void __ubsan_handle_builtin_unreachable(void*) __attribute__((weak));
  #define NELUA_UBSAN_UNREACHABLE() {if(&__ubsan_handle_builtin_unreachable) __builtin_unreachable();}
#endif
#ifndef NELUA_UBSAN_UNREACHABLE
  #define NELUA_UBSAN_UNREACHABLE()
#endif
/* Macro used to specify a function that never returns. */
#if __STDC_VERSION__ >= 201112L
  #define NELUA_NORETURN _Noreturn
#elif defined(__GNUC__)
  #define NELUA_NORETURN __attribute__((noreturn))
#elif defined(_MSC_VER)
  #define NELUA_NORETURN __declspec(noreturn)
#else
  #define NELUA_NORETURN
#endif
#include <stddef.h>
/* Macro used sign that a type punning cast may alias (related to strict aliasing). */
#ifdef __GNUC__
  #define NELUA_MAYALIAS __attribute__((may_alias))
#else
  #define NELUA_MAYALIAS
#endif
#define NELUA_NIL (nlniltype){}
/* Macro used for branch prediction. */
#if defined(__GNUC__) || defined(__clang__)
  #define NELUA_LIKELY(x) __builtin_expect(x, 1)
#else
  #define NELUA_LIKELY(x) (x)
#endif
/* Macro used to force not inlining a function. */
#ifdef __GNUC__
  #define NELUA_NOINLINE __attribute__((noinline))
#elif defined(_MSC_VER)
  #define NELUA_NOINLINE __declspec(noinline)
#else
  #define NELUA_NOINLINE
#endif
/* Macro used suppress sanitizer errors when the GC is scanning. */
#if defined(__has_feature)
  #if __has_feature(address_sanitizer)
    #define NELUA_GC_NO_SANITIZE __attribute__((no_sanitize_address))
  #elif __has_feature(memory_sanitizer)
    #define NELUA_GC_NO_SANITIZE __attribute__((no_sanitize_memory))
  #endif
#endif
#ifndef NELUA_GC_NO_SANITIZE
  #if defined(__SANITIZE_ADDRESS__)
    #define NELUA_GC_NO_SANITIZE __attribute__((no_sanitize_address))
  #else
    #define NELUA_GC_NO_SANITIZE
  #endif
#endif
#include <setjmp.h>
#include <errno.h>
#include <termios.h>
/* Macro used to take reference of literals. */
#define NELUA_LITERAL_REF(T, x) (&((struct{T v;}){x}.v))
/* ------------------------------ DECLARATIONS ------------------------------ */
static NELUA_INLINE void nelua_memory_copy(void* dest, void* src, uintptr_t n);
static NELUA_INLINE void nelua_write_stderr(const char* msg, uintptr_t len, bool flush);
static NELUA_NORETURN void nelua_abort(void);
typedef struct nlstring nlstring;
typedef uint8_t* nluint8_arr0_ptr;
struct nlstring {
  nluint8_arr0_ptr data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nlstring) == 16 && NELUA_ALIGNOF(nlstring) == 8, "Nelua and C disagree on type size or align");
static void nelua_assert_line_1(bool cond, nlstring msg);
static NELUA_INLINE void nelua_memory_zero(void* dest, uintptr_t n);
static void nelua_assert_line_2(bool cond, nlstring msg);
typedef struct nelua_span_uint8_ nelua_span_uint8_;
struct nelua_span_uint8_ {
  nluint8_arr0_ptr data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nelua_span_uint8_) == 16 && NELUA_ALIGNOF(nelua_span_uint8_) == 8, "Nelua and C disagree on type size or align");
static NELUA_INLINE bool nelua_span_uint8__empty(nelua_span_uint8_ self);
typedef uint8_t* nluint8_ptr;
static NELUA_INLINE nluint8_ptr nelua_span_uint8____atindex(nelua_span_uint8_ self, uintptr_t i);
static void nelua_assert_line_3(bool cond, nlstring msg);
typedef void** nlpointer_ptr;
typedef struct nelua_span_pointer_ nelua_span_pointer_;
typedef void** nlpointer_arr0_ptr;
struct nelua_span_pointer_ {
  nlpointer_arr0_ptr data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nelua_span_pointer_) == 16 && NELUA_ALIGNOF(nelua_span_pointer_) == 8, "Nelua and C disagree on type size or align");
static NELUA_INLINE nlpointer_ptr nelua_span_pointer____atindex(nelua_span_pointer_ self, uintptr_t i);
static void nelua_assert_line_4(bool cond, nlstring msg);
typedef struct nelua_GCScanRange nelua_GCScanRange;
typedef nelua_GCScanRange* nelua_GCScanRange_ptr;
struct nelua_GCScanRange {
  uintptr_t low;
  uintptr_t high;
};
NELUA_STATIC_ASSERT(sizeof(nelua_GCScanRange) == 16 && NELUA_ALIGNOF(nelua_GCScanRange) == 8, "Nelua and C disagree on type size or align");
typedef struct nelua_span_GCScanRange_ nelua_span_GCScanRange_;
typedef nelua_GCScanRange* nelua_GCScanRange_arr0_ptr;
struct nelua_span_GCScanRange_ {
  nelua_GCScanRange_arr0_ptr data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nelua_span_GCScanRange_) == 16 && NELUA_ALIGNOF(nelua_span_GCScanRange_) == 8, "Nelua and C disagree on type size or align");
static NELUA_INLINE nelua_GCScanRange_ptr nelua_span_GCScanRange____atindex(nelua_span_GCScanRange_ self, uintptr_t i);
static void nelua_assert_line_5(bool cond, nlstring msg);
typedef uintptr_t* nlusize_ptr;
typedef struct nelua_span_usize_ nelua_span_usize_;
typedef uintptr_t* nlusize_arr0_ptr;
struct nelua_span_usize_ {
  nlusize_arr0_ptr data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nelua_span_usize_) == 16 && NELUA_ALIGNOF(nelua_span_usize_) == 8, "Nelua and C disagree on type size or align");
static NELUA_INLINE nlusize_ptr nelua_span_usize____atindex(nelua_span_usize_ self, uintptr_t i);
static void nelua_assert_line_6(bool cond, nlstring msg);
typedef struct nelua_hashmapnode_pointer__GCItem_ nelua_hashmapnode_pointer__GCItem_;
typedef nelua_hashmapnode_pointer__GCItem_* nelua_hashmapnode_pointer__GCItem__ptr;
typedef struct nelua_GCItem nelua_GCItem;
typedef void (*nelua_GCFinalizerCallback)(void*, void*);
struct nelua_GCItem {
  uintptr_t flags;
  uintptr_t size;
  nelua_GCFinalizerCallback finalizer;
  void* userdata;
};
NELUA_STATIC_ASSERT(sizeof(nelua_GCItem) == 32 && NELUA_ALIGNOF(nelua_GCItem) == 8, "Nelua and C disagree on type size or align");
struct nelua_hashmapnode_pointer__GCItem_ {
  void* key;
  nelua_GCItem value;
  bool filled;
  uintptr_t next;
};
NELUA_STATIC_ASSERT(sizeof(nelua_hashmapnode_pointer__GCItem_) == 56 && NELUA_ALIGNOF(nelua_hashmapnode_pointer__GCItem_) == 8, "Nelua and C disagree on type size or align");
typedef struct nelua_span_hashmapnode_pointer__GCItem__ nelua_span_hashmapnode_pointer__GCItem__;
typedef nelua_hashmapnode_pointer__GCItem_* nelua_hashmapnode_pointer__GCItem__arr0_ptr;
struct nelua_span_hashmapnode_pointer__GCItem__ {
  nelua_hashmapnode_pointer__GCItem__arr0_ptr data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nelua_span_hashmapnode_pointer__GCItem__) == 16 && NELUA_ALIGNOF(nelua_span_hashmapnode_pointer__GCItem__) == 8, "Nelua and C disagree on type size or align");
static NELUA_INLINE nelua_hashmapnode_pointer__GCItem__ptr nelua_span_hashmapnode_pointer__GCItem_____atindex(nelua_span_hashmapnode_pointer__GCItem__ self, uintptr_t i);
static void nelua_assert_line_7(bool cond, nlstring msg);
typedef struct nelua_hashmapnode_pointer__usize_ nelua_hashmapnode_pointer__usize_;
typedef nelua_hashmapnode_pointer__usize_* nelua_hashmapnode_pointer__usize__ptr;
struct nelua_hashmapnode_pointer__usize_ {
  void* key;
  uintptr_t value;
  bool filled;
  uintptr_t next;
};
NELUA_STATIC_ASSERT(sizeof(nelua_hashmapnode_pointer__usize_) == 32 && NELUA_ALIGNOF(nelua_hashmapnode_pointer__usize_) == 8, "Nelua and C disagree on type size or align");
typedef struct nelua_span_hashmapnode_pointer__usize__ nelua_span_hashmapnode_pointer__usize__;
typedef nelua_hashmapnode_pointer__usize_* nelua_hashmapnode_pointer__usize__arr0_ptr;
struct nelua_span_hashmapnode_pointer__usize__ {
  nelua_hashmapnode_pointer__usize__arr0_ptr data;
  uintptr_t size;
};
NELUA_STATIC_ASSERT(sizeof(nelua_span_hashmapnode_pointer__usize__) == 16 && NELUA_ALIGNOF(nelua_span_hashmapnode_pointer__usize__) == 8, "Nelua and C disagree on type size or align");
static NELUA_INLINE nelua_hashmapnode_pointer__usize__ptr nelua_span_hashmapnode_pointer__usize_____atindex(nelua_span_hashmapnode_pointer__usize__ self, uintptr_t i);
static void nelua_assert_line_8(bool cond, nlstring msg);
typedef struct nlmulret_nlboolean_nlint64_nluint8 {
  bool r1;
  int64_t r2;
  uint8_t r3;
} nlmulret_nlboolean_nlint64_nluint8;
typedef nlstring* nlstring_ptr;
typedef nlmulret_nlboolean_nlint64_nluint8 (*function_r1xBQ225tRe7LZWm)(nlstring_ptr, int64_t);
typedef struct nlmulret_function_r1xBQ225tRe7LZWm_nlstring_ptr_nlint64 {
  function_r1xBQ225tRe7LZWm r1;
  nlstring_ptr r2;
  int64_t r3;
} nlmulret_function_r1xBQ225tRe7LZWm_nlstring_ptr_nlint64;
static NELUA_INLINE nlmulret_function_r1xBQ225tRe7LZWm_nlstring_ptr_nlint64 nelua_ipairs_1(nlstring_ptr a);
static nlmulret_nlboolean_nlint64_nluint8 nelua_ipairs_next(nlstring_ptr a_1, int64_t k);
static NELUA_NORETURN void nelua_panic_cstring(const char* s);
static NELUA_INLINE void* nelua_assert_deref(void* p);
static NELUA_INLINE uintptr_t nelua_assert_narrow_nlint64_nlusize(int64_t x);
typedef struct main_Tile main_Tile;
typedef main_Tile* main_Tile_ptr;
typedef struct nlmulret_nlboolean_nlint64_main_Tile_ptr {
  bool r1;
  int64_t r2;
  main_Tile_ptr r3;
} nlmulret_nlboolean_nlint64_main_Tile_ptr;
typedef int64_t main_Tile_Kind;
typedef struct list_DList_2 list_DList_2;
typedef struct pool_PoolT_15 pool_PoolT_15;
typedef struct pool_Chunk_15 pool_Chunk_15;
typedef pool_Chunk_15* pool_Chunk_15_ptr;
typedef union pool_Slot_15 pool_Slot_15;
typedef pool_Slot_15* pool_Slot_15_ptr;
struct pool_PoolT_15 {
  pool_Chunk_15_ptr current_chunk;
  pool_Slot_15_ptr free_slot;
};
NELUA_STATIC_ASSERT(sizeof(pool_PoolT_15) == 16 && NELUA_ALIGNOF(pool_PoolT_15) == 8, "Nelua and C disagree on type size or align");
typedef struct list_Node_8 list_Node_8;
typedef list_Node_8* list_Node_8_ptr;
struct list_DList_2 {
  pool_PoolT_15 pool;
  list_Node_8_ptr head;
  list_Node_8_ptr tail;
};
NELUA_STATIC_ASSERT(sizeof(list_DList_2) == 32 && NELUA_ALIGNOF(list_DList_2) == 8, "Nelua and C disagree on type size or align");
struct main_Tile {
  main_Tile_Kind kind;
  list_DList_2 objects;
};
NELUA_STATIC_ASSERT(sizeof(main_Tile) == 40 && NELUA_ALIGNOF(main_Tile) == 8, "Nelua and C disagree on type size or align");
typedef struct NELUA_MAYALIAS main_Tile_arr49 {main_Tile v[49];} main_Tile_arr49;
typedef union NELUA_MAYALIAS main_Tile_arr49_cast {main_Tile_arr49 a; main_Tile p[49];} main_Tile_arr49_cast;
NELUA_STATIC_ASSERT(sizeof(main_Tile_arr49) == 1960 && NELUA_ALIGNOF(main_Tile_arr49) == 8, "Nelua and C disagree on type size or align");
typedef main_Tile_arr49* main_Tile_arr49_ptr;
typedef nlmulret_nlboolean_nlint64_main_Tile_ptr (*function_34gvaBKj3vvkM3dS7)(main_Tile_arr49_ptr, int64_t);
typedef struct main_Object main_Object;
typedef main_Object* main_Object_ptr;
struct list_Node_8 {
  main_Object_ptr data;
  list_Node_8_ptr next;
  list_Node_8_ptr prev;
};
NELUA_STATIC_ASSERT(sizeof(list_Node_8) == 24 && NELUA_ALIGNOF(list_Node_8) == 8, "Nelua and C disagree on type size or align");
typedef struct main_vec2 main_vec2;
struct main_vec2 {
  int32_t x;
  int32_t y;
};
NELUA_STATIC_ASSERT(sizeof(main_vec2) == 8 && NELUA_ALIGNOF(main_vec2) == 4, "Nelua and C disagree on type size or align");
struct main_Object {
  uint64_t typeid;
  main_vec2 pos;
  list_Node_8_ptr tile_node;
};
NELUA_STATIC_ASSERT(sizeof(main_Object) == 24 && NELUA_ALIGNOF(main_Object) == 8, "Nelua and C disagree on type size or align");
union pool_Slot_15 {
  pool_Slot_15_ptr next_free_slot;
  list_Node_8 element;
};
NELUA_STATIC_ASSERT(sizeof(pool_Slot_15) == 24 && NELUA_ALIGNOF(pool_Slot_15) == 8, "Nelua and C disagree on type size or align");
struct pool_Chunk_15 {
  pool_Chunk_15_ptr next;
  pool_Slot_15 slots[16];
};
NELUA_STATIC_ASSERT(sizeof(pool_Chunk_15) == 392 && NELUA_ALIGNOF(pool_Chunk_15) == 8, "Nelua and C disagree on type size or align");
typedef struct nlmulret_function_34gvaBKj3vvkM3dS7_main_Tile_arr49_ptr_nlint64 {
  function_34gvaBKj3vvkM3dS7 r1;
  main_Tile_arr49_ptr r2;
  int64_t r3;
} nlmulret_function_34gvaBKj3vvkM3dS7_main_Tile_arr49_ptr_nlint64;
static NELUA_INLINE nlmulret_function_34gvaBKj3vvkM3dS7_main_Tile_arr49_ptr_nlint64 nelua_mipairs_1(main_Tile_arr49_ptr a);
static nlmulret_nlboolean_nlint64_main_Tile_ptr nelua_mipairs_next(main_Tile_arr49_ptr a_2, int64_t k);
static NELUA_INLINE int64_t nelua_assert_bounds_nlint64(int64_t index, uintptr_t len);
typedef struct nlmulret_nlboolean_nlpointer_nlusize {
  bool r1;
  void* r2;
  uintptr_t r3;
} nlmulret_nlboolean_nlpointer_nlusize;
typedef struct nelua_hashmap_iteratorT_1 nelua_hashmap_iteratorT_1;
typedef nelua_hashmap_iteratorT_1* nelua_hashmap_iteratorT_1_ptr;
typedef nlmulret_nlboolean_nlpointer_nlusize (*function_2EyHN9k6KLqeowE1y)(nelua_hashmap_iteratorT_1_ptr, void*);
typedef struct nelua_hashmap_pointer__usize_ nelua_hashmap_pointer__usize_;
typedef nelua_hashmap_pointer__usize_* nelua_hashmap_pointer__usize__ptr;
struct nelua_hashmap_iteratorT_1 {
  nelua_hashmap_pointer__usize__ptr container;
  uintptr_t index;
};
NELUA_STATIC_ASSERT(sizeof(nelua_hashmap_iteratorT_1) == 16 && NELUA_ALIGNOF(nelua_hashmap_iteratorT_1) == 8, "Nelua and C disagree on type size or align");
typedef struct nelua_GeneralAllocator nelua_GeneralAllocator;
struct nelua_GeneralAllocator {};
struct nelua_hashmap_pointer__usize_ {
  nelua_span_usize_ buckets;
  nelua_span_hashmapnode_pointer__usize__ nodes;
  uintptr_t size;
  uintptr_t free_index;
  nelua_GeneralAllocator allocator;
};
NELUA_STATIC_ASSERT(sizeof(nelua_hashmap_pointer__usize_) == 48 && NELUA_ALIGNOF(nelua_hashmap_pointer__usize_) == 8, "Nelua and C disagree on type size or align");
typedef struct nlmulret_function_2EyHN9k6KLqeowE1y_nelua_hashmap_iteratorT_1_nlpointer {
  function_2EyHN9k6KLqeowE1y r1;
  nelua_hashmap_iteratorT_1 r2;
  void* r3;
} nlmulret_function_2EyHN9k6KLqeowE1y_nelua_hashmap_iteratorT_1_nlpointer;
static NELUA_INLINE nlmulret_function_2EyHN9k6KLqeowE1y_nelua_hashmap_iteratorT_1_nlpointer nelua_pairs_1(nelua_hashmap_pointer__usize__ptr a);
typedef nelua_GCItem* nelua_GCItem_ptr;
typedef struct nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr {
  bool r1;
  void* r2;
  nelua_GCItem_ptr r3;
} nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr;
typedef struct nelua_hashmap_iteratorT nelua_hashmap_iteratorT;
typedef nelua_hashmap_iteratorT* nelua_hashmap_iteratorT_ptr;
typedef nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr (*function_3dDifWjDdRxpgM1fu)(nelua_hashmap_iteratorT_ptr, void*);
typedef struct nelua_hashmap_pointer__GCItem_ nelua_hashmap_pointer__GCItem_;
typedef nelua_hashmap_pointer__GCItem_* nelua_hashmap_pointer__GCItem__ptr;
struct nelua_hashmap_iteratorT {
  nelua_hashmap_pointer__GCItem__ptr container;
  uintptr_t index;
};
NELUA_STATIC_ASSERT(sizeof(nelua_hashmap_iteratorT) == 16 && NELUA_ALIGNOF(nelua_hashmap_iteratorT) == 8, "Nelua and C disagree on type size or align");
struct nelua_hashmap_pointer__GCItem_ {
  nelua_span_usize_ buckets;
  nelua_span_hashmapnode_pointer__GCItem__ nodes;
  uintptr_t size;
  uintptr_t free_index;
  nelua_GeneralAllocator allocator;
};
NELUA_STATIC_ASSERT(sizeof(nelua_hashmap_pointer__GCItem_) == 48 && NELUA_ALIGNOF(nelua_hashmap_pointer__GCItem_) == 8, "Nelua and C disagree on type size or align");
typedef struct nlmulret_function_3dDifWjDdRxpgM1fu_nelua_hashmap_iteratorT_nlpointer {
  function_3dDifWjDdRxpgM1fu r1;
  nelua_hashmap_iteratorT r2;
  void* r3;
} nlmulret_function_3dDifWjDdRxpgM1fu_nelua_hashmap_iteratorT_nlpointer;
static NELUA_INLINE nlmulret_function_3dDifWjDdRxpgM1fu_nelua_hashmap_iteratorT_nlpointer nelua_mpairs_1(nelua_hashmap_pointer__GCItem__ptr a);
typedef struct nlniltype {} nlniltype;
typedef struct nlniltype nltype;
static NELUA_INLINE void nelua_memory_spanset_1(nelua_span_usize_ dest, uintptr_t x);
static nelua_GeneralAllocator nelua_general_allocator;
typedef nelua_GeneralAllocator* nelua_GeneralAllocator_ptr;
static NELUA_INLINE void* nelua_GeneralAllocator_alloc_1(nelua_GeneralAllocator_ptr self, uintptr_t size, uintptr_t flags);
static NELUA_INLINE void* nelua_GeneralAllocator_alloc_2(nelua_GeneralAllocator_ptr self, uintptr_t size, nlniltype flags);
static NELUA_INLINE void* nelua_GeneralAllocator_alloc0_1(nelua_GeneralAllocator_ptr self, uintptr_t size, nlniltype flags);
static NELUA_INLINE void* nelua_GeneralAllocator_alloc0_2(nelua_GeneralAllocator_ptr self, uintptr_t size, uintptr_t flags);
static NELUA_INLINE void nelua_GeneralAllocator_dealloc(nelua_GeneralAllocator_ptr self, void* p);
static NELUA_INLINE void* nelua_GeneralAllocator_realloc(nelua_GeneralAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize);
static void* nelua_GeneralAllocator_realloc0(nelua_GeneralAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize);
static nelua_span_pointer_ nelua_GeneralAllocator_spanalloc_1(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags);
static nelua_span_GCScanRange_ nelua_GeneralAllocator_spanalloc_2(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags);
static nelua_span_usize_ nelua_GeneralAllocator_spanalloc_3(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags);
static nelua_span_hashmapnode_pointer__GCItem__ nelua_GeneralAllocator_spanalloc0_1(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags);
static nelua_span_hashmapnode_pointer__usize__ nelua_GeneralAllocator_spanalloc0_2(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags);
static void nelua_GeneralAllocator_spandealloc_1(nelua_GeneralAllocator_ptr self, nelua_span_pointer_ s);
static void nelua_GeneralAllocator_spandealloc_2(nelua_GeneralAllocator_ptr self, nelua_span_GCScanRange_ s);
static void nelua_GeneralAllocator_spandealloc_3(nelua_GeneralAllocator_ptr self, nelua_span_usize_ s);
static void nelua_GeneralAllocator_spandealloc_4(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_pointer__GCItem__ s);
static void nelua_GeneralAllocator_spandealloc_5(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_pointer__usize__ s);
static nelua_span_pointer_ nelua_GeneralAllocator_spanrealloc_1(nelua_GeneralAllocator_ptr self, nelua_span_pointer_ s, uintptr_t size);
static nelua_span_GCScanRange_ nelua_GeneralAllocator_spanrealloc_2(nelua_GeneralAllocator_ptr self, nelua_span_GCScanRange_ s, uintptr_t size);
static nelua_span_usize_ nelua_GeneralAllocator_spanrealloc_3(nelua_GeneralAllocator_ptr self, nelua_span_usize_ s, uintptr_t size);
static nelua_span_pointer_ nelua_GeneralAllocator_xspanrealloc_1(nelua_GeneralAllocator_ptr self, nelua_span_pointer_ s, uintptr_t size);
static NELUA_NORETURN void nelua_panic_string(nlstring s);
static nelua_span_GCScanRange_ nelua_GeneralAllocator_xspanrealloc_2(nelua_GeneralAllocator_ptr self, nelua_span_GCScanRange_ s, uintptr_t size);
static nelua_span_usize_ nelua_GeneralAllocator_xspanrealloc_3(nelua_GeneralAllocator_ptr self, nelua_span_usize_ s, uintptr_t size);
static nelua_span_hashmapnode_pointer__GCItem__ nelua_GeneralAllocator_spanrealloc0_1(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_pointer__GCItem__ s, uintptr_t size);
static nelua_span_hashmapnode_pointer__usize__ nelua_GeneralAllocator_spanrealloc0_2(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_pointer__usize__ s, uintptr_t size);
static nelua_span_hashmapnode_pointer__GCItem__ nelua_GeneralAllocator_xspanrealloc0_1(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_pointer__GCItem__ s, uintptr_t size);
static nelua_span_hashmapnode_pointer__usize__ nelua_GeneralAllocator_xspanrealloc0_2(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_pointer__usize__ s, uintptr_t size);
static uintptr_t nelua_hash_hash_1(void* v);
static NELUA_INLINE uintptr_t nelua_ceilidiv(uintptr_t x, uintptr_t y);
static NELUA_INLINE uintptr_t nelua_hashmod(uintptr_t h, uintptr_t n);
static NELUA_INLINE uintptr_t nelua_roundpow2(uintptr_t n);
static void nelua_hashmap_pointer__GCItem__destroy(nelua_hashmap_pointer__GCItem__ptr self);
typedef struct nlmulret_nlusize_nlusize_nlusize {
  uintptr_t r1;
  uintptr_t r2;
  uintptr_t r3;
} nlmulret_nlusize_nlusize_nlusize;
static NELUA_INLINE nlmulret_nlusize_nlusize_nlusize nelua_hashmap_pointer__GCItem___find(nelua_hashmap_pointer__GCItem__ptr self, void* key);
static NELUA_NOINLINE void nelua_hashmap_pointer__GCItem__rehash(nelua_hashmap_pointer__GCItem__ptr self, uintptr_t bucket_count);
static void nelua_assert_line_9(bool cond);
static uintptr_t nelua_hashmap_pointer__GCItem___at(nelua_hashmap_pointer__GCItem__ptr self, void* key);
static void nelua_assert_line_10(bool cond, nlstring msg);
static nelua_GCItem_ptr nelua_hashmap_pointer__GCItem____atindex(nelua_hashmap_pointer__GCItem__ptr self, void* key);
static nelua_GCItem_ptr nelua_hashmap_pointer__GCItem__peek(nelua_hashmap_pointer__GCItem__ptr self, void* key);
static nelua_GCItem nelua_hashmap_pointer__GCItem__remove(nelua_hashmap_pointer__GCItem__ptr self, void* key);
static bool nelua_hashmap_pointer__GCItem__erase(nelua_hashmap_pointer__GCItem__ptr self, void* key);
static NELUA_INLINE nelua_hashmapnode_pointer__GCItem__ptr nelua_hashmap_iteratorT__next_node(nelua_hashmap_iteratorT_ptr self, void* key);
static nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr nelua_hashmap_iteratorT_mnext(nelua_hashmap_iteratorT_ptr self, void* key);
static NELUA_INLINE nlmulret_function_3dDifWjDdRxpgM1fu_nelua_hashmap_iteratorT_nlpointer nelua_hashmap_pointer__GCItem____mpairs(nelua_hashmap_pointer__GCItem__ptr self);
static void nelua_hashmap_pointer__usize__destroy(nelua_hashmap_pointer__usize__ptr self);
static NELUA_INLINE nlmulret_nlusize_nlusize_nlusize nelua_hashmap_pointer__usize___find(nelua_hashmap_pointer__usize__ptr self, void* key);
static NELUA_NOINLINE void nelua_hashmap_pointer__usize__rehash(nelua_hashmap_pointer__usize__ptr self, uintptr_t bucket_count);
static void nelua_assert_line_11(bool cond);
static uintptr_t nelua_hashmap_pointer__usize___at(nelua_hashmap_pointer__usize__ptr self, void* key);
static void nelua_assert_line_12(bool cond, nlstring msg);
static nlusize_ptr nelua_hashmap_pointer__usize____atindex(nelua_hashmap_pointer__usize__ptr self, void* key);
static uintptr_t nelua_hashmap_pointer__usize__remove(nelua_hashmap_pointer__usize__ptr self, void* key);
static NELUA_INLINE nelua_hashmapnode_pointer__usize__ptr nelua_hashmap_iteratorT_1__next_node(nelua_hashmap_iteratorT_1_ptr self, void* key);
static nlmulret_nlboolean_nlpointer_nlusize nelua_hashmap_iteratorT_1_next(nelua_hashmap_iteratorT_1_ptr self, void* key);
static NELUA_INLINE nlmulret_function_2EyHN9k6KLqeowE1y_nelua_hashmap_iteratorT_1_nlpointer nelua_hashmap_pointer__usize____pairs(nelua_hashmap_pointer__usize__ptr self);
typedef struct nelua_vector_pointer_ nelua_vector_pointer_;
typedef nelua_vector_pointer_* nelua_vector_pointer__ptr;
struct nelua_vector_pointer_ {
  nelua_span_pointer_ data;
  uintptr_t size;
  nelua_GeneralAllocator allocator;
};
NELUA_STATIC_ASSERT(sizeof(nelua_vector_pointer_) == 24 && NELUA_ALIGNOF(nelua_vector_pointer_) == 8, "Nelua and C disagree on type size or align");
static void nelua_vector_pointer__clear(nelua_vector_pointer__ptr self);
static void nelua_vector_pointer__destroy(nelua_vector_pointer__ptr self);
static NELUA_NOINLINE void nelua_vectorT_grow(nelua_vector_pointer__ptr self);
static void nelua_assert_line_13(bool cond, nlstring msg);
static void nelua_vector_pointer__push(nelua_vector_pointer__ptr self, void* v);
static NELUA_INLINE nlpointer_ptr nelua_vector_pointer____atindex(nelua_vector_pointer__ptr self, uintptr_t pos);
static void nelua_assert_line_14(bool cond, nlstring msg);
typedef struct nelua_vector_GCScanRange_ nelua_vector_GCScanRange_;
typedef nelua_vector_GCScanRange_* nelua_vector_GCScanRange__ptr;
struct nelua_vector_GCScanRange_ {
  nelua_span_GCScanRange_ data;
  uintptr_t size;
  nelua_GeneralAllocator allocator;
};
NELUA_STATIC_ASSERT(sizeof(nelua_vector_GCScanRange_) == 24 && NELUA_ALIGNOF(nelua_vector_GCScanRange_) == 8, "Nelua and C disagree on type size or align");
static void nelua_vector_GCScanRange__destroy(nelua_vector_GCScanRange__ptr self);
static NELUA_NOINLINE void nelua_vectorT_grow_1(nelua_vector_GCScanRange__ptr self);
static void nelua_assert_line_15(bool cond, nlstring msg);
static void nelua_vector_GCScanRange__push(nelua_vector_GCScanRange__ptr self, nelua_GCScanRange v);
static nelua_GCScanRange nelua_vector_GCScanRange__pop(nelua_vector_GCScanRange__ptr self);
static void nelua_assert_line_16(bool cond, nlstring msg);
static NELUA_INLINE bool nelua_hasflag(uintptr_t flags, uintptr_t flag);
static NELUA_INLINE uintptr_t nelua_align_forward(uintptr_t addr, uintptr_t align);
typedef struct nelua_GC nelua_GC;
struct nelua_GC {
  bool running;
  bool collecting;
  uintptr_t pause;
  uintptr_t membytes;
  uintptr_t lastmembytes;
  uintptr_t addrormask;
  uintptr_t addrandmask;
  uintptr_t stacktop;
  uintptr_t stackbottom;
  nelua_vector_pointer_ finalizeitems;
  nelua_vector_GCScanRange_ scanranges;
  nelua_hashmap_pointer__GCItem_ items;
  nelua_hashmap_pointer__usize_ rootitems;
};
NELUA_STATIC_ASSERT(sizeof(nelua_GC) == 208 && NELUA_ALIGNOF(nelua_GC) == 8, "Nelua and C disagree on type size or align");
static nelua_GC nelua_gc;
typedef nelua_GC* nelua_GC_ptr;
static void nelua_GC_unregister_1(nelua_GC_ptr self, void* ptr, bool finalize);
static void nelua_assert_line_17(bool cond, nlstring msg);
static NELUA_NOINLINE NELUA_GC_NO_SANITIZE void nelua_GC_markptrs(nelua_GC_ptr self);
static NELUA_NOINLINE void nelua_GC_scanrange(nelua_GC_ptr self, uintptr_t low, uintptr_t high);
static NELUA_NOINLINE void nelua_GC_scanptr(nelua_GC_ptr self, void* ptr);
static NELUA_NOINLINE NELUA_GC_NO_SANITIZE void nelua_GC_scanstack(nelua_GC_ptr self);
typedef union nelua_RegsBuf nelua_RegsBuf;
union nelua_RegsBuf {
  jmp_buf regs;
  void* firstreg;
};
static NELUA_NOINLINE void nelua_GC_mark(nelua_GC_ptr self);
typedef void (*function_rmio2ccn5TvMa852)(nelua_GC_ptr);
static NELUA_NOINLINE void nelua_GC_sweep(nelua_GC_ptr self);
static void nelua_assert_line_18(bool cond, nlstring msg);
static void nelua_assert_line_19(bool cond, nlstring msg);
static void nelua_assert_line_20(bool cond, nlstring msg);
static NELUA_NOINLINE void nelua_GC_rehash(nelua_GC_ptr self);
static NELUA_NOINLINE void nelua_GC_collect(nelua_GC_ptr self);
static NELUA_NOINLINE void nelua_GC_registerroots(nelua_GC_ptr self);
typedef void (*function_2gZWAqbgEuvU3TiaR)(void*, void*);
static bool nelua_GC_step(nelua_GC_ptr self);
static void nelua_GC_register(nelua_GC_ptr self, void* ptr, uintptr_t size, uintptr_t flags, function_2gZWAqbgEuvU3TiaR finalizer, void* userdata);
static void nelua_assert_line_21(bool cond, nlstring msg);
static void nelua_assert_line_22(bool cond, nlstring msg);
static void nelua_assert_line_23(bool cond, nlstring msg);
static void nelua_assert_line_24(bool cond, nlstring msg);
static void nelua_GC_reregister(nelua_GC_ptr self, void* oldptr, void* newptr, uintptr_t newsize);
static void nelua_assert_line_25(bool cond, nlstring msg);
static void nelua_assert_line_26(bool cond, nlstring msg);
static void nelua_assert_line_27(bool cond, nlstring msg);
static void nelua_GC_restart(nelua_GC_ptr self);
static NELUA_NOINLINE void nelua_GC_init(nelua_GC_ptr self, void* stack);
static NELUA_NOINLINE void nelua_GC_destroy(nelua_GC_ptr self);
typedef char** nlcstring_ptr;
int main(int argc, nlcstring_ptr argv);
typedef int (*function_2kJXCPHs2QinkWNvV)(int, nlcstring_ptr);
typedef struct nelua_GCAllocator nelua_GCAllocator;
struct nelua_GCAllocator {};
static nelua_GCAllocator nelua_gc_allocator;
typedef nelua_GCAllocator* nelua_GCAllocator_ptr;
static NELUA_NOINLINE void* nelua_GCAllocator_alloc_1(nelua_GCAllocator_ptr self, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata);
static NELUA_NOINLINE void* nelua_GCAllocator_alloc_3(nelua_GCAllocator_ptr self, uintptr_t size, uintptr_t flags, nelua_GCFinalizerCallback finalizer, void* userdata);
static NELUA_NOINLINE void* nelua_GCAllocator_alloc0_1(nelua_GCAllocator_ptr self, uintptr_t size, nlniltype flags, nelua_GCFinalizerCallback finalizer, void* userdata);
static NELUA_NOINLINE void* nelua_GCAllocator_alloc0_2(nelua_GCAllocator_ptr self, uintptr_t size, uintptr_t flags, nelua_GCFinalizerCallback finalizer, void* userdata);
static NELUA_NOINLINE void nelua_GCAllocator_dealloc(nelua_GCAllocator_ptr self, void* ptr);
static NELUA_NOINLINE void* nelua_GCAllocator_realloc(nelua_GCAllocator_ptr self, void* ptr, uintptr_t newsize, uintptr_t oldsize);
static nelua_span_uint8_ nelua_GCAllocator_spanalloc_2(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata);
static nelua_span_uint8_ nelua_GCAllocator_spanalloc0_1(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata);
typedef struct pool_Chunk_1 pool_Chunk_1;
typedef pool_Chunk_1* pool_Chunk_1_ptr;
typedef union pool_Slot_1 pool_Slot_1;
typedef pool_Slot_1* pool_Slot_1_ptr;
typedef struct event_Subscription event_Subscription;
typedef struct main_event_Event_AfterEventProcessing main_event_Event_AfterEventProcessing;
typedef main_event_Event_AfterEventProcessing* main_event_Event_AfterEventProcessing_ptr;
typedef void (*function_5jQF6ccFUGExBdUeJ)(void*, main_event_Event_AfterEventProcessing_ptr);
struct event_Subscription {
  void* subscriber;
  function_5jQF6ccFUGExBdUeJ handler;
};
NELUA_STATIC_ASSERT(sizeof(event_Subscription) == 16 && NELUA_ALIGNOF(event_Subscription) == 8, "Nelua and C disagree on type size or align");
union pool_Slot_1 {
  pool_Slot_1_ptr next_free_slot;
  event_Subscription element;
};
NELUA_STATIC_ASSERT(sizeof(pool_Slot_1) == 16 && NELUA_ALIGNOF(pool_Slot_1) == 8, "Nelua and C disagree on type size or align");
struct pool_Chunk_1 {
  pool_Chunk_1_ptr next;
  pool_Slot_1 slots[16];
};
NELUA_STATIC_ASSERT(sizeof(pool_Chunk_1) == 264 && NELUA_ALIGNOF(pool_Chunk_1) == 8, "Nelua and C disagree on type size or align");
struct main_event_Event_AfterEventProcessing {};
static NELUA_NOINLINE pool_Chunk_1_ptr nelua_GCAllocator_new_4(nelua_GCAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags);
static void nelua_assert_line_28(bool cond, nlstring msg);
typedef struct pool_Chunk_2 pool_Chunk_2;
typedef pool_Chunk_2* pool_Chunk_2_ptr;
typedef union pool_Slot_2 pool_Slot_2;
typedef pool_Slot_2* pool_Slot_2_ptr;
typedef struct list_Node_1 list_Node_1;
typedef event_Subscription* event_Subscription_ptr;
typedef list_Node_1* list_Node_1_ptr;
struct list_Node_1 {
  event_Subscription_ptr data;
  list_Node_1_ptr next;
};
NELUA_STATIC_ASSERT(sizeof(list_Node_1) == 16 && NELUA_ALIGNOF(list_Node_1) == 8, "Nelua and C disagree on type size or align");
union pool_Slot_2 {
  pool_Slot_2_ptr next_free_slot;
  list_Node_1 element;
};
NELUA_STATIC_ASSERT(sizeof(pool_Slot_2) == 16 && NELUA_ALIGNOF(pool_Slot_2) == 8, "Nelua and C disagree on type size or align");
struct pool_Chunk_2 {
  pool_Chunk_2_ptr next;
  pool_Slot_2 slots[16];
};
NELUA_STATIC_ASSERT(sizeof(pool_Chunk_2) == 264 && NELUA_ALIGNOF(pool_Chunk_2) == 8, "Nelua and C disagree on type size or align");
static NELUA_NOINLINE pool_Chunk_2_ptr nelua_GCAllocator_new_5(nelua_GCAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags);
static void nelua_assert_line_29(bool cond, nlstring msg);
typedef struct pool_Chunk_3 pool_Chunk_3;
typedef pool_Chunk_3* pool_Chunk_3_ptr;
typedef union pool_Slot_3 pool_Slot_3;
typedef pool_Slot_3* pool_Slot_3_ptr;
typedef struct event_Subscription_1 event_Subscription_1;
typedef struct main_event_Event_AnimalDeath main_event_Event_AnimalDeath;
typedef main_event_Event_AnimalDeath* main_event_Event_AnimalDeath_ptr;
typedef void (*function_zxezGrmyM9tuw6iJ)(void*, main_event_Event_AnimalDeath_ptr);
struct event_Subscription_1 {
  void* subscriber;
  function_zxezGrmyM9tuw6iJ handler;
};
NELUA_STATIC_ASSERT(sizeof(event_Subscription_1) == 16 && NELUA_ALIGNOF(event_Subscription_1) == 8, "Nelua and C disagree on type size or align");
union pool_Slot_3 {
  pool_Slot_3_ptr next_free_slot;
  event_Subscription_1 element;
};
NELUA_STATIC_ASSERT(sizeof(pool_Slot_3) == 16 && NELUA_ALIGNOF(pool_Slot_3) == 8, "Nelua and C disagree on type size or align");
struct pool_Chunk_3 {
  pool_Chunk_3_ptr next;
  pool_Slot_3 slots[16];
};
NELUA_STATIC_ASSERT(sizeof(pool_Chunk_3) == 264 && NELUA_ALIGNOF(pool_Chunk_3) == 8, "Nelua and C disagree on type size or align");
typedef struct main_Animal main_Animal;
typedef main_Animal* main_Animal_ptr;
struct main_event_Event_AnimalDeath {
  main_Animal_ptr animal;
};
NELUA_STATIC_ASSERT(sizeof(main_event_Event_AnimalDeath) == 8 && NELUA_ALIGNOF(main_event_Event_AnimalDeath) == 8, "Nelua and C disagree on type size or align");
struct main_Animal {
  uint64_t typeid;
  main_vec2 pos;
  list_Node_8_ptr tile_node;
  int8_t health;
};
NELUA_STATIC_ASSERT(sizeof(main_Animal) == 32 && NELUA_ALIGNOF(main_Animal) == 8, "Nelua and C disagree on type size or align");
static NELUA_NOINLINE pool_Chunk_3_ptr nelua_GCAllocator_new_6(nelua_GCAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags);
static void nelua_assert_line_30(bool cond, nlstring msg);
typedef struct pool_Chunk_4 pool_Chunk_4;
typedef pool_Chunk_4* pool_Chunk_4_ptr;
typedef union pool_Slot_4 pool_Slot_4;
typedef pool_Slot_4* pool_Slot_4_ptr;
typedef struct list_Node_2 list_Node_2;
typedef event_Subscription_1* event_Subscription_1_ptr;
typedef list_Node_2* list_Node_2_ptr;
struct list_Node_2 {
  event_Subscription_1_ptr data;
  list_Node_2_ptr next;
};
NELUA_STATIC_ASSERT(sizeof(list_Node_2) == 16 && NELUA_ALIGNOF(list_Node_2) == 8, "Nelua and C disagree on type size or align");
union pool_Slot_4 {
  pool_Slot_4_ptr next_free_slot;
  list_Node_2 element;
};
NELUA_STATIC_ASSERT(sizeof(pool_Slot_4) == 16 && NELUA_ALIGNOF(pool_Slot_4) == 8, "Nelua and C disagree on type size or align");
struct pool_Chunk_4 {
  pool_Chunk_4_ptr next;
  pool_Slot_4 slots[16];
};
NELUA_STATIC_ASSERT(sizeof(pool_Chunk_4) == 264 && NELUA_ALIGNOF(pool_Chunk_4) == 8, "Nelua and C disagree on type size or align");
static NELUA_NOINLINE pool_Chunk_4_ptr nelua_GCAllocator_new_7(nelua_GCAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags);
static void nelua_assert_line_31(bool cond, nlstring msg);
typedef struct pool_Chunk_5 pool_Chunk_5;
typedef pool_Chunk_5* pool_Chunk_5_ptr;
typedef union pool_Slot_5 pool_Slot_5;
typedef pool_Slot_5* pool_Slot_5_ptr;
typedef struct event_Subscription_2 event_Subscription_2;
typedef struct main_event_Event_ObjectMoved main_event_Event_ObjectMoved;
typedef main_event_Event_ObjectMoved* main_event_Event_ObjectMoved_ptr;
typedef void (*function_47C7wLHnkQC8jxoxm)(void*, main_event_Event_ObjectMoved_ptr);
struct event_Subscription_2 {
  void* subscriber;
  function_47C7wLHnkQC8jxoxm handler;
};
NELUA_STATIC_ASSERT(sizeof(event_Subscription_2) == 16 && NELUA_ALIGNOF(event_Subscription_2) == 8, "Nelua and C disagree on type size or align");
union pool_Slot_5 {
  pool_Slot_5_ptr next_free_slot;
  event_Subscription_2 element;
};
NELUA_STATIC_ASSERT(sizeof(pool_Slot_5) == 16 && NELUA_ALIGNOF(pool_Slot_5) == 8, "Nelua and C disagree on type size or align");
struct pool_Chunk_5 {
  pool_Chunk_5_ptr next;
  pool_Slot_5 slots[16];
};
NELUA_STATIC_ASSERT(sizeof(pool_Chunk_5) == 264 && NELUA_ALIGNOF(pool_Chunk_5) == 8, "Nelua and C disagree on type size or align");
struct main_event_Event_ObjectMoved {
  main_Object_ptr obj;
  main_vec2 oldpos;
};
NELUA_STATIC_ASSERT(sizeof(main_event_Event_ObjectMoved) == 16 && NELUA_ALIGNOF(main_event_Event_ObjectMoved) == 8, "Nelua and C disagree on type size or align");
static NELUA_NOINLINE pool_Chunk_5_ptr nelua_GCAllocator_new_8(nelua_GCAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags);
static void nelua_assert_line_32(bool cond, nlstring msg);
typedef struct pool_Chunk_6 pool_Chunk_6;
typedef pool_Chunk_6* pool_Chunk_6_ptr;
typedef union pool_Slot_6 pool_Slot_6;
typedef pool_Slot_6* pool_Slot_6_ptr;
typedef struct list_Node_3 list_Node_3;
typedef event_Subscription_2* event_Subscription_2_ptr;
typedef list_Node_3* list_Node_3_ptr;
struct list_Node_3 {
  event_Subscription_2_ptr data;
  list_Node_3_ptr next;
};
NELUA_STATIC_ASSERT(sizeof(list_Node_3) == 16 && NELUA_ALIGNOF(list_Node_3) == 8, "Nelua and C disagree on type size or align");
union pool_Slot_6 {
  pool_Slot_6_ptr next_free_slot;
  list_Node_3 element;
};
NELUA_STATIC_ASSERT(sizeof(pool_Slot_6) == 16 && NELUA_ALIGNOF(pool_Slot_6) == 8, "Nelua and C disagree on type size or align");
struct pool_Chunk_6 {
  pool_Chunk_6_ptr next;
  pool_Slot_6 slots[16];
};
NELUA_STATIC_ASSERT(sizeof(pool_Chunk_6) == 264 && NELUA_ALIGNOF(pool_Chunk_6) == 8, "Nelua and C disagree on type size or align");
static NELUA_NOINLINE pool_Chunk_6_ptr nelua_GCAllocator_new_9(nelua_GCAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags);
static void nelua_assert_line_33(bool cond, nlstring msg);
typedef struct pool_Chunk_7 pool_Chunk_7;
typedef pool_Chunk_7* pool_Chunk_7_ptr;
typedef union pool_Slot_7 pool_Slot_7;
typedef pool_Slot_7* pool_Slot_7_ptr;
typedef struct event_Subscription_3 event_Subscription_3;
typedef struct main_event_Event_PlayerAttack main_event_Event_PlayerAttack;
typedef main_event_Event_PlayerAttack* main_event_Event_PlayerAttack_ptr;
typedef void (*function_33LFECzHockrdAF5u)(void*, main_event_Event_PlayerAttack_ptr);
struct event_Subscription_3 {
  void* subscriber;
  function_33LFECzHockrdAF5u handler;
};
NELUA_STATIC_ASSERT(sizeof(event_Subscription_3) == 16 && NELUA_ALIGNOF(event_Subscription_3) == 8, "Nelua and C disagree on type size or align");
union pool_Slot_7 {
  pool_Slot_7_ptr next_free_slot;
  event_Subscription_3 element;
};
NELUA_STATIC_ASSERT(sizeof(pool_Slot_7) == 16 && NELUA_ALIGNOF(pool_Slot_7) == 8, "Nelua and C disagree on type size or align");
struct pool_Chunk_7 {
  pool_Chunk_7_ptr next;
  pool_Slot_7 slots[16];
};
NELUA_STATIC_ASSERT(sizeof(pool_Chunk_7) == 264 && NELUA_ALIGNOF(pool_Chunk_7) == 8, "Nelua and C disagree on type size or align");
typedef struct main_Player main_Player;
typedef main_Player* main_Player_ptr;
struct main_event_Event_PlayerAttack {
  main_Player_ptr player;
  main_vec2 attack_pos;
};
NELUA_STATIC_ASSERT(sizeof(main_event_Event_PlayerAttack) == 16 && NELUA_ALIGNOF(main_event_Event_PlayerAttack) == 8, "Nelua and C disagree on type size or align");
struct main_Player {
  uint64_t typeid;
  main_vec2 pos;
  list_Node_8_ptr tile_node;
};
NELUA_STATIC_ASSERT(sizeof(main_Player) == 24 && NELUA_ALIGNOF(main_Player) == 8, "Nelua and C disagree on type size or align");
static NELUA_NOINLINE pool_Chunk_7_ptr nelua_GCAllocator_new_10(nelua_GCAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags);
static void nelua_assert_line_34(bool cond, nlstring msg);
typedef struct pool_Chunk_8 pool_Chunk_8;
typedef pool_Chunk_8* pool_Chunk_8_ptr;
typedef union pool_Slot_8 pool_Slot_8;
typedef pool_Slot_8* pool_Slot_8_ptr;
typedef struct list_Node_4 list_Node_4;
typedef event_Subscription_3* event_Subscription_3_ptr;
typedef list_Node_4* list_Node_4_ptr;
struct list_Node_4 {
  event_Subscription_3_ptr data;
  list_Node_4_ptr next;
};
NELUA_STATIC_ASSERT(sizeof(list_Node_4) == 16 && NELUA_ALIGNOF(list_Node_4) == 8, "Nelua and C disagree on type size or align");
union pool_Slot_8 {
  pool_Slot_8_ptr next_free_slot;
  list_Node_4 element;
};
NELUA_STATIC_ASSERT(sizeof(pool_Slot_8) == 16 && NELUA_ALIGNOF(pool_Slot_8) == 8, "Nelua and C disagree on type size or align");
struct pool_Chunk_8 {
  pool_Chunk_8_ptr next;
  pool_Slot_8 slots[16];
};
NELUA_STATIC_ASSERT(sizeof(pool_Chunk_8) == 264 && NELUA_ALIGNOF(pool_Chunk_8) == 8, "Nelua and C disagree on type size or align");
static NELUA_NOINLINE pool_Chunk_8_ptr nelua_GCAllocator_new_11(nelua_GCAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags);
static void nelua_assert_line_35(bool cond, nlstring msg);
typedef struct pool_Chunk_9 pool_Chunk_9;
typedef pool_Chunk_9* pool_Chunk_9_ptr;
typedef union pool_Slot_9 pool_Slot_9;
typedef pool_Slot_9* pool_Slot_9_ptr;
typedef struct event_Subscription_4 event_Subscription_4;
typedef struct main_event_Event_AnimalDamaged main_event_Event_AnimalDamaged;
typedef main_event_Event_AnimalDamaged* main_event_Event_AnimalDamaged_ptr;
typedef void (*function_3pdNrWTzpEWtYEh5B)(void*, main_event_Event_AnimalDamaged_ptr);
struct event_Subscription_4 {
  void* subscriber;
  function_3pdNrWTzpEWtYEh5B handler;
};
NELUA_STATIC_ASSERT(sizeof(event_Subscription_4) == 16 && NELUA_ALIGNOF(event_Subscription_4) == 8, "Nelua and C disagree on type size or align");
union pool_Slot_9 {
  pool_Slot_9_ptr next_free_slot;
  event_Subscription_4 element;
};
NELUA_STATIC_ASSERT(sizeof(pool_Slot_9) == 16 && NELUA_ALIGNOF(pool_Slot_9) == 8, "Nelua and C disagree on type size or align");
struct pool_Chunk_9 {
  pool_Chunk_9_ptr next;
  pool_Slot_9 slots[16];
};
NELUA_STATIC_ASSERT(sizeof(pool_Chunk_9) == 264 && NELUA_ALIGNOF(pool_Chunk_9) == 8, "Nelua and C disagree on type size or align");
struct main_event_Event_AnimalDamaged {
  main_Animal_ptr animal;
};
NELUA_STATIC_ASSERT(sizeof(main_event_Event_AnimalDamaged) == 8 && NELUA_ALIGNOF(main_event_Event_AnimalDamaged) == 8, "Nelua and C disagree on type size or align");
static NELUA_NOINLINE pool_Chunk_9_ptr nelua_GCAllocator_new_12(nelua_GCAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags);
static void nelua_assert_line_36(bool cond, nlstring msg);
typedef struct pool_Chunk_10 pool_Chunk_10;
typedef pool_Chunk_10* pool_Chunk_10_ptr;
typedef union pool_Slot_10 pool_Slot_10;
typedef pool_Slot_10* pool_Slot_10_ptr;
typedef struct list_Node_5 list_Node_5;
typedef event_Subscription_4* event_Subscription_4_ptr;
typedef list_Node_5* list_Node_5_ptr;
struct list_Node_5 {
  event_Subscription_4_ptr data;
  list_Node_5_ptr next;
};
NELUA_STATIC_ASSERT(sizeof(list_Node_5) == 16 && NELUA_ALIGNOF(list_Node_5) == 8, "Nelua and C disagree on type size or align");
union pool_Slot_10 {
  pool_Slot_10_ptr next_free_slot;
  list_Node_5 element;
};
NELUA_STATIC_ASSERT(sizeof(pool_Slot_10) == 16 && NELUA_ALIGNOF(pool_Slot_10) == 8, "Nelua and C disagree on type size or align");
struct pool_Chunk_10 {
  pool_Chunk_10_ptr next;
  pool_Slot_10 slots[16];
};
NELUA_STATIC_ASSERT(sizeof(pool_Chunk_10) == 264 && NELUA_ALIGNOF(pool_Chunk_10) == 8, "Nelua and C disagree on type size or align");
static NELUA_NOINLINE pool_Chunk_10_ptr nelua_GCAllocator_new_13(nelua_GCAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags);
static void nelua_assert_line_37(bool cond, nlstring msg);
typedef struct pool_Chunk_11 pool_Chunk_11;
typedef pool_Chunk_11* pool_Chunk_11_ptr;
typedef union pool_Slot_11 pool_Slot_11;
typedef pool_Slot_11* pool_Slot_11_ptr;
typedef struct event_Subscription_5 event_Subscription_5;
typedef struct main_event_Event_ObjectTryMove main_event_Event_ObjectTryMove;
typedef main_event_Event_ObjectTryMove* main_event_Event_ObjectTryMove_ptr;
typedef void (*function_3gc14SEe7fxwFFezK)(void*, main_event_Event_ObjectTryMove_ptr);
struct event_Subscription_5 {
  void* subscriber;
  function_3gc14SEe7fxwFFezK handler;
};
NELUA_STATIC_ASSERT(sizeof(event_Subscription_5) == 16 && NELUA_ALIGNOF(event_Subscription_5) == 8, "Nelua and C disagree on type size or align");
union pool_Slot_11 {
  pool_Slot_11_ptr next_free_slot;
  event_Subscription_5 element;
};
NELUA_STATIC_ASSERT(sizeof(pool_Slot_11) == 16 && NELUA_ALIGNOF(pool_Slot_11) == 8, "Nelua and C disagree on type size or align");
struct pool_Chunk_11 {
  pool_Chunk_11_ptr next;
  pool_Slot_11 slots[16];
};
NELUA_STATIC_ASSERT(sizeof(pool_Chunk_11) == 264 && NELUA_ALIGNOF(pool_Chunk_11) == 8, "Nelua and C disagree on type size or align");
struct main_event_Event_ObjectTryMove {
  main_Object_ptr obj;
  main_vec2 destination;
  bool cancel;
};
NELUA_STATIC_ASSERT(sizeof(main_event_Event_ObjectTryMove) == 24 && NELUA_ALIGNOF(main_event_Event_ObjectTryMove) == 8, "Nelua and C disagree on type size or align");
static NELUA_NOINLINE pool_Chunk_11_ptr nelua_GCAllocator_new_14(nelua_GCAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags);
static void nelua_assert_line_38(bool cond, nlstring msg);
typedef struct pool_Chunk_12 pool_Chunk_12;
typedef pool_Chunk_12* pool_Chunk_12_ptr;
typedef union pool_Slot_12 pool_Slot_12;
typedef pool_Slot_12* pool_Slot_12_ptr;
typedef struct list_Node_6 list_Node_6;
typedef event_Subscription_5* event_Subscription_5_ptr;
typedef list_Node_6* list_Node_6_ptr;
struct list_Node_6 {
  event_Subscription_5_ptr data;
  list_Node_6_ptr next;
};
NELUA_STATIC_ASSERT(sizeof(list_Node_6) == 16 && NELUA_ALIGNOF(list_Node_6) == 8, "Nelua and C disagree on type size or align");
union pool_Slot_12 {
  pool_Slot_12_ptr next_free_slot;
  list_Node_6 element;
};
NELUA_STATIC_ASSERT(sizeof(pool_Slot_12) == 16 && NELUA_ALIGNOF(pool_Slot_12) == 8, "Nelua and C disagree on type size or align");
struct pool_Chunk_12 {
  pool_Chunk_12_ptr next;
  pool_Slot_12 slots[16];
};
NELUA_STATIC_ASSERT(sizeof(pool_Chunk_12) == 264 && NELUA_ALIGNOF(pool_Chunk_12) == 8, "Nelua and C disagree on type size or align");
static NELUA_NOINLINE pool_Chunk_12_ptr nelua_GCAllocator_new_15(nelua_GCAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags);
static void nelua_assert_line_39(bool cond, nlstring msg);
typedef struct pool_Chunk_13 pool_Chunk_13;
typedef pool_Chunk_13* pool_Chunk_13_ptr;
typedef union pool_Slot_13 pool_Slot_13;
typedef pool_Slot_13* pool_Slot_13_ptr;
typedef struct event_Subscription_6 event_Subscription_6;
typedef struct main_event_Event_KeyPressed main_event_Event_KeyPressed;
typedef main_event_Event_KeyPressed* main_event_Event_KeyPressed_ptr;
typedef void (*function_3uWno6F81YYRMaqKx)(void*, main_event_Event_KeyPressed_ptr);
struct event_Subscription_6 {
  void* subscriber;
  function_3uWno6F81YYRMaqKx handler;
};
NELUA_STATIC_ASSERT(sizeof(event_Subscription_6) == 16 && NELUA_ALIGNOF(event_Subscription_6) == 8, "Nelua and C disagree on type size or align");
union pool_Slot_13 {
  pool_Slot_13_ptr next_free_slot;
  event_Subscription_6 element;
};
NELUA_STATIC_ASSERT(sizeof(pool_Slot_13) == 16 && NELUA_ALIGNOF(pool_Slot_13) == 8, "Nelua and C disagree on type size or align");
struct pool_Chunk_13 {
  pool_Chunk_13_ptr next;
  pool_Slot_13 slots[16];
};
NELUA_STATIC_ASSERT(sizeof(pool_Chunk_13) == 264 && NELUA_ALIGNOF(pool_Chunk_13) == 8, "Nelua and C disagree on type size or align");
struct main_event_Event_KeyPressed {
  uint8_t key;
};
NELUA_STATIC_ASSERT(sizeof(main_event_Event_KeyPressed) == 1 && NELUA_ALIGNOF(main_event_Event_KeyPressed) == 1, "Nelua and C disagree on type size or align");
static NELUA_NOINLINE pool_Chunk_13_ptr nelua_GCAllocator_new_16(nelua_GCAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags);
static void nelua_assert_line_40(bool cond, nlstring msg);
typedef struct pool_Chunk_14 pool_Chunk_14;
typedef pool_Chunk_14* pool_Chunk_14_ptr;
typedef union pool_Slot_14 pool_Slot_14;
typedef pool_Slot_14* pool_Slot_14_ptr;
typedef struct list_Node_7 list_Node_7;
typedef event_Subscription_6* event_Subscription_6_ptr;
typedef list_Node_7* list_Node_7_ptr;
struct list_Node_7 {
  event_Subscription_6_ptr data;
  list_Node_7_ptr next;
};
NELUA_STATIC_ASSERT(sizeof(list_Node_7) == 16 && NELUA_ALIGNOF(list_Node_7) == 8, "Nelua and C disagree on type size or align");
union pool_Slot_14 {
  pool_Slot_14_ptr next_free_slot;
  list_Node_7 element;
};
NELUA_STATIC_ASSERT(sizeof(pool_Slot_14) == 16 && NELUA_ALIGNOF(pool_Slot_14) == 8, "Nelua and C disagree on type size or align");
struct pool_Chunk_14 {
  pool_Chunk_14_ptr next;
  pool_Slot_14 slots[16];
};
NELUA_STATIC_ASSERT(sizeof(pool_Chunk_14) == 264 && NELUA_ALIGNOF(pool_Chunk_14) == 8, "Nelua and C disagree on type size or align");
static NELUA_NOINLINE pool_Chunk_14_ptr nelua_GCAllocator_new_17(nelua_GCAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags);
static void nelua_assert_line_41(bool cond, nlstring msg);
static NELUA_NOINLINE pool_Chunk_15_ptr nelua_GCAllocator_new_18(nelua_GCAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags);
static void nelua_assert_line_42(bool cond, nlstring msg);
typedef struct pool_Chunk_16 pool_Chunk_16;
typedef pool_Chunk_16* pool_Chunk_16_ptr;
typedef union pool_Slot_16 pool_Slot_16;
typedef pool_Slot_16* pool_Slot_16_ptr;
typedef struct list_Node_9 list_Node_9;
typedef list_Node_9* list_Node_9_ptr;
struct list_Node_9 {
  main_Object_ptr data;
  list_Node_9_ptr next;
};
NELUA_STATIC_ASSERT(sizeof(list_Node_9) == 16 && NELUA_ALIGNOF(list_Node_9) == 8, "Nelua and C disagree on type size or align");
union pool_Slot_16 {
  pool_Slot_16_ptr next_free_slot;
  list_Node_9 element;
};
NELUA_STATIC_ASSERT(sizeof(pool_Slot_16) == 16 && NELUA_ALIGNOF(pool_Slot_16) == 8, "Nelua and C disagree on type size or align");
struct pool_Chunk_16 {
  pool_Chunk_16_ptr next;
  pool_Slot_16 slots[16];
};
NELUA_STATIC_ASSERT(sizeof(pool_Chunk_16) == 264 && NELUA_ALIGNOF(pool_Chunk_16) == 8, "Nelua and C disagree on type size or align");
static NELUA_NOINLINE pool_Chunk_16_ptr nelua_GCAllocator_new_19(nelua_GCAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags);
static void nelua_assert_line_43(bool cond, nlstring msg);
static NELUA_NOINLINE main_Player_ptr nelua_GCAllocator_new_20(nelua_GCAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags);
static void nelua_assert_line_44(bool cond, nlstring msg);
static NELUA_NOINLINE main_Animal_ptr nelua_GCAllocator_new_21(nelua_GCAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags);
static void nelua_assert_line_45(bool cond, nlstring msg);
static void* nelua_GCAllocator_xalloc_1(nelua_GCAllocator_ptr self, uintptr_t size, nlniltype flags);
static void* nelua_GCAllocator_realloc0(nelua_GCAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize);
static void nelua_GCAllocator_spandealloc_1(nelua_GCAllocator_ptr self, nelua_span_uint8_ s);
static nelua_span_uint8_ nelua_GCAllocator_spanrealloc_1(nelua_GCAllocator_ptr self, nelua_span_uint8_ s, uintptr_t size);
static nelua_span_uint8_ nelua_GCAllocator_xspanrealloc_1(nelua_GCAllocator_ptr self, nelua_span_uint8_ s, uintptr_t size);
static nelua_span_uint8_ nelua_GCAllocator_spanrealloc0_1(nelua_GCAllocator_ptr self, nelua_span_uint8_ s, uintptr_t size);
static main_Player_ptr nelua_new_1(nlniltype what, nlniltype size, nlniltype flags);
static main_Animal_ptr nelua_new_2(nlniltype what, nlniltype size, nlniltype flags);
static nelua_GCAllocator pool_allocator;
typedef struct pool_PoolT_1 pool_PoolT_1;
typedef pool_PoolT_1* pool_PoolT_1_ptr;
struct pool_PoolT_1 {
  pool_Chunk_1_ptr current_chunk;
  pool_Slot_1_ptr free_slot;
};
NELUA_STATIC_ASSERT(sizeof(pool_PoolT_1) == 16 && NELUA_ALIGNOF(pool_PoolT_1) == 8, "Nelua and C disagree on type size or align");
static void pool_PoolT_1_newChunk(pool_PoolT_1_ptr self);
static void pool_PoolT_1_init(pool_PoolT_1_ptr self);
typedef struct pool_PoolT_2 pool_PoolT_2;
typedef pool_PoolT_2* pool_PoolT_2_ptr;
struct pool_PoolT_2 {
  pool_Chunk_2_ptr current_chunk;
  pool_Slot_2_ptr free_slot;
};
NELUA_STATIC_ASSERT(sizeof(pool_PoolT_2) == 16 && NELUA_ALIGNOF(pool_PoolT_2) == 8, "Nelua and C disagree on type size or align");
static void pool_PoolT_2_newChunk(pool_PoolT_2_ptr self);
static void pool_PoolT_2_init(pool_PoolT_2_ptr self);
typedef struct pool_PoolT_3 pool_PoolT_3;
typedef pool_PoolT_3* pool_PoolT_3_ptr;
struct pool_PoolT_3 {
  pool_Chunk_3_ptr current_chunk;
  pool_Slot_3_ptr free_slot;
};
NELUA_STATIC_ASSERT(sizeof(pool_PoolT_3) == 16 && NELUA_ALIGNOF(pool_PoolT_3) == 8, "Nelua and C disagree on type size or align");
static void pool_PoolT_3_newChunk(pool_PoolT_3_ptr self);
static void pool_PoolT_3_init(pool_PoolT_3_ptr self);
static event_Subscription_1_ptr pool_PoolT_3_add(pool_PoolT_3_ptr self);
typedef struct pool_PoolT_4 pool_PoolT_4;
typedef pool_PoolT_4* pool_PoolT_4_ptr;
struct pool_PoolT_4 {
  pool_Chunk_4_ptr current_chunk;
  pool_Slot_4_ptr free_slot;
};
NELUA_STATIC_ASSERT(sizeof(pool_PoolT_4) == 16 && NELUA_ALIGNOF(pool_PoolT_4) == 8, "Nelua and C disagree on type size or align");
static void pool_PoolT_4_newChunk(pool_PoolT_4_ptr self);
static void pool_PoolT_4_init(pool_PoolT_4_ptr self);
static list_Node_2_ptr pool_PoolT_4_add(pool_PoolT_4_ptr self);
typedef struct pool_PoolT_5 pool_PoolT_5;
typedef pool_PoolT_5* pool_PoolT_5_ptr;
struct pool_PoolT_5 {
  pool_Chunk_5_ptr current_chunk;
  pool_Slot_5_ptr free_slot;
};
NELUA_STATIC_ASSERT(sizeof(pool_PoolT_5) == 16 && NELUA_ALIGNOF(pool_PoolT_5) == 8, "Nelua and C disagree on type size or align");
static void pool_PoolT_5_newChunk(pool_PoolT_5_ptr self);
static void pool_PoolT_5_init(pool_PoolT_5_ptr self);
static event_Subscription_2_ptr pool_PoolT_5_add(pool_PoolT_5_ptr self);
typedef struct pool_PoolT_6 pool_PoolT_6;
typedef pool_PoolT_6* pool_PoolT_6_ptr;
struct pool_PoolT_6 {
  pool_Chunk_6_ptr current_chunk;
  pool_Slot_6_ptr free_slot;
};
NELUA_STATIC_ASSERT(sizeof(pool_PoolT_6) == 16 && NELUA_ALIGNOF(pool_PoolT_6) == 8, "Nelua and C disagree on type size or align");
static void pool_PoolT_6_newChunk(pool_PoolT_6_ptr self);
static void pool_PoolT_6_init(pool_PoolT_6_ptr self);
static list_Node_3_ptr pool_PoolT_6_add(pool_PoolT_6_ptr self);
typedef struct pool_PoolT_7 pool_PoolT_7;
typedef pool_PoolT_7* pool_PoolT_7_ptr;
struct pool_PoolT_7 {
  pool_Chunk_7_ptr current_chunk;
  pool_Slot_7_ptr free_slot;
};
NELUA_STATIC_ASSERT(sizeof(pool_PoolT_7) == 16 && NELUA_ALIGNOF(pool_PoolT_7) == 8, "Nelua and C disagree on type size or align");
static void pool_PoolT_7_newChunk(pool_PoolT_7_ptr self);
static void pool_PoolT_7_init(pool_PoolT_7_ptr self);
static event_Subscription_3_ptr pool_PoolT_7_add(pool_PoolT_7_ptr self);
typedef struct pool_PoolT_8 pool_PoolT_8;
typedef pool_PoolT_8* pool_PoolT_8_ptr;
struct pool_PoolT_8 {
  pool_Chunk_8_ptr current_chunk;
  pool_Slot_8_ptr free_slot;
};
NELUA_STATIC_ASSERT(sizeof(pool_PoolT_8) == 16 && NELUA_ALIGNOF(pool_PoolT_8) == 8, "Nelua and C disagree on type size or align");
static void pool_PoolT_8_newChunk(pool_PoolT_8_ptr self);
static void pool_PoolT_8_init(pool_PoolT_8_ptr self);
static list_Node_4_ptr pool_PoolT_8_add(pool_PoolT_8_ptr self);
typedef struct pool_PoolT_9 pool_PoolT_9;
typedef pool_PoolT_9* pool_PoolT_9_ptr;
struct pool_PoolT_9 {
  pool_Chunk_9_ptr current_chunk;
  pool_Slot_9_ptr free_slot;
};
NELUA_STATIC_ASSERT(sizeof(pool_PoolT_9) == 16 && NELUA_ALIGNOF(pool_PoolT_9) == 8, "Nelua and C disagree on type size or align");
static void pool_PoolT_9_newChunk(pool_PoolT_9_ptr self);
static void pool_PoolT_9_init(pool_PoolT_9_ptr self);
static event_Subscription_4_ptr pool_PoolT_9_add(pool_PoolT_9_ptr self);
typedef struct pool_PoolT_10 pool_PoolT_10;
typedef pool_PoolT_10* pool_PoolT_10_ptr;
struct pool_PoolT_10 {
  pool_Chunk_10_ptr current_chunk;
  pool_Slot_10_ptr free_slot;
};
NELUA_STATIC_ASSERT(sizeof(pool_PoolT_10) == 16 && NELUA_ALIGNOF(pool_PoolT_10) == 8, "Nelua and C disagree on type size or align");
static void pool_PoolT_10_newChunk(pool_PoolT_10_ptr self);
static void pool_PoolT_10_init(pool_PoolT_10_ptr self);
static list_Node_5_ptr pool_PoolT_10_add(pool_PoolT_10_ptr self);
typedef struct pool_PoolT_11 pool_PoolT_11;
typedef pool_PoolT_11* pool_PoolT_11_ptr;
struct pool_PoolT_11 {
  pool_Chunk_11_ptr current_chunk;
  pool_Slot_11_ptr free_slot;
};
NELUA_STATIC_ASSERT(sizeof(pool_PoolT_11) == 16 && NELUA_ALIGNOF(pool_PoolT_11) == 8, "Nelua and C disagree on type size or align");
static void pool_PoolT_11_newChunk(pool_PoolT_11_ptr self);
static void pool_PoolT_11_init(pool_PoolT_11_ptr self);
static event_Subscription_5_ptr pool_PoolT_11_add(pool_PoolT_11_ptr self);
typedef struct pool_PoolT_12 pool_PoolT_12;
typedef pool_PoolT_12* pool_PoolT_12_ptr;
struct pool_PoolT_12 {
  pool_Chunk_12_ptr current_chunk;
  pool_Slot_12_ptr free_slot;
};
NELUA_STATIC_ASSERT(sizeof(pool_PoolT_12) == 16 && NELUA_ALIGNOF(pool_PoolT_12) == 8, "Nelua and C disagree on type size or align");
static void pool_PoolT_12_newChunk(pool_PoolT_12_ptr self);
static void pool_PoolT_12_init(pool_PoolT_12_ptr self);
static list_Node_6_ptr pool_PoolT_12_add(pool_PoolT_12_ptr self);
typedef struct pool_PoolT_13 pool_PoolT_13;
typedef pool_PoolT_13* pool_PoolT_13_ptr;
struct pool_PoolT_13 {
  pool_Chunk_13_ptr current_chunk;
  pool_Slot_13_ptr free_slot;
};
NELUA_STATIC_ASSERT(sizeof(pool_PoolT_13) == 16 && NELUA_ALIGNOF(pool_PoolT_13) == 8, "Nelua and C disagree on type size or align");
static void pool_PoolT_13_newChunk(pool_PoolT_13_ptr self);
static void pool_PoolT_13_init(pool_PoolT_13_ptr self);
static event_Subscription_6_ptr pool_PoolT_13_add(pool_PoolT_13_ptr self);
typedef struct pool_PoolT_14 pool_PoolT_14;
typedef pool_PoolT_14* pool_PoolT_14_ptr;
struct pool_PoolT_14 {
  pool_Chunk_14_ptr current_chunk;
  pool_Slot_14_ptr free_slot;
};
NELUA_STATIC_ASSERT(sizeof(pool_PoolT_14) == 16 && NELUA_ALIGNOF(pool_PoolT_14) == 8, "Nelua and C disagree on type size or align");
static void pool_PoolT_14_newChunk(pool_PoolT_14_ptr self);
static void pool_PoolT_14_init(pool_PoolT_14_ptr self);
static list_Node_7_ptr pool_PoolT_14_add(pool_PoolT_14_ptr self);
typedef pool_PoolT_15* pool_PoolT_15_ptr;
static void pool_PoolT_15_newChunk(pool_PoolT_15_ptr self);
static void pool_PoolT_15_init(pool_PoolT_15_ptr self);
static list_Node_8_ptr pool_PoolT_15_add(pool_PoolT_15_ptr self);
static void pool_PoolT_15_remove(pool_PoolT_15_ptr self, list_Node_8_ptr x);
typedef struct pool_PoolT_16 pool_PoolT_16;
typedef pool_PoolT_16* pool_PoolT_16_ptr;
struct pool_PoolT_16 {
  pool_Chunk_16_ptr current_chunk;
  pool_Slot_16_ptr free_slot;
};
NELUA_STATIC_ASSERT(sizeof(pool_PoolT_16) == 16 && NELUA_ALIGNOF(pool_PoolT_16) == 8, "Nelua and C disagree on type size or align");
static void pool_PoolT_16_newChunk(pool_PoolT_16_ptr self);
static void pool_PoolT_16_init(pool_PoolT_16_ptr self);
static nltype nelua_require_pool(nlniltype modname);
static nltype nelua_require_pool_cached(nlniltype modname);
typedef struct list_SListT list_SListT;
typedef list_SListT* list_SListT_ptr;
struct list_SListT {
  pool_PoolT_2 pool;
  list_Node_1_ptr head;
};
NELUA_STATIC_ASSERT(sizeof(list_SListT) == 24 && NELUA_ALIGNOF(list_SListT) == 8, "Nelua and C disagree on type size or align");
static void list_SListT_init(list_SListT_ptr self);
typedef struct list_SListT_1 list_SListT_1;
typedef list_SListT_1* list_SListT_1_ptr;
struct list_SListT_1 {
  pool_PoolT_4 pool;
  list_Node_2_ptr head;
};
NELUA_STATIC_ASSERT(sizeof(list_SListT_1) == 24 && NELUA_ALIGNOF(list_SListT_1) == 8, "Nelua and C disagree on type size or align");
static void list_SListT_1_init(list_SListT_1_ptr self);
static list_Node_2_ptr list_SListT_1_push(list_SListT_1_ptr self, event_Subscription_1_ptr x);
typedef list_DList_2* list_DList_2_ptr;
static void list_DList_2_init(list_DList_2_ptr self);
static list_Node_8_ptr list_DList_2_insertBefore(list_DList_2_ptr self, list_Node_8_ptr x, main_Object_ptr v);
static list_Node_8_ptr list_DList_2_pushHead(list_DList_2_ptr self, main_Object_ptr x);
static void list_DList_2_unlink(list_DList_2_ptr self, list_Node_8_ptr x);
static void list_DList_2_remove(list_DList_2_ptr self, list_Node_8_ptr n);
static bool list_DList_2_isEmpty(list_DList_2_ptr self);
typedef struct nlmulret_nlboolean_list_Node_2_ptr_event_Subscription_1_ptr {
  bool r1;
  list_Node_2_ptr r2;
  event_Subscription_1_ptr r3;
} nlmulret_nlboolean_list_Node_2_ptr_event_Subscription_1_ptr;
static nlmulret_nlboolean_list_Node_2_ptr_event_Subscription_1_ptr list_SListT_1___next(list_SListT_1_ptr self, list_Node_2_ptr n);
typedef nlmulret_nlboolean_list_Node_2_ptr_event_Subscription_1_ptr (*function_3pW14qWtCTEhgcCu8)(list_SListT_1_ptr, list_Node_2_ptr);
typedef struct nlmulret_function_3pW14qWtCTEhgcCu8_list_SListT_1_ptr_nlnilptr {
  function_3pW14qWtCTEhgcCu8 r1;
  list_SListT_1_ptr r2;
  void* r3;
} nlmulret_function_3pW14qWtCTEhgcCu8_list_SListT_1_ptr_nlnilptr;
static nlmulret_function_3pW14qWtCTEhgcCu8_list_SListT_1_ptr_nlnilptr list_SListT_1_each(list_SListT_1_ptr self);
typedef struct list_SListT_2 list_SListT_2;
typedef list_SListT_2* list_SListT_2_ptr;
struct list_SListT_2 {
  pool_PoolT_6 pool;
  list_Node_3_ptr head;
};
NELUA_STATIC_ASSERT(sizeof(list_SListT_2) == 24 && NELUA_ALIGNOF(list_SListT_2) == 8, "Nelua and C disagree on type size or align");
static void list_SListT_2_init(list_SListT_2_ptr self);
static list_Node_3_ptr list_SListT_2_push(list_SListT_2_ptr self, event_Subscription_2_ptr x);
typedef struct nlmulret_nlboolean_list_Node_3_ptr_event_Subscription_2_ptr {
  bool r1;
  list_Node_3_ptr r2;
  event_Subscription_2_ptr r3;
} nlmulret_nlboolean_list_Node_3_ptr_event_Subscription_2_ptr;
static nlmulret_nlboolean_list_Node_3_ptr_event_Subscription_2_ptr list_SListT_2___next(list_SListT_2_ptr self, list_Node_3_ptr n);
typedef nlmulret_nlboolean_list_Node_3_ptr_event_Subscription_2_ptr (*function_4dNpuBYcNpbgam6wu)(list_SListT_2_ptr, list_Node_3_ptr);
typedef struct nlmulret_function_4dNpuBYcNpbgam6wu_list_SListT_2_ptr_nlnilptr {
  function_4dNpuBYcNpbgam6wu r1;
  list_SListT_2_ptr r2;
  void* r3;
} nlmulret_function_4dNpuBYcNpbgam6wu_list_SListT_2_ptr_nlnilptr;
static nlmulret_function_4dNpuBYcNpbgam6wu_list_SListT_2_ptr_nlnilptr list_SListT_2_each(list_SListT_2_ptr self);
typedef struct list_SListT_3 list_SListT_3;
typedef list_SListT_3* list_SListT_3_ptr;
struct list_SListT_3 {
  pool_PoolT_8 pool;
  list_Node_4_ptr head;
};
NELUA_STATIC_ASSERT(sizeof(list_SListT_3) == 24 && NELUA_ALIGNOF(list_SListT_3) == 8, "Nelua and C disagree on type size or align");
static void list_SListT_3_init(list_SListT_3_ptr self);
static list_Node_4_ptr list_SListT_3_push(list_SListT_3_ptr self, event_Subscription_3_ptr x);
typedef struct nlmulret_nlboolean_list_Node_4_ptr_event_Subscription_3_ptr {
  bool r1;
  list_Node_4_ptr r2;
  event_Subscription_3_ptr r3;
} nlmulret_nlboolean_list_Node_4_ptr_event_Subscription_3_ptr;
static nlmulret_nlboolean_list_Node_4_ptr_event_Subscription_3_ptr list_SListT_3___next(list_SListT_3_ptr self, list_Node_4_ptr n);
typedef nlmulret_nlboolean_list_Node_4_ptr_event_Subscription_3_ptr (*function_5xCyqTDq2WN4Nxi7)(list_SListT_3_ptr, list_Node_4_ptr);
typedef struct nlmulret_function_5xCyqTDq2WN4Nxi7_list_SListT_3_ptr_nlnilptr {
  function_5xCyqTDq2WN4Nxi7 r1;
  list_SListT_3_ptr r2;
  void* r3;
} nlmulret_function_5xCyqTDq2WN4Nxi7_list_SListT_3_ptr_nlnilptr;
static nlmulret_function_5xCyqTDq2WN4Nxi7_list_SListT_3_ptr_nlnilptr list_SListT_3_each(list_SListT_3_ptr self);
typedef struct list_SListT_4 list_SListT_4;
typedef list_SListT_4* list_SListT_4_ptr;
struct list_SListT_4 {
  pool_PoolT_10 pool;
  list_Node_5_ptr head;
};
NELUA_STATIC_ASSERT(sizeof(list_SListT_4) == 24 && NELUA_ALIGNOF(list_SListT_4) == 8, "Nelua and C disagree on type size or align");
static void list_SListT_4_init(list_SListT_4_ptr self);
static list_Node_5_ptr list_SListT_4_push(list_SListT_4_ptr self, event_Subscription_4_ptr x);
typedef struct nlmulret_nlboolean_list_Node_5_ptr_event_Subscription_4_ptr {
  bool r1;
  list_Node_5_ptr r2;
  event_Subscription_4_ptr r3;
} nlmulret_nlboolean_list_Node_5_ptr_event_Subscription_4_ptr;
static nlmulret_nlboolean_list_Node_5_ptr_event_Subscription_4_ptr list_SListT_4___next(list_SListT_4_ptr self, list_Node_5_ptr n);
typedef nlmulret_nlboolean_list_Node_5_ptr_event_Subscription_4_ptr (*function_5bJJn15qp3DNA8yzW)(list_SListT_4_ptr, list_Node_5_ptr);
typedef struct nlmulret_function_5bJJn15qp3DNA8yzW_list_SListT_4_ptr_nlnilptr {
  function_5bJJn15qp3DNA8yzW r1;
  list_SListT_4_ptr r2;
  void* r3;
} nlmulret_function_5bJJn15qp3DNA8yzW_list_SListT_4_ptr_nlnilptr;
static nlmulret_function_5bJJn15qp3DNA8yzW_list_SListT_4_ptr_nlnilptr list_SListT_4_each(list_SListT_4_ptr self);
typedef struct list_SListT_5 list_SListT_5;
typedef list_SListT_5* list_SListT_5_ptr;
struct list_SListT_5 {
  pool_PoolT_12 pool;
  list_Node_6_ptr head;
};
NELUA_STATIC_ASSERT(sizeof(list_SListT_5) == 24 && NELUA_ALIGNOF(list_SListT_5) == 8, "Nelua and C disagree on type size or align");
static void list_SListT_5_init(list_SListT_5_ptr self);
static list_Node_6_ptr list_SListT_5_push(list_SListT_5_ptr self, event_Subscription_5_ptr x);
typedef struct list_SListT_7 list_SListT_7;
typedef list_SListT_7* list_SListT_7_ptr;
struct list_SListT_7 {
  pool_PoolT_16 pool;
  list_Node_9_ptr head;
};
NELUA_STATIC_ASSERT(sizeof(list_SListT_7) == 24 && NELUA_ALIGNOF(list_SListT_7) == 8, "Nelua and C disagree on type size or align");
static void list_SListT_7_init(list_SListT_7_ptr self);
typedef struct nlmulret_nlboolean_list_Node_6_ptr_event_Subscription_5_ptr {
  bool r1;
  list_Node_6_ptr r2;
  event_Subscription_5_ptr r3;
} nlmulret_nlboolean_list_Node_6_ptr_event_Subscription_5_ptr;
static nlmulret_nlboolean_list_Node_6_ptr_event_Subscription_5_ptr list_SListT_5___next(list_SListT_5_ptr self, list_Node_6_ptr n);
typedef nlmulret_nlboolean_list_Node_6_ptr_event_Subscription_5_ptr (*function_2cfA3uKMBDnNKyrSf)(list_SListT_5_ptr, list_Node_6_ptr);
typedef struct nlmulret_function_2cfA3uKMBDnNKyrSf_list_SListT_5_ptr_nlnilptr {
  function_2cfA3uKMBDnNKyrSf r1;
  list_SListT_5_ptr r2;
  void* r3;
} nlmulret_function_2cfA3uKMBDnNKyrSf_list_SListT_5_ptr_nlnilptr;
static nlmulret_function_2cfA3uKMBDnNKyrSf_list_SListT_5_ptr_nlnilptr list_SListT_5_each(list_SListT_5_ptr self);
typedef struct list_SListT_6 list_SListT_6;
typedef list_SListT_6* list_SListT_6_ptr;
struct list_SListT_6 {
  pool_PoolT_14 pool;
  list_Node_7_ptr head;
};
NELUA_STATIC_ASSERT(sizeof(list_SListT_6) == 24 && NELUA_ALIGNOF(list_SListT_6) == 8, "Nelua and C disagree on type size or align");
static void list_SListT_6_init(list_SListT_6_ptr self);
static list_Node_7_ptr list_SListT_6_push(list_SListT_6_ptr self, event_Subscription_6_ptr x);
typedef struct nlmulret_nlboolean_list_Node_7_ptr_event_Subscription_6_ptr {
  bool r1;
  list_Node_7_ptr r2;
  event_Subscription_6_ptr r3;
} nlmulret_nlboolean_list_Node_7_ptr_event_Subscription_6_ptr;
static nlmulret_nlboolean_list_Node_7_ptr_event_Subscription_6_ptr list_SListT_6___next(list_SListT_6_ptr self, list_Node_7_ptr n);
typedef nlmulret_nlboolean_list_Node_7_ptr_event_Subscription_6_ptr (*function_4oongp4zBQ9NUBLmT)(list_SListT_6_ptr, list_Node_7_ptr);
typedef struct nlmulret_function_4oongp4zBQ9NUBLmT_list_SListT_6_ptr_nlnilptr {
  function_4oongp4zBQ9NUBLmT r1;
  list_SListT_6_ptr r2;
  void* r3;
} nlmulret_function_4oongp4zBQ9NUBLmT_list_SListT_6_ptr_nlnilptr;
static nlmulret_function_4oongp4zBQ9NUBLmT_list_SListT_6_ptr_nlnilptr list_SListT_6_each(list_SListT_6_ptr self);
static void nelua_require_list(nlniltype modname);
static void nelua_require_list_cached(nlniltype modname);
typedef struct event_SubListT event_SubListT;
typedef event_SubListT* event_SubListT_ptr;
struct event_SubListT {
  pool_PoolT_1 pool;
  list_SListT list;
};
NELUA_STATIC_ASSERT(sizeof(event_SubListT) == 40 && NELUA_ALIGNOF(event_SubListT) == 8, "Nelua and C disagree on type size or align");
static void event_SubListT_init(event_SubListT_ptr self);
typedef struct event_SubListT_1 event_SubListT_1;
typedef event_SubListT_1* event_SubListT_1_ptr;
struct event_SubListT_1 {
  pool_PoolT_3 pool;
  list_SListT_1 list;
};
NELUA_STATIC_ASSERT(sizeof(event_SubListT_1) == 40 && NELUA_ALIGNOF(event_SubListT_1) == 8, "Nelua and C disagree on type size or align");
static void event_SubListT_1_init(event_SubListT_1_ptr self);
typedef void (*function_SPt3RC6SJoHTFZr8)(void*, main_event_Event_AnimalDeath_ptr);
static void event_SubListT_1_sub(event_SubListT_1_ptr self, void* subscriber, function_SPt3RC6SJoHTFZr8 handler);
static void event_SubListT_1_emit(event_SubListT_1_ptr self, main_event_Event_AnimalDeath_ptr event);
typedef struct event_SubListT_2 event_SubListT_2;
typedef event_SubListT_2* event_SubListT_2_ptr;
struct event_SubListT_2 {
  pool_PoolT_5 pool;
  list_SListT_2 list;
};
NELUA_STATIC_ASSERT(sizeof(event_SubListT_2) == 40 && NELUA_ALIGNOF(event_SubListT_2) == 8, "Nelua and C disagree on type size or align");
static void event_SubListT_2_init(event_SubListT_2_ptr self);
typedef void (*function_5WmHNW6Q3YTCamKZg)(void*, main_event_Event_ObjectMoved_ptr);
static void event_SubListT_2_sub(event_SubListT_2_ptr self, void* subscriber, function_5WmHNW6Q3YTCamKZg handler);
static void event_SubListT_2_emit(event_SubListT_2_ptr self, main_event_Event_ObjectMoved_ptr event);
typedef struct event_SubListT_3 event_SubListT_3;
typedef event_SubListT_3* event_SubListT_3_ptr;
struct event_SubListT_3 {
  pool_PoolT_7 pool;
  list_SListT_3 list;
};
NELUA_STATIC_ASSERT(sizeof(event_SubListT_3) == 40 && NELUA_ALIGNOF(event_SubListT_3) == 8, "Nelua and C disagree on type size or align");
static void event_SubListT_3_init(event_SubListT_3_ptr self);
typedef void (*function_2mNVtgWabEqXKo4yi)(void*, main_event_Event_PlayerAttack_ptr);
static void event_SubListT_3_sub(event_SubListT_3_ptr self, void* subscriber, function_2mNVtgWabEqXKo4yi handler);
static void event_SubListT_3_emit(event_SubListT_3_ptr self, main_event_Event_PlayerAttack_ptr event);
typedef struct event_SubListT_4 event_SubListT_4;
typedef event_SubListT_4* event_SubListT_4_ptr;
struct event_SubListT_4 {
  pool_PoolT_9 pool;
  list_SListT_4 list;
};
NELUA_STATIC_ASSERT(sizeof(event_SubListT_4) == 40 && NELUA_ALIGNOF(event_SubListT_4) == 8, "Nelua and C disagree on type size or align");
static void event_SubListT_4_init(event_SubListT_4_ptr self);
typedef void (*function_3mHTWKBsxSdaL6ffP)(void*, main_event_Event_AnimalDamaged_ptr);
static void event_SubListT_4_sub(event_SubListT_4_ptr self, void* subscriber, function_3mHTWKBsxSdaL6ffP handler);
static void event_SubListT_4_emit(event_SubListT_4_ptr self, main_event_Event_AnimalDamaged_ptr event);
typedef struct event_SubListT_5 event_SubListT_5;
typedef event_SubListT_5* event_SubListT_5_ptr;
struct event_SubListT_5 {
  pool_PoolT_11 pool;
  list_SListT_5 list;
};
NELUA_STATIC_ASSERT(sizeof(event_SubListT_5) == 40 && NELUA_ALIGNOF(event_SubListT_5) == 8, "Nelua and C disagree on type size or align");
static void event_SubListT_5_init(event_SubListT_5_ptr self);
typedef void (*function_2X5NxKm2r8X1th4sE)(void*, main_event_Event_ObjectTryMove_ptr);
static void event_SubListT_5_sub(event_SubListT_5_ptr self, void* subscriber, function_2X5NxKm2r8X1th4sE handler);
static void event_SubListT_5_emit(event_SubListT_5_ptr self, main_event_Event_ObjectTryMove_ptr event);
typedef struct event_SubListT_6 event_SubListT_6;
typedef event_SubListT_6* event_SubListT_6_ptr;
struct event_SubListT_6 {
  pool_PoolT_13 pool;
  list_SListT_6 list;
};
NELUA_STATIC_ASSERT(sizeof(event_SubListT_6) == 40 && NELUA_ALIGNOF(event_SubListT_6) == 8, "Nelua and C disagree on type size or align");
static void event_SubListT_6_init(event_SubListT_6_ptr self);
typedef void (*function_3UduMYNKBeNiJPjWr)(void*, main_event_Event_KeyPressed_ptr);
static void event_SubListT_6_sub(event_SubListT_6_ptr self, void* subscriber, function_3UduMYNKBeNiJPjWr handler);
static void event_SubListT_6_emit(event_SubListT_6_ptr self, main_event_Event_KeyPressed_ptr event);
static nltype nelua_require_event(nlniltype modname);
typedef struct NELUA_MAYALIAS nluint8_arr48 {uint8_t v[48];} nluint8_arr48;
typedef union NELUA_MAYALIAS nluint8_arr48_cast {nluint8_arr48 a; uint8_t p[48];} nluint8_arr48_cast;
NELUA_STATIC_ASSERT(sizeof(nluint8_arr48) == 48 && NELUA_ALIGNOF(nluint8_arr48) == 1, "Nelua and C disagree on type size or align");
typedef nluint8_arr48* nluint8_arr48_ptr;
static nlstring nelua_strconv_1_int2str_2(nluint8_arr48_ptr buf, intptr_t x, nlniltype base);
static NELUA_INLINE uintptr_t nelua_assert_bounds_nlusize(uintptr_t index, uintptr_t len);
typedef struct nelua_stringbuilderT nelua_stringbuilderT;
typedef nelua_stringbuilderT* nelua_stringbuilderT_ptr;
struct nelua_stringbuilderT {
  nelua_span_uint8_ data;
  uintptr_t size;
  nelua_GCAllocator allocator;
};
NELUA_STATIC_ASSERT(sizeof(nelua_stringbuilderT) == 24 && NELUA_ALIGNOF(nelua_stringbuilderT) == 8, "Nelua and C disagree on type size or align");
static void nelua_stringbuilderT_destroy(nelua_stringbuilderT_ptr self);
static bool nelua_stringbuilderT_grow(nelua_stringbuilderT_ptr self, uintptr_t newsize);
static nelua_span_uint8_ nelua_stringbuilderT_prepare(nelua_stringbuilderT_ptr self, uintptr_t n);
static void nelua_stringbuilderT_commit(nelua_stringbuilderT_ptr self, uintptr_t n);
static void nelua_assert_line_46(bool cond, nlstring msg);
static nlstring nelua_stringbuilderT_promote(nelua_stringbuilderT_ptr self);
static nlstring nelua_nlstring_create(uintptr_t size);
static void nelua_assert_line_47(bool cond, nlstring msg);
static void nelua_nlstring_destroy(nlstring_ptr self);
static nlstring nelua_nlstring_copy(nlstring s);
static NELUA_INLINE nluint8_ptr nelua_nlstring___atindex(nlstring s, uintptr_t i);
static void nelua_assert_line_48(bool cond, nlstring msg);
static NELUA_INLINE intptr_t nelua_nlstring___len(nlstring a);
static nlstring nelua_nlstring___concat_1(int32_t a, nlstring b);
static nlstring nelua_nlstring___concat_2(nlstring a, nlstring b);
static nlstring nelua_tostring_2(int32_t x);
typedef FILE* FILE_ptr;
typedef struct nelua_filestream nelua_filestream;
typedef nelua_filestream* nelua_filestream_ptr;
typedef struct nelua_FStream nelua_FStream;
typedef nelua_FStream* nelua_FStream_ptr;
struct nelua_filestream {
  nelua_FStream_ptr fs;
};
NELUA_STATIC_ASSERT(sizeof(nelua_filestream) == 8 && NELUA_ALIGNOF(nelua_filestream) == 8, "Nelua and C disagree on type size or align");
typedef int (*function_5TzZFr2X5qBkNwua4)(FILE_ptr);
struct nelua_FStream {
  FILE_ptr fp;
  function_5TzZFr2X5qBkNwua4 closef;
};
NELUA_STATIC_ASSERT(sizeof(nelua_FStream) == 16 && NELUA_ALIGNOF(nelua_FStream) == 8, "Nelua and C disagree on type size or align");
static NELUA_INLINE FILE_ptr nelua_filestream__getfp(nelua_filestream_ptr self);
typedef struct nlmulret_nlstring_nlint64 {
  nlstring r1;
  int64_t r2;
} nlmulret_nlstring_nlint64;
static nlmulret_nlstring_nlint64 nelua_geterrno(void);
static NELUA_INLINE nlstring nelua_cstring2string(const char* s);
typedef struct nlmulret_nlboolean_nlstring {
  bool r1;
  nlstring r2;
} nlmulret_nlboolean_nlstring;
static nlmulret_nlboolean_nlstring nelua_readchars(nelua_stringbuilderT_ptr sb, FILE_ptr fp, uintptr_t n);
typedef struct nlmulret_nlstring_nlstring_nlint64 {
  nlstring r1;
  nlstring r2;
  int64_t r3;
} nlmulret_nlstring_nlstring_nlint64;
static nlmulret_nlstring_nlstring_nlint64 nelua_filestream_read_1(nelua_filestream_ptr self, int64_t fmt);
typedef struct nlmulret_nlboolean_nlstring_nlint64 {
  bool r1;
  nlstring r2;
  int64_t r3;
} nlmulret_nlboolean_nlstring_nlint64;
static nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_write_1(nelua_filestream_ptr self, nlstring __arg1);
static nelua_FStream nelua_stdinfs;
static nelua_filestream nelua_io_stdin;
static nelua_FStream nelua_stdoutfs;
static nelua_filestream nelua_io_stdout;
static nlmulret_nlstring_nlstring_nlint64 nelua_io_read_1(int64_t fmt);
static nlmulret_nlboolean_nlstring_nlint64 nelua_io_write_1(nlstring __arg1);
static nltype nelua_require_io(nlniltype modname);
static void nelua_require_entmgr(nlniltype modname);
typedef main_vec2* main_vec2_ptr;
static nlstring main_vec2___tostring(main_vec2_ptr self);
typedef struct main_EventBusT main_EventBusT;
struct main_EventBusT {
  event_SubListT sublist_AfterEventProcessing;
  event_SubListT_1 sublist_AnimalDeath;
  event_SubListT_2 sublist_ObjectMoved;
  event_SubListT_3 sublist_PlayerAttack;
  event_SubListT_4 sublist_AnimalDamaged;
  event_SubListT_5 sublist_ObjectTryMove;
  event_SubListT_6 sublist_KeyPressed;
};
NELUA_STATIC_ASSERT(sizeof(main_EventBusT) == 280 && NELUA_ALIGNOF(main_EventBusT) == 8, "Nelua and C disagree on type size or align");
static main_EventBusT main_event_bus;
typedef main_EventBusT* main_EventBusT_ptr;
static void main_EventBusT_init(main_EventBusT_ptr self);
typedef void (*function_4WmBbjumsffDobLkA)(main_Player_ptr, main_event_Event_KeyPressed_ptr);
static void main_EventBusT_subscribeTo_1(main_EventBusT_ptr self, nlniltype event, void* subscriber, function_4WmBbjumsffDobLkA handler);
typedef void (*function_2RMqu9Y13j8kEs2Lg)(void*, main_event_Event_KeyPressed_ptr);
typedef void (*function_15AWPgqbccPV11c7)(main_Player_ptr, main_event_Event_AnimalDamaged_ptr);
static void main_EventBusT_subscribeTo_2(main_EventBusT_ptr self, nlniltype event, void* subscriber, function_15AWPgqbccPV11c7 handler);
typedef void (*function_oRZ7yVG9JpaZWeAa)(void*, main_event_Event_AnimalDamaged_ptr);
typedef void (*function_3s38JSQJHhFrY9ris)(main_Animal_ptr, main_event_Event_PlayerAttack_ptr);
static void main_EventBusT_subscribeTo_3(main_EventBusT_ptr self, nlniltype event, void* subscriber, function_3s38JSQJHhFrY9ris handler);
typedef void (*function_rgZz7Vgcn1eBw8fD)(void*, main_event_Event_PlayerAttack_ptr);
typedef struct main_Narrator main_Narrator;
typedef main_Narrator* main_Narrator_ptr;
typedef void (*function_2htbwEnNf7AXuQQHo)(main_Narrator_ptr, main_event_Event_PlayerAttack_ptr);
struct main_Narrator {};
static void main_EventBusT_subscribeTo_4(main_EventBusT_ptr self, nlniltype event, void* subscriber, function_2htbwEnNf7AXuQQHo handler);
typedef void (*function_2unX1KsA8mAv3LfB4)(void*, main_event_Event_PlayerAttack_ptr);
typedef void (*function_oBKPg1FFcB5Dg4Aw)(main_Narrator_ptr, main_event_Event_ObjectMoved_ptr);
static void main_EventBusT_subscribeTo_5(main_EventBusT_ptr self, nlniltype event, void* subscriber, function_oBKPg1FFcB5Dg4Aw handler);
typedef void (*function_HUcGJ63PhNaPPbUN)(void*, main_event_Event_ObjectMoved_ptr);
typedef void (*function_51hrVrGsWPLUqgN7q)(main_Narrator_ptr, main_event_Event_AnimalDeath_ptr);
static void main_EventBusT_subscribeTo_6(main_EventBusT_ptr self, nlniltype event, void* subscriber, function_51hrVrGsWPLUqgN7q handler);
typedef void (*function_smbtA6kyWbJcVXmB)(void*, main_event_Event_AnimalDeath_ptr);
typedef struct main_Map main_Map;
typedef main_Map* main_Map_ptr;
typedef void (*function_3Rhiu8maLRfEDva9C)(main_Map_ptr, main_event_Event_ObjectTryMove_ptr);
struct main_Map {
  list_SListT_7 deferred_removal;
  main_Tile tiles[49];
};
NELUA_STATIC_ASSERT(sizeof(main_Map) == 1984 && NELUA_ALIGNOF(main_Map) == 8, "Nelua and C disagree on type size or align");
static void main_EventBusT_subscribeTo_7(main_EventBusT_ptr self, nlniltype event, void* subscriber, function_3Rhiu8maLRfEDva9C handler);
typedef void (*function_mgToF1Ks5bFq6EaH)(void*, main_event_Event_ObjectTryMove_ptr);
typedef void (*function_4Y2Xurfya4ueffdc3)(main_Map_ptr, main_event_Event_ObjectMoved_ptr);
static void main_EventBusT_subscribeTo_8(main_EventBusT_ptr self, nlniltype event, void* subscriber, function_4Y2Xurfya4ueffdc3 handler);
typedef void (*function_4SCqEa4iBBx8mdkem)(void*, main_event_Event_ObjectMoved_ptr);
static void main_EventBusT_emit_1(main_EventBusT_ptr self, main_event_Event_KeyPressed event);
static void main_EventBusT_emit_2(main_EventBusT_ptr self, main_event_Event_PlayerAttack_ptr event);
static void main_EventBusT_emit_3(main_EventBusT_ptr self, main_event_Event_AnimalDeath_ptr event);
static void main_EventBusT_emit_4(main_EventBusT_ptr self, main_event_Event_AnimalDamaged_ptr event);
static void main_EventBusT_emit_5(main_EventBusT_ptr self, main_event_Event_ObjectTryMove_ptr event);
static void main_EventBusT_emit_6(main_EventBusT_ptr self, main_event_Event_ObjectMoved_ptr event);
static void main_Object_subscribeTo_1(main_Player_ptr self, nlniltype event, function_4WmBbjumsffDobLkA handler);
static void main_Object_subscribeTo_2(main_Player_ptr self, nlniltype event, function_15AWPgqbccPV11c7 handler);
static void main_Object_subscribeTo_3(main_Animal_ptr self, nlniltype event, function_3s38JSQJHhFrY9ris handler);
static void main_Object_raiseEvent_1(main_Player_ptr self, main_event_Event_PlayerAttack_ptr event);
static void main_Object_raiseEvent_2(main_Animal_ptr self, main_event_Event_AnimalDeath_ptr event);
static void main_Object_raiseEvent_3(main_Animal_ptr self, main_event_Event_AnimalDamaged_ptr event);
static void main_Object_raiseEvent_4(main_Object_ptr self, main_event_Event_ObjectTryMove_ptr event);
static void main_Object_raiseEvent_5(main_Object_ptr self, main_event_Event_ObjectMoved_ptr event);
static void main_Object_tryMoveTo_1(main_Player_ptr ptr, main_vec2 pos);
static void main_Player_say_1(main_Player_ptr self, nlstring __arg1);
static void nelua_print_1(nlstring a1, nlstring a2);
static void main_Player_init(main_Player_ptr self);
static void main_Player_KeyPressed_handler(main_Player_ptr self_1, main_event_Event_KeyPressed_ptr event);
static void main_Player_AnimalDamaged_handler(main_Player_ptr self_2, main_event_Event_AnimalDamaged_ptr event);
static main_Player_ptr main_Player_create(main_vec2 pos);
static void main_Animal_init(main_Animal_ptr self);
static void main_Animal_PlayerAttack_handler(main_Animal_ptr self_3, main_event_Event_PlayerAttack_ptr event);
static void nelua_print_2(nlstring a1);
static main_Animal_ptr main_Animal_create(main_vec2 pos);
static void main_Narrator_subscribeTo_1(main_Narrator_ptr self, nlniltype event, function_2htbwEnNf7AXuQQHo handler);
static void main_Narrator_subscribeTo_2(main_Narrator_ptr self, nlniltype event, function_oBKPg1FFcB5Dg4Aw handler);
static void main_Narrator_subscribeTo_3(main_Narrator_ptr self, nlniltype event, function_51hrVrGsWPLUqgN7q handler);
static void main_Narrator_init(main_Narrator_ptr self);
static void main_Narrator_PlayerAttack_handler(main_Narrator_ptr self_4, main_event_Event_PlayerAttack_ptr event);
static void main_Narrator_ObjectMoved_handler(main_Narrator_ptr self_5, main_event_Event_ObjectMoved_ptr event);
static void main_Narrator_AnimalDeath_handler(main_Narrator_ptr self_6, main_event_Event_AnimalDeath_ptr event);
static bool main_Tile_hasObject(main_Tile_ptr self);
static list_Node_8_ptr main_Tile_addObject_1(main_Tile_ptr self, main_Object_ptr ptr);
static list_Node_8_ptr main_Tile_addObject_2(main_Tile_ptr self, main_Player_ptr ptr);
static list_Node_8_ptr main_Tile_addObject_3(main_Tile_ptr self, main_Animal_ptr ptr);
static void main_Tile_removeObject_1(main_Tile_ptr self, main_Object_ptr ptr);
static void main_Map_subscribeTo_1(main_Map_ptr self, nlniltype event, function_3Rhiu8maLRfEDva9C handler);
static void main_Map_subscribeTo_2(main_Map_ptr self, nlniltype event, function_4Y2Xurfya4ueffdc3 handler);
static main_vec2 main_Map_getTilePosFromOffset(int32_t offset);
static NELUA_INLINE int64_t nelua_assert_imod_nlint64(int64_t a, int64_t b);
static main_Tile_ptr main_Map_getTile(main_Map_ptr self, main_vec2 pos);
static void main_Map_init(main_Map_ptr self, nlstring initstr);
static void main_readInit(main_Map_ptr self_7, nlstring initstr_1);
static NELUA_INLINE int32_t nelua_assert_narrow_nlint64_nlint32(int64_t x);
static void main_Map_ObjectTryMove_handler(main_Map_ptr self_8, main_event_Event_ObjectTryMove_ptr event);
static void main_Map_ObjectMoved_handler(main_Map_ptr self_9, main_event_Event_ObjectMoved_ptr event);
static void main_Map_render(main_Map_ptr self);
static main_Narrator main_narrator;
static main_Map main_map;
static int nelua_main(int argc, char** argv);
/* ------------------------------ DEFINITIONS ------------------------------- */
void nelua_write_stderr(const char* msg, uintptr_t len, bool flush) {
  if(len > 0 && msg) {
    fwrite(msg, 1, len, stderr);
  }
  if(flush) {
    fwrite("\n", 1, 1, stderr);
    fflush(stderr);
  }
}
void nelua_abort(void) {
  NELUA_UBSAN_UNREACHABLE();
  abort();
}
void nelua_assert_line_1(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/nix/store/fjg7d071zkmnh2jk44hjr291x4b4794z-nelua-0-unstable-2024-04-20/lib/nelua/lib/memory.nelua\033[1m:27:14: \033[31m\033[1mruntime error: \033[0m\033[1m", 142, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n  check(dest and src, 'invalid pointer')\n             \033[1m\033[32m^\033[0m\033[35m~~~~~~\033[0m\n", 89, true);
    nelua_abort();
  }
}
void nelua_memory_copy(void* dest, void* src, uintptr_t n) {
  if(NELUA_UNLIKELY((n == 0))) {
    return;
  }
  nelua_assert_line_1(((dest != NULL) && (src != NULL)), ((nlstring){(uint8_t*)"invalid pointer", 15}));
  memcpy(dest, src, (size_t)n);
}
void nelua_assert_line_2(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/nix/store/fjg7d071zkmnh2jk44hjr291x4b4794z-nelua-0-unstable-2024-04-20/lib/nelua/lib/memory.nelua\033[1m:60:9: \033[31m\033[1mruntime error: \033[0m\033[1m", 141, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n  check(dest, 'invalid pointer')\n        \033[1m\033[32m^\033[0m\033[35m~~~\033[0m\n", 73, true);
    nelua_abort();
  }
}
void nelua_memory_zero(void* dest, uintptr_t n) {
  if(NELUA_UNLIKELY((n == 0))) {
    return;
  }
  nelua_assert_line_2((dest != NULL), ((nlstring){(uint8_t*)"invalid pointer", 15}));
  memset(dest, 0, (size_t)n);
}
bool nelua_span_uint8__empty(nelua_span_uint8_ self) {
  return (self.size == 0);
}
void nelua_assert_line_3(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/nix/store/fjg7d071zkmnh2jk44hjr291x4b4794z-nelua-0-unstable-2024-04-20/lib/nelua/lib/span.nelua\033[1m:93:13: \033[31m\033[1mruntime error: \033[0m\033[1m", 140, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    check(i < self.size, 'index out of range')\n            \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 98, true);
    nelua_abort();
  }
}
nluint8_ptr nelua_span_uint8____atindex(nelua_span_uint8_ self, uintptr_t i) {
  nelua_assert_line_3((i < self.size), ((nlstring){(uint8_t*)"index out of range", 18}));
  return (&self.data[i]);
}
void nelua_assert_line_4(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/nix/store/fjg7d071zkmnh2jk44hjr291x4b4794z-nelua-0-unstable-2024-04-20/lib/nelua/lib/span.nelua\033[1m:93:13: \033[31m\033[1mruntime error: \033[0m\033[1m", 140, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    check(i < self.size, 'index out of range')\n            \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 98, true);
    nelua_abort();
  }
}
nlpointer_ptr nelua_span_pointer____atindex(nelua_span_pointer_ self, uintptr_t i) {
  nelua_assert_line_4((i < self.size), ((nlstring){(uint8_t*)"index out of range", 18}));
  return (&self.data[i]);
}
void nelua_assert_line_5(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/nix/store/fjg7d071zkmnh2jk44hjr291x4b4794z-nelua-0-unstable-2024-04-20/lib/nelua/lib/span.nelua\033[1m:93:13: \033[31m\033[1mruntime error: \033[0m\033[1m", 140, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    check(i < self.size, 'index out of range')\n            \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 98, true);
    nelua_abort();
  }
}
nelua_GCScanRange_ptr nelua_span_GCScanRange____atindex(nelua_span_GCScanRange_ self, uintptr_t i) {
  nelua_assert_line_5((i < self.size), ((nlstring){(uint8_t*)"index out of range", 18}));
  return (&self.data[i]);
}
void nelua_assert_line_6(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/nix/store/fjg7d071zkmnh2jk44hjr291x4b4794z-nelua-0-unstable-2024-04-20/lib/nelua/lib/span.nelua\033[1m:93:13: \033[31m\033[1mruntime error: \033[0m\033[1m", 140, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    check(i < self.size, 'index out of range')\n            \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 98, true);
    nelua_abort();
  }
}
nlusize_ptr nelua_span_usize____atindex(nelua_span_usize_ self, uintptr_t i) {
  nelua_assert_line_6((i < self.size), ((nlstring){(uint8_t*)"index out of range", 18}));
  return (&self.data[i]);
}
void nelua_assert_line_7(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/nix/store/fjg7d071zkmnh2jk44hjr291x4b4794z-nelua-0-unstable-2024-04-20/lib/nelua/lib/span.nelua\033[1m:93:13: \033[31m\033[1mruntime error: \033[0m\033[1m", 140, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    check(i < self.size, 'index out of range')\n            \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 98, true);
    nelua_abort();
  }
}
nelua_hashmapnode_pointer__GCItem__ptr nelua_span_hashmapnode_pointer__GCItem_____atindex(nelua_span_hashmapnode_pointer__GCItem__ self, uintptr_t i) {
  nelua_assert_line_7((i < self.size), ((nlstring){(uint8_t*)"index out of range", 18}));
  return (&self.data[i]);
}
void nelua_assert_line_8(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/nix/store/fjg7d071zkmnh2jk44hjr291x4b4794z-nelua-0-unstable-2024-04-20/lib/nelua/lib/span.nelua\033[1m:93:13: \033[31m\033[1mruntime error: \033[0m\033[1m", 140, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    check(i < self.size, 'index out of range')\n            \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 98, true);
    nelua_abort();
  }
}
nelua_hashmapnode_pointer__usize__ptr nelua_span_hashmapnode_pointer__usize_____atindex(nelua_span_hashmapnode_pointer__usize__ self, uintptr_t i) {
  nelua_assert_line_8((i < self.size), ((nlstring){(uint8_t*)"index out of range", 18}));
  return (&self.data[i]);
}
void nelua_panic_cstring(const char* s) {
  if(s) {
    nelua_write_stderr(s, strlen(s), true);
  }
  nelua_abort();
}
void* nelua_assert_deref(void* p) {
  if(NELUA_UNLIKELY(p == NULL)) {
    nelua_panic_cstring("attempt to dereference a null pointer");
  }
  return p;
}
uintptr_t nelua_assert_narrow_nlint64_nlusize(int64_t x) {
  if(NELUA_UNLIKELY(x < 0)) {
    nelua_panic_cstring("narrow casting from int64 to usize failed");
  }
  return (uintptr_t)x;
}
nlmulret_nlboolean_nlint64_nluint8 nelua_ipairs_next(nlstring_ptr a_1, int64_t k) {
  k = (k + 1);
  if((k >= (nelua_nlstring___len((*(nlstring*)nelua_assert_deref(a_1))) + 1))) {
    return (nlmulret_nlboolean_nlint64_nluint8){false, 0, 0U};
  }
  return (nlmulret_nlboolean_nlint64_nluint8){true, k, (*(uint8_t*)nelua_assert_deref(nelua_nlstring___atindex((*(nlstring*)nelua_assert_deref(a_1)), nelua_assert_narrow_nlint64_nlusize(k))))};
}
nlmulret_function_r1xBQ225tRe7LZWm_nlstring_ptr_nlint64 nelua_ipairs_1(nlstring_ptr a) {
  return (nlmulret_function_r1xBQ225tRe7LZWm_nlstring_ptr_nlint64){nelua_ipairs_next, a, 0};
}
int64_t nelua_assert_bounds_nlint64(int64_t index, uintptr_t len) {
  if(NELUA_UNLIKELY((uintptr_t)index >= len || index < 0)) {
    nelua_panic_cstring("array index: position out of bounds");
  }
  return index;
}
nlmulret_nlboolean_nlint64_main_Tile_ptr nelua_mipairs_next(main_Tile_arr49_ptr a_2, int64_t k) {
  k = (k + 1);
  if((k >= 49)) {
    return (nlmulret_nlboolean_nlint64_main_Tile_ptr){false, 0, ((main_Tile_ptr)NULL)};
  }
  return (nlmulret_nlboolean_nlint64_main_Tile_ptr){true, k, (&a_2->v[nelua_assert_bounds_nlint64(k, 49)])};
}
nlmulret_function_34gvaBKj3vvkM3dS7_main_Tile_arr49_ptr_nlint64 nelua_mipairs_1(main_Tile_arr49_ptr a) {
  return (nlmulret_function_34gvaBKj3vvkM3dS7_main_Tile_arr49_ptr_nlint64){nelua_mipairs_next, a, -1};
}
nlmulret_function_2EyHN9k6KLqeowE1y_nelua_hashmap_iteratorT_1_nlpointer nelua_pairs_1(nelua_hashmap_pointer__usize__ptr a) {
  nlmulret_function_2EyHN9k6KLqeowE1y_nelua_hashmap_iteratorT_1_nlpointer _ret_1 = nelua_hashmap_pointer__usize____pairs(a);
  return (nlmulret_function_2EyHN9k6KLqeowE1y_nelua_hashmap_iteratorT_1_nlpointer){_ret_1.r1, _ret_1.r2, _ret_1.r3};
}
nlmulret_function_3dDifWjDdRxpgM1fu_nelua_hashmap_iteratorT_nlpointer nelua_mpairs_1(nelua_hashmap_pointer__GCItem__ptr a) {
  nlmulret_function_3dDifWjDdRxpgM1fu_nelua_hashmap_iteratorT_nlpointer _ret_1 = nelua_hashmap_pointer__GCItem____mpairs(a);
  return (nlmulret_function_3dDifWjDdRxpgM1fu_nelua_hashmap_iteratorT_nlpointer){_ret_1.r1, _ret_1.r2, _ret_1.r3};
}
void nelua_memory_spanset_1(nelua_span_usize_ dest, uintptr_t x) {
  for(uintptr_t i = 0U, _end = dest.size; i < _end; i += 1) {
    (*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex(dest, i))) = x;
  }
}
void* nelua_GeneralAllocator_alloc_1(nelua_GeneralAllocator_ptr self, uintptr_t size, uintptr_t flags) {
  if(NELUA_UNLIKELY((size == 0))) {
    return (void*)NULL;
  }
  return malloc((size_t)size);
}
void* nelua_GeneralAllocator_alloc_2(nelua_GeneralAllocator_ptr self, uintptr_t size, nlniltype flags) {
  if(NELUA_UNLIKELY((size == 0))) {
    return (void*)NULL;
  }
  return malloc((size_t)size);
}
void* nelua_GeneralAllocator_alloc0_1(nelua_GeneralAllocator_ptr self, uintptr_t size, nlniltype flags) {
  if(NELUA_UNLIKELY((size == 0))) {
    return (void*)NULL;
  }
  return calloc((size_t)size, 1U);
}
void* nelua_GeneralAllocator_alloc0_2(nelua_GeneralAllocator_ptr self, uintptr_t size, uintptr_t flags) {
  if(NELUA_UNLIKELY((size == 0))) {
    return (void*)NULL;
  }
  return calloc((size_t)size, 1U);
}
void nelua_GeneralAllocator_dealloc(nelua_GeneralAllocator_ptr self, void* p) {
  if(NELUA_UNLIKELY((p == (void*)NULL))) {
    return;
  }
  free(p);
}
void* nelua_GeneralAllocator_realloc(nelua_GeneralAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize) {
  if(NELUA_UNLIKELY((newsize == 0))) {
    if(NELUA_LIKELY((p != (void*)NULL))) {
      free(p);
    }
    return (void*)NULL;
  } else if(NELUA_UNLIKELY((newsize == oldsize))) {
    return p;
  }
  return realloc(p, (size_t)newsize);
}
void* nelua_GeneralAllocator_realloc0(nelua_GeneralAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize) {
  p = nelua_GeneralAllocator_realloc(self, p, newsize, oldsize);
  if(NELUA_LIKELY(((newsize > oldsize) && (p != (void*)NULL)))) {
    nelua_memory_zero((void*)(&((nluint8_arr0_ptr)p)[oldsize]), (newsize - oldsize));
  }
  return p;
}
nelua_span_pointer_ nelua_GeneralAllocator_spanalloc_1(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags) {
  if(NELUA_LIKELY((size > 0))) {
    nlpointer_arr0_ptr data = ((nlpointer_arr0_ptr)nelua_GeneralAllocator_alloc_2(self, (size * 8), NELUA_NIL));
    if(NELUA_LIKELY((data != ((nlpointer_arr0_ptr)NULL)))) {
      return (nelua_span_pointer_){.data = data, .size = size};
    }
  }
  return (nelua_span_pointer_){0};
}
nelua_span_GCScanRange_ nelua_GeneralAllocator_spanalloc_2(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags) {
  if(NELUA_LIKELY((size > 0))) {
    uintptr_t flags_1 = 262144U;
    nelua_GCScanRange_arr0_ptr data = ((nelua_GCScanRange_arr0_ptr)nelua_GeneralAllocator_alloc_1(self, (size * 16), flags_1));
    if(NELUA_LIKELY((data != ((nelua_GCScanRange_arr0_ptr)NULL)))) {
      return (nelua_span_GCScanRange_){.data = data, .size = size};
    }
  }
  return (nelua_span_GCScanRange_){0};
}
nelua_span_usize_ nelua_GeneralAllocator_spanalloc_3(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags) {
  if(NELUA_LIKELY((size > 0))) {
    uintptr_t flags_2 = 262144U;
    nlusize_arr0_ptr data = ((nlusize_arr0_ptr)nelua_GeneralAllocator_alloc_1(self, (size * 8), flags_2));
    if(NELUA_LIKELY((data != ((nlusize_arr0_ptr)NULL)))) {
      return (nelua_span_usize_){.data = data, .size = size};
    }
  }
  return (nelua_span_usize_){0};
}
nelua_span_hashmapnode_pointer__GCItem__ nelua_GeneralAllocator_spanalloc0_1(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags) {
  if(NELUA_LIKELY((size > 0))) {
    nelua_hashmapnode_pointer__GCItem__arr0_ptr data = ((nelua_hashmapnode_pointer__GCItem__arr0_ptr)nelua_GeneralAllocator_alloc0_1(self, (size * 56), NELUA_NIL));
    if(NELUA_LIKELY((data != ((nelua_hashmapnode_pointer__GCItem__arr0_ptr)NULL)))) {
      return (nelua_span_hashmapnode_pointer__GCItem__){.data = data, .size = size};
    }
  }
  return (nelua_span_hashmapnode_pointer__GCItem__){0};
}
nelua_span_hashmapnode_pointer__usize__ nelua_GeneralAllocator_spanalloc0_2(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags) {
  if(NELUA_LIKELY((size > 0))) {
    nelua_hashmapnode_pointer__usize__arr0_ptr data = ((nelua_hashmapnode_pointer__usize__arr0_ptr)nelua_GeneralAllocator_alloc0_1(self, (size * 32), NELUA_NIL));
    if(NELUA_LIKELY((data != ((nelua_hashmapnode_pointer__usize__arr0_ptr)NULL)))) {
      return (nelua_span_hashmapnode_pointer__usize__){.data = data, .size = size};
    }
  }
  return (nelua_span_hashmapnode_pointer__usize__){0};
}
void nelua_GeneralAllocator_spandealloc_1(nelua_GeneralAllocator_ptr self, nelua_span_pointer_ s) {
  if(NELUA_UNLIKELY((s.size == 0))) {
    return;
  }
  nelua_GeneralAllocator_dealloc(self, (void*)s.data);
}
void nelua_GeneralAllocator_spandealloc_2(nelua_GeneralAllocator_ptr self, nelua_span_GCScanRange_ s) {
  if(NELUA_UNLIKELY((s.size == 0))) {
    return;
  }
  nelua_GeneralAllocator_dealloc(self, (void*)s.data);
}
void nelua_GeneralAllocator_spandealloc_3(nelua_GeneralAllocator_ptr self, nelua_span_usize_ s) {
  if(NELUA_UNLIKELY((s.size == 0))) {
    return;
  }
  nelua_GeneralAllocator_dealloc(self, (void*)s.data);
}
void nelua_GeneralAllocator_spandealloc_4(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_pointer__GCItem__ s) {
  if(NELUA_UNLIKELY((s.size == 0))) {
    return;
  }
  nelua_GeneralAllocator_dealloc(self, (void*)s.data);
}
void nelua_GeneralAllocator_spandealloc_5(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_pointer__usize__ s) {
  if(NELUA_UNLIKELY((s.size == 0))) {
    return;
  }
  nelua_GeneralAllocator_dealloc(self, (void*)s.data);
}
nelua_span_pointer_ nelua_GeneralAllocator_spanrealloc_1(nelua_GeneralAllocator_ptr self, nelua_span_pointer_ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GeneralAllocator_spanalloc_1(self, NELUA_NIL, size, NELUA_NIL);
    return s;
  }
  nlpointer_arr0_ptr p = ((nlpointer_arr0_ptr)nelua_GeneralAllocator_realloc(self, (void*)s.data, (size * 8), (s.size * 8)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((nlpointer_arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_GCScanRange_ nelua_GeneralAllocator_spanrealloc_2(nelua_GeneralAllocator_ptr self, nelua_span_GCScanRange_ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GeneralAllocator_spanalloc_2(self, NELUA_NIL, size, NELUA_NIL);
    return s;
  }
  nelua_GCScanRange_arr0_ptr p = ((nelua_GCScanRange_arr0_ptr)nelua_GeneralAllocator_realloc(self, (void*)s.data, (size * 16), (s.size * 16)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((nelua_GCScanRange_arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_usize_ nelua_GeneralAllocator_spanrealloc_3(nelua_GeneralAllocator_ptr self, nelua_span_usize_ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GeneralAllocator_spanalloc_3(self, NELUA_NIL, size, NELUA_NIL);
    return s;
  }
  nlusize_arr0_ptr p = ((nlusize_arr0_ptr)nelua_GeneralAllocator_realloc(self, (void*)s.data, (size * 8), (s.size * 8)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((nlusize_arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
void nelua_panic_string(nlstring s) {
  if(s.size > 0) {
    nelua_write_stderr((const char*)s.data, s.size, true);
  }
  nelua_abort();
}
nelua_span_pointer_ nelua_GeneralAllocator_xspanrealloc_1(nelua_GeneralAllocator_ptr self, nelua_span_pointer_ s, uintptr_t size) {
  s = nelua_GeneralAllocator_spanrealloc_1(self, s, size);
  if(NELUA_UNLIKELY((s.size != size))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return s;
}
nelua_span_GCScanRange_ nelua_GeneralAllocator_xspanrealloc_2(nelua_GeneralAllocator_ptr self, nelua_span_GCScanRange_ s, uintptr_t size) {
  s = nelua_GeneralAllocator_spanrealloc_2(self, s, size);
  if(NELUA_UNLIKELY((s.size != size))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return s;
}
nelua_span_usize_ nelua_GeneralAllocator_xspanrealloc_3(nelua_GeneralAllocator_ptr self, nelua_span_usize_ s, uintptr_t size) {
  s = nelua_GeneralAllocator_spanrealloc_3(self, s, size);
  if(NELUA_UNLIKELY((s.size != size))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return s;
}
nelua_span_hashmapnode_pointer__GCItem__ nelua_GeneralAllocator_spanrealloc0_1(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_pointer__GCItem__ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GeneralAllocator_spanalloc0_1(self, NELUA_NIL, size, NELUA_NIL);
    return s;
  }
  nelua_hashmapnode_pointer__GCItem__arr0_ptr p = ((nelua_hashmapnode_pointer__GCItem__arr0_ptr)nelua_GeneralAllocator_realloc0(self, (void*)s.data, (size * 56), (s.size * 56)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((nelua_hashmapnode_pointer__GCItem__arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_hashmapnode_pointer__usize__ nelua_GeneralAllocator_spanrealloc0_2(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_pointer__usize__ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GeneralAllocator_spanalloc0_2(self, NELUA_NIL, size, NELUA_NIL);
    return s;
  }
  nelua_hashmapnode_pointer__usize__arr0_ptr p = ((nelua_hashmapnode_pointer__usize__arr0_ptr)nelua_GeneralAllocator_realloc0(self, (void*)s.data, (size * 32), (s.size * 32)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((nelua_hashmapnode_pointer__usize__arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_hashmapnode_pointer__GCItem__ nelua_GeneralAllocator_xspanrealloc0_1(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_pointer__GCItem__ s, uintptr_t size) {
  s = nelua_GeneralAllocator_spanrealloc0_1(self, s, size);
  if(NELUA_UNLIKELY((s.size != size))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return s;
}
nelua_span_hashmapnode_pointer__usize__ nelua_GeneralAllocator_xspanrealloc0_2(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_pointer__usize__ s, uintptr_t size) {
  s = nelua_GeneralAllocator_spanrealloc0_2(self, s, size);
  if(NELUA_UNLIKELY((s.size != size))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return s;
}
uintptr_t nelua_hash_hash_1(void* v) {
  return ((uintptr_t)v >> 4);
}
uintptr_t nelua_ceilidiv(uintptr_t x, uintptr_t y) {
  return (((x + y) - 1) / y);
}
uintptr_t nelua_hashmod(uintptr_t h, uintptr_t n) {
  return (h & (n - 1));
}
uintptr_t nelua_roundpow2(uintptr_t n) {
  if(((n & (n - 1)) == 0)) {
    return n;
  }
  n = (n | (n >> 1));
  n = (n | (n >> 2));
  n = (n | (n >> 4));
  n = (n | (n >> 8));
  n = (n | (n >> 16));
  n = (n | (n >> 32));
  n = (n + 1);
  return n;
}
void nelua_hashmap_pointer__GCItem__destroy(nelua_hashmap_pointer__GCItem__ptr self) {
  nelua_GeneralAllocator_spandealloc_3((&self->allocator), self->buckets);
  nelua_GeneralAllocator_spandealloc_4((&self->allocator), self->nodes);
  self->buckets = (nelua_span_usize_){0};
  self->nodes = (nelua_span_hashmapnode_pointer__GCItem__){0};
  self->size = 0U;
  self->free_index = 0U;
}
nlmulret_nlusize_nlusize_nlusize nelua_hashmap_pointer__GCItem___find(nelua_hashmap_pointer__GCItem__ptr self, void* key) {
  uintptr_t h = nelua_hash_hash_1(key);
  uintptr_t buckets_size = self->buckets.size;
  uintptr_t bucket_index = nelua_hashmod(h, buckets_size);
  uintptr_t prev_node_index = 0xffffffffffffffffULL;
  if(NELUA_UNLIKELY((buckets_size == 0))) {
    return (nlmulret_nlusize_nlusize_nlusize){0xffffffffffffffffULL, prev_node_index, bucket_index};
  }
  uintptr_t node_index = (*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex(self->buckets, bucket_index)));
  while((node_index != 0xffffffffffffffffULL)) {
    nelua_hashmapnode_pointer__GCItem__ptr node = (&(*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, node_index))));
    bool eq = (key == node->key);
    if(eq) {
      return (nlmulret_nlusize_nlusize_nlusize){node_index, prev_node_index, bucket_index};
    }
    prev_node_index = node_index;
    node_index = node->next;
  }
  return (nlmulret_nlusize_nlusize_nlusize){node_index, prev_node_index, bucket_index};
}
void nelua_assert_line_9(bool cond) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/nix/store/fjg7d071zkmnh2jk44hjr291x4b4794z-nelua-0-unstable-2024-04-20/lib/nelua/lib/hashmap.nelua\033[1m:214:15: \033[31m\033[1mruntime error: \033[0m\033[1massertion failed!\033[0m\n      check(j == self.size)\n              \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~\033[0m\n",  243, true);
    nelua_abort();
  }
}
void nelua_hashmap_pointer__GCItem__rehash(nelua_hashmap_pointer__GCItem__ptr self, uintptr_t bucket_count) {
  uintptr_t min_buckets_count = nelua_ceilidiv((self->size * 100), 75U);
  if((bucket_count < min_buckets_count)) {
    bucket_count = min_buckets_count;
  }
  bucket_count = nelua_roundpow2(bucket_count);
  uintptr_t node_count = nelua_ceilidiv((bucket_count * 75U), 100U);
  if(((bucket_count > 0) && (node_count <= self->size))) {
    node_count = (self->size + 1);
  }
  if((((node_count < self->nodes.size) && (self->nodes.size > 0)) && (node_count > 0))) {
    uintptr_t j = 0U;
    while(((j < self->nodes.size) && (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, j))).filled)) {
      j = (j + 1);
    }
    for(uintptr_t i = j, _end = self->nodes.size; i < _end; i += 1) {
      if((*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, i))).filled) {
        (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, j))) = (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, i)));
        j = (j + 1);
      }
    }
    for(uintptr_t i = j, _end = self->nodes.size; i < _end; i += 1) {
      (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, i))) = (nelua_hashmapnode_pointer__GCItem_){0};
    }
    nelua_assert_line_9((j == self->size));
  }
  self->nodes = nelua_GeneralAllocator_xspanrealloc0_1((&self->allocator), self->nodes, node_count);
  self->buckets = nelua_GeneralAllocator_xspanrealloc_3((&self->allocator), self->buckets, bucket_count);
  nelua_memory_spanset_1(self->buckets, 0xffffffffffffffffULL);
  uintptr_t free_index = 0xffffffffffffffffULL;
  for(intptr_t i = (intptr_t)(self->nodes.size - 1); i >= 0; i += -1) {
    nelua_hashmapnode_pointer__GCItem__ptr node = (&(*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, (uintptr_t)i))));
    if(node->filled) {
      node->next = 0xffffffffffffffffULL;
    } else {
      node->next = free_index;
      free_index = (uintptr_t)i;
    }
  }
  self->free_index = free_index;
  for(uintptr_t i = 0U, _end = self->nodes.size; i < _end; i += 1) {
    if((*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, i))).filled) {
      nlmulret_nlusize_nlusize_nlusize _asgnret_1 = nelua_hashmap_pointer__GCItem___find(self, (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, i))).key);
      uintptr_t node_index = _asgnret_1.r1;
      uintptr_t prev_node_index = _asgnret_1.r2;
      uintptr_t bucket_index = _asgnret_1.r3;
      if(NELUA_LIKELY((prev_node_index == 0xffffffffffffffffULL))) {
        (*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex(self->buckets, bucket_index))) = i;
      } else {
        (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, prev_node_index))).next = i;
      }
      (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, i))).next = node_index;
    }
  }
}
void nelua_assert_line_10(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/nix/store/fjg7d071zkmnh2jk44hjr291x4b4794z-nelua-0-unstable-2024-04-20/lib/nelua/lib/hashmap.nelua\033[1m:270:24: \033[31m\033[1mruntime error: \033[0m\033[1m", 144, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n      check(node_index < self.nodes.size, 'not enough space to add a node')\n                       \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~~\033[0m\n", 144, true);
    nelua_abort();
  }
}
uintptr_t nelua_hashmap_pointer__GCItem___at(nelua_hashmap_pointer__GCItem__ptr self, void* key) {
  if(NELUA_UNLIKELY((self->buckets.size == 0))) {
    nelua_hashmap_pointer__GCItem__rehash(self, 8U);
  }
  nlmulret_nlusize_nlusize_nlusize _asgnret_1 = nelua_hashmap_pointer__GCItem___find(self, key);
  uintptr_t node_index = _asgnret_1.r1;
  uintptr_t prev_node_index = _asgnret_1.r2;
  uintptr_t bucket_index = _asgnret_1.r3;
  if((node_index != 0xffffffffffffffffULL)) {
    return node_index;
  } else {
    uintptr_t node_index_1 = self->free_index;
    nelua_assert_line_10((node_index_1 < self->nodes.size), ((nlstring){(uint8_t*)"not enough space to add a node", 30}));
    nelua_hashmapnode_pointer__GCItem__ptr node = (&(*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, node_index_1))));
    self->free_index = node->next;
    (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(node)) = (nelua_hashmapnode_pointer__GCItem_){.key = key, .filled = true, .next = 0xffffffffffffffffULL};
    if(NELUA_LIKELY((prev_node_index == 0xffffffffffffffffULL))) {
      (*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex(self->buckets, bucket_index))) = node_index_1;
    } else {
      (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, prev_node_index))).next = node_index_1;
    }
    self->size = (self->size + 1);
    if(NELUA_UNLIKELY(((self->size * 100) >= (self->buckets.size * 75U)))) {
      nelua_hashmap_pointer__GCItem__rehash(self, nelua_ceilidiv((self->size * 200U), 75U));
    }
    return node_index_1;
  }
}
nelua_GCItem_ptr nelua_hashmap_pointer__GCItem____atindex(nelua_hashmap_pointer__GCItem__ptr self, void* key) {
  return (&(*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, nelua_hashmap_pointer__GCItem___at(self, key)))).value);
}
nelua_GCItem_ptr nelua_hashmap_pointer__GCItem__peek(nelua_hashmap_pointer__GCItem__ptr self, void* key) {
  uintptr_t node_index = nelua_hashmap_pointer__GCItem___find(self, key).r1;
  if((node_index != 0xffffffffffffffffULL)) {
    return (&(*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, node_index))).value);
  }
  return ((nelua_GCItem_ptr)NULL);
}
nelua_GCItem nelua_hashmap_pointer__GCItem__remove(nelua_hashmap_pointer__GCItem__ptr self, void* key) {
  nlmulret_nlusize_nlusize_nlusize _asgnret_1 = nelua_hashmap_pointer__GCItem___find(self, key);
  uintptr_t node_index = _asgnret_1.r1;
  uintptr_t prev_node_index = _asgnret_1.r2;
  uintptr_t bucket_index = _asgnret_1.r3;
  if(NELUA_UNLIKELY((node_index == 0xffffffffffffffffULL))) {
    return (nelua_GCItem){0};
  }
  nelua_hashmapnode_pointer__GCItem__ptr node = (&(*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, node_index))));
  nelua_GCItem value = node->value;
  if(NELUA_LIKELY((prev_node_index == 0xffffffffffffffffULL))) {
    (*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex(self->buckets, bucket_index))) = node->next;
  } else {
    (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, prev_node_index))).next = node->next;
  }
  self->size = (self->size - 1);
  (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(node)) = (nelua_hashmapnode_pointer__GCItem_){.next = self->free_index};
  self->free_index = node_index;
  return value;
}
bool nelua_hashmap_pointer__GCItem__erase(nelua_hashmap_pointer__GCItem__ptr self, void* key) {
  nlmulret_nlusize_nlusize_nlusize _asgnret_1 = nelua_hashmap_pointer__GCItem___find(self, key);
  uintptr_t node_index = _asgnret_1.r1;
  uintptr_t prev_node_index = _asgnret_1.r2;
  uintptr_t bucket_index = _asgnret_1.r3;
  if(NELUA_UNLIKELY((node_index == 0xffffffffffffffffULL))) {
    return false;
  }
  nelua_hashmapnode_pointer__GCItem__ptr node = (&(*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, node_index))));
  if(NELUA_LIKELY((prev_node_index == 0xffffffffffffffffULL))) {
    (*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex(self->buckets, bucket_index))) = node->next;
  } else {
    (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->nodes, prev_node_index))).next = node->next;
  }
  self->size = (self->size - 1);
  (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(node)) = (nelua_hashmapnode_pointer__GCItem_){.next = self->free_index};
  self->free_index = node_index;
  return true;
}
nelua_hashmapnode_pointer__GCItem__ptr nelua_hashmap_iteratorT__next_node(nelua_hashmap_iteratorT_ptr self, void* key) {
  if(NELUA_UNLIKELY((self->index == 0xffffffffffffffffULL))) {
    self->index = 0U;
  } else {
    self->index = (self->index + 1);
  }
  while((self->index < self->container->nodes.size)) {
    nelua_hashmapnode_pointer__GCItem__ptr node = (&(*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex(self->container->nodes, self->index))));
    if(node->filled) {
      return node;
    }
    self->index = (self->index + 1);
  }
  return ((nelua_hashmapnode_pointer__GCItem__ptr)NULL);
}
nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr nelua_hashmap_iteratorT_mnext(nelua_hashmap_iteratorT_ptr self, void* key) {
  nelua_hashmapnode_pointer__GCItem__ptr node = nelua_hashmap_iteratorT__next_node(self, key);
  if((!(node != NULL))) {
    return (nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr){false, NULL, ((nelua_GCItem_ptr)NULL)};
  }
  return (nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr){true, node->key, (&node->value)};
}
nlmulret_function_3dDifWjDdRxpgM1fu_nelua_hashmap_iteratorT_nlpointer nelua_hashmap_pointer__GCItem____mpairs(nelua_hashmap_pointer__GCItem__ptr self) {
  return (nlmulret_function_3dDifWjDdRxpgM1fu_nelua_hashmap_iteratorT_nlpointer){nelua_hashmap_iteratorT_mnext, (nelua_hashmap_iteratorT){.container = self, .index = 0xffffffffffffffffULL}, NULL};
}
void nelua_hashmap_pointer__usize__destroy(nelua_hashmap_pointer__usize__ptr self) {
  nelua_GeneralAllocator_spandealloc_3((&self->allocator), self->buckets);
  nelua_GeneralAllocator_spandealloc_5((&self->allocator), self->nodes);
  self->buckets = (nelua_span_usize_){0};
  self->nodes = (nelua_span_hashmapnode_pointer__usize__){0};
  self->size = 0U;
  self->free_index = 0U;
}
nlmulret_nlusize_nlusize_nlusize nelua_hashmap_pointer__usize___find(nelua_hashmap_pointer__usize__ptr self, void* key) {
  uintptr_t h = nelua_hash_hash_1(key);
  uintptr_t buckets_size = self->buckets.size;
  uintptr_t bucket_index = nelua_hashmod(h, buckets_size);
  uintptr_t prev_node_index = 0xffffffffffffffffULL;
  if(NELUA_UNLIKELY((buckets_size == 0))) {
    return (nlmulret_nlusize_nlusize_nlusize){0xffffffffffffffffULL, prev_node_index, bucket_index};
  }
  uintptr_t node_index = (*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex(self->buckets, bucket_index)));
  while((node_index != 0xffffffffffffffffULL)) {
    nelua_hashmapnode_pointer__usize__ptr node = (&(*(nelua_hashmapnode_pointer__usize_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__usize_____atindex(self->nodes, node_index))));
    bool eq = (key == node->key);
    if(eq) {
      return (nlmulret_nlusize_nlusize_nlusize){node_index, prev_node_index, bucket_index};
    }
    prev_node_index = node_index;
    node_index = node->next;
  }
  return (nlmulret_nlusize_nlusize_nlusize){node_index, prev_node_index, bucket_index};
}
void nelua_assert_line_11(bool cond) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/nix/store/fjg7d071zkmnh2jk44hjr291x4b4794z-nelua-0-unstable-2024-04-20/lib/nelua/lib/hashmap.nelua\033[1m:214:15: \033[31m\033[1mruntime error: \033[0m\033[1massertion failed!\033[0m\n      check(j == self.size)\n              \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~\033[0m\n",  243, true);
    nelua_abort();
  }
}
void nelua_hashmap_pointer__usize__rehash(nelua_hashmap_pointer__usize__ptr self, uintptr_t bucket_count) {
  uintptr_t min_buckets_count = nelua_ceilidiv((self->size * 100), 75U);
  if((bucket_count < min_buckets_count)) {
    bucket_count = min_buckets_count;
  }
  bucket_count = nelua_roundpow2(bucket_count);
  uintptr_t node_count = nelua_ceilidiv((bucket_count * 75U), 100U);
  if(((bucket_count > 0) && (node_count <= self->size))) {
    node_count = (self->size + 1);
  }
  if((((node_count < self->nodes.size) && (self->nodes.size > 0)) && (node_count > 0))) {
    uintptr_t j = 0U;
    while(((j < self->nodes.size) && (*(nelua_hashmapnode_pointer__usize_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__usize_____atindex(self->nodes, j))).filled)) {
      j = (j + 1);
    }
    for(uintptr_t i = j, _end = self->nodes.size; i < _end; i += 1) {
      if((*(nelua_hashmapnode_pointer__usize_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__usize_____atindex(self->nodes, i))).filled) {
        (*(nelua_hashmapnode_pointer__usize_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__usize_____atindex(self->nodes, j))) = (*(nelua_hashmapnode_pointer__usize_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__usize_____atindex(self->nodes, i)));
        j = (j + 1);
      }
    }
    for(uintptr_t i = j, _end = self->nodes.size; i < _end; i += 1) {
      (*(nelua_hashmapnode_pointer__usize_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__usize_____atindex(self->nodes, i))) = (nelua_hashmapnode_pointer__usize_){0};
    }
    nelua_assert_line_11((j == self->size));
  }
  self->nodes = nelua_GeneralAllocator_xspanrealloc0_2((&self->allocator), self->nodes, node_count);
  self->buckets = nelua_GeneralAllocator_xspanrealloc_3((&self->allocator), self->buckets, bucket_count);
  nelua_memory_spanset_1(self->buckets, 0xffffffffffffffffULL);
  uintptr_t free_index = 0xffffffffffffffffULL;
  for(intptr_t i = (intptr_t)(self->nodes.size - 1); i >= 0; i += -1) {
    nelua_hashmapnode_pointer__usize__ptr node = (&(*(nelua_hashmapnode_pointer__usize_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__usize_____atindex(self->nodes, (uintptr_t)i))));
    if(node->filled) {
      node->next = 0xffffffffffffffffULL;
    } else {
      node->next = free_index;
      free_index = (uintptr_t)i;
    }
  }
  self->free_index = free_index;
  for(uintptr_t i = 0U, _end = self->nodes.size; i < _end; i += 1) {
    if((*(nelua_hashmapnode_pointer__usize_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__usize_____atindex(self->nodes, i))).filled) {
      nlmulret_nlusize_nlusize_nlusize _asgnret_1 = nelua_hashmap_pointer__usize___find(self, (*(nelua_hashmapnode_pointer__usize_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__usize_____atindex(self->nodes, i))).key);
      uintptr_t node_index = _asgnret_1.r1;
      uintptr_t prev_node_index = _asgnret_1.r2;
      uintptr_t bucket_index = _asgnret_1.r3;
      if(NELUA_LIKELY((prev_node_index == 0xffffffffffffffffULL))) {
        (*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex(self->buckets, bucket_index))) = i;
      } else {
        (*(nelua_hashmapnode_pointer__usize_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__usize_____atindex(self->nodes, prev_node_index))).next = i;
      }
      (*(nelua_hashmapnode_pointer__usize_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__usize_____atindex(self->nodes, i))).next = node_index;
    }
  }
}
void nelua_assert_line_12(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/nix/store/fjg7d071zkmnh2jk44hjr291x4b4794z-nelua-0-unstable-2024-04-20/lib/nelua/lib/hashmap.nelua\033[1m:270:24: \033[31m\033[1mruntime error: \033[0m\033[1m", 144, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n      check(node_index < self.nodes.size, 'not enough space to add a node')\n                       \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~~\033[0m\n", 144, true);
    nelua_abort();
  }
}
uintptr_t nelua_hashmap_pointer__usize___at(nelua_hashmap_pointer__usize__ptr self, void* key) {
  if(NELUA_UNLIKELY((self->buckets.size == 0))) {
    nelua_hashmap_pointer__usize__rehash(self, 8U);
  }
  nlmulret_nlusize_nlusize_nlusize _asgnret_1 = nelua_hashmap_pointer__usize___find(self, key);
  uintptr_t node_index = _asgnret_1.r1;
  uintptr_t prev_node_index = _asgnret_1.r2;
  uintptr_t bucket_index = _asgnret_1.r3;
  if((node_index != 0xffffffffffffffffULL)) {
    return node_index;
  } else {
    uintptr_t node_index_2 = self->free_index;
    nelua_assert_line_12((node_index_2 < self->nodes.size), ((nlstring){(uint8_t*)"not enough space to add a node", 30}));
    nelua_hashmapnode_pointer__usize__ptr node = (&(*(nelua_hashmapnode_pointer__usize_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__usize_____atindex(self->nodes, node_index_2))));
    self->free_index = node->next;
    (*(nelua_hashmapnode_pointer__usize_*)nelua_assert_deref(node)) = (nelua_hashmapnode_pointer__usize_){.key = key, .filled = true, .next = 0xffffffffffffffffULL};
    if(NELUA_LIKELY((prev_node_index == 0xffffffffffffffffULL))) {
      (*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex(self->buckets, bucket_index))) = node_index_2;
    } else {
      (*(nelua_hashmapnode_pointer__usize_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__usize_____atindex(self->nodes, prev_node_index))).next = node_index_2;
    }
    self->size = (self->size + 1);
    if(NELUA_UNLIKELY(((self->size * 100) >= (self->buckets.size * 75U)))) {
      nelua_hashmap_pointer__usize__rehash(self, nelua_ceilidiv((self->size * 200U), 75U));
    }
    return node_index_2;
  }
}
nlusize_ptr nelua_hashmap_pointer__usize____atindex(nelua_hashmap_pointer__usize__ptr self, void* key) {
  return (&(*(nelua_hashmapnode_pointer__usize_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__usize_____atindex(self->nodes, nelua_hashmap_pointer__usize___at(self, key)))).value);
}
uintptr_t nelua_hashmap_pointer__usize__remove(nelua_hashmap_pointer__usize__ptr self, void* key) {
  nlmulret_nlusize_nlusize_nlusize _asgnret_1 = nelua_hashmap_pointer__usize___find(self, key);
  uintptr_t node_index = _asgnret_1.r1;
  uintptr_t prev_node_index = _asgnret_1.r2;
  uintptr_t bucket_index = _asgnret_1.r3;
  if(NELUA_UNLIKELY((node_index == 0xffffffffffffffffULL))) {
    return 0U;
  }
  nelua_hashmapnode_pointer__usize__ptr node = (&(*(nelua_hashmapnode_pointer__usize_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__usize_____atindex(self->nodes, node_index))));
  uintptr_t value = node->value;
  if(NELUA_LIKELY((prev_node_index == 0xffffffffffffffffULL))) {
    (*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex(self->buckets, bucket_index))) = node->next;
  } else {
    (*(nelua_hashmapnode_pointer__usize_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__usize_____atindex(self->nodes, prev_node_index))).next = node->next;
  }
  self->size = (self->size - 1);
  (*(nelua_hashmapnode_pointer__usize_*)nelua_assert_deref(node)) = (nelua_hashmapnode_pointer__usize_){.next = self->free_index};
  self->free_index = node_index;
  return value;
}
nelua_hashmapnode_pointer__usize__ptr nelua_hashmap_iteratorT_1__next_node(nelua_hashmap_iteratorT_1_ptr self, void* key) {
  if(NELUA_UNLIKELY((self->index == 0xffffffffffffffffULL))) {
    self->index = 0U;
  } else {
    self->index = (self->index + 1);
  }
  while((self->index < self->container->nodes.size)) {
    nelua_hashmapnode_pointer__usize__ptr node = (&(*(nelua_hashmapnode_pointer__usize_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__usize_____atindex(self->container->nodes, self->index))));
    if(node->filled) {
      return node;
    }
    self->index = (self->index + 1);
  }
  return ((nelua_hashmapnode_pointer__usize__ptr)NULL);
}
nlmulret_nlboolean_nlpointer_nlusize nelua_hashmap_iteratorT_1_next(nelua_hashmap_iteratorT_1_ptr self, void* key) {
  nelua_hashmapnode_pointer__usize__ptr node = nelua_hashmap_iteratorT_1__next_node(self, key);
  if((!(node != NULL))) {
    return (nlmulret_nlboolean_nlpointer_nlusize){false, NULL, 0U};
  }
  return (nlmulret_nlboolean_nlpointer_nlusize){true, node->key, node->value};
}
nlmulret_function_2EyHN9k6KLqeowE1y_nelua_hashmap_iteratorT_1_nlpointer nelua_hashmap_pointer__usize____pairs(nelua_hashmap_pointer__usize__ptr self) {
  return (nlmulret_function_2EyHN9k6KLqeowE1y_nelua_hashmap_iteratorT_1_nlpointer){nelua_hashmap_iteratorT_1_next, (nelua_hashmap_iteratorT_1){.container = self, .index = 0xffffffffffffffffULL}, NULL};
}
void nelua_vector_pointer__clear(nelua_vector_pointer__ptr self) {
  self->size = 0U;
}
void nelua_vector_pointer__destroy(nelua_vector_pointer__ptr self) {
  nelua_GeneralAllocator_spandealloc_1((&self->allocator), self->data);
  self->data = (nelua_span_pointer_){0};
  self->size = 0U;
}
void nelua_assert_line_13(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/nix/store/fjg7d071zkmnh2jk44hjr291x4b4794z-nelua-0-unstable-2024-04-20/lib/nelua/lib/vector.nelua\033[1m:124:17: \033[31m\033[1mruntime error: \033[0m\033[1m", 143, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n      check(cap > self.data.size, 'capacity overflow')\n                \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~\033[0m\n", 115, true);
    nelua_abort();
  }
}
void nelua_vectorT_grow(nelua_vector_pointer__ptr self) {
  uintptr_t cap = 1U;
  if(NELUA_LIKELY((self->data.size != 0))) {
    cap = (self->data.size * 2);
    nelua_assert_line_13((cap > self->data.size), ((nlstring){(uint8_t*)"capacity overflow", 17}));
  }
  self->data = nelua_GeneralAllocator_xspanrealloc_1((&self->allocator), self->data, cap);
}
void nelua_vector_pointer__push(nelua_vector_pointer__ptr self, void* v) {
  uintptr_t newsize = (self->size + 1);
  if(NELUA_UNLIKELY((newsize > self->data.size))) {
    nelua_vectorT_grow(self);
  }
  (*(void**)nelua_assert_deref(nelua_span_pointer____atindex(self->data, self->size))) = v;
  self->size = newsize;
}
void nelua_assert_line_14(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/nix/store/fjg7d071zkmnh2jk44hjr291x4b4794z-nelua-0-unstable-2024-04-20/lib/nelua/lib/vector.nelua\033[1m:223:15: \033[31m\033[1mruntime error: \033[0m\033[1m", 143, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    check(pos < self.size, 'position out of bounds')\n              \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 106, true);
    nelua_abort();
  }
}
nlpointer_ptr nelua_vector_pointer____atindex(nelua_vector_pointer__ptr self, uintptr_t pos) {
  nelua_assert_line_14((pos < self->size), ((nlstring){(uint8_t*)"position out of bounds", 22}));
  return (&(*(void**)nelua_assert_deref(nelua_span_pointer____atindex(self->data, pos))));
}
void nelua_vector_GCScanRange__destroy(nelua_vector_GCScanRange__ptr self) {
  nelua_GeneralAllocator_spandealloc_2((&self->allocator), self->data);
  self->data = (nelua_span_GCScanRange_){0};
  self->size = 0U;
}
void nelua_assert_line_15(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/nix/store/fjg7d071zkmnh2jk44hjr291x4b4794z-nelua-0-unstable-2024-04-20/lib/nelua/lib/vector.nelua\033[1m:124:17: \033[31m\033[1mruntime error: \033[0m\033[1m", 143, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n      check(cap > self.data.size, 'capacity overflow')\n                \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~\033[0m\n", 115, true);
    nelua_abort();
  }
}
void nelua_vectorT_grow_1(nelua_vector_GCScanRange__ptr self) {
  uintptr_t cap = 1U;
  if(NELUA_LIKELY((self->data.size != 0))) {
    cap = (self->data.size * 2);
    nelua_assert_line_15((cap > self->data.size), ((nlstring){(uint8_t*)"capacity overflow", 17}));
  }
  self->data = nelua_GeneralAllocator_xspanrealloc_2((&self->allocator), self->data, cap);
}
void nelua_vector_GCScanRange__push(nelua_vector_GCScanRange__ptr self, nelua_GCScanRange v) {
  uintptr_t newsize = (self->size + 1);
  if(NELUA_UNLIKELY((newsize > self->data.size))) {
    nelua_vectorT_grow_1(self);
  }
  (*(nelua_GCScanRange*)nelua_assert_deref(nelua_span_GCScanRange____atindex(self->data, self->size))) = v;
  self->size = newsize;
}
void nelua_assert_line_16(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/nix/store/fjg7d071zkmnh2jk44hjr291x4b4794z-nelua-0-unstable-2024-04-20/lib/nelua/lib/vector.nelua\033[1m:144:21: \033[31m\033[1mruntime error: \033[0m\033[1m", 143, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    check(self.size > 0, 'attempt to pop an empty vector')\n                    \033[1m\033[32m^\033[0m\033[35m~~\033[0m\n", 110, true);
    nelua_abort();
  }
}
nelua_GCScanRange nelua_vector_GCScanRange__pop(nelua_vector_GCScanRange__ptr self) {
  nelua_assert_line_16((self->size > 0), ((nlstring){(uint8_t*)"attempt to pop an empty vector", 30}));
  self->size = (self->size - 1);
  return (*(nelua_GCScanRange*)nelua_assert_deref(nelua_span_GCScanRange____atindex(self->data, self->size)));
}
bool nelua_hasflag(uintptr_t flags, uintptr_t flag) {
  return ((flags & flag) != 0);
}
uintptr_t nelua_align_forward(uintptr_t addr, uintptr_t align) {
  return ((addr + (align - 1)) & (~(align - 1)));
}
void nelua_assert_line_17(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/nix/store/fjg7d071zkmnh2jk44hjr291x4b4794z-nelua-0-unstable-2024-04-20/lib/nelua/lib/allocators/gc.nelua\033[1m:140:20: \033[31m\033[1mruntime error: \033[0m\033[1m", 150, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    assert(oldsize ~= 0, 'invalid unregister pointer')\n                   \033[1m\033[32m^\033[0m\033[35m~~~\033[0m\n", 106, true);
    nelua_abort();
  }
}
void nelua_GC_unregister_1(nelua_GC_ptr self, void* ptr, bool finalize) {
  if(NELUA_UNLIKELY((!(ptr != NULL)))) {
    return;
  }
  nelua_GCItem item = nelua_hashmap_pointer__GCItem__remove((&self->items), ptr);
  if(NELUA_LIKELY((item.size != 0))) {
    self->membytes = (self->membytes - item.size);
    for(uintptr_t i = 0U, _end = self->finalizeitems.size; i < _end; i += 1) {
      if(((*(void**)nelua_assert_deref(nelua_vector_pointer____atindex((&self->finalizeitems), i))) == ptr)) {
        (*(void**)nelua_assert_deref(nelua_vector_pointer____atindex((&self->finalizeitems), i))) = (void*)NULL;
        break;
      }
    }
    if((finalize && (item.finalizer != NULL))) {
      item.finalizer(ptr, item.userdata);
    }
  } else {
    uintptr_t oldsize = nelua_hashmap_pointer__usize__remove((&self->rootitems), ptr);
    nelua_assert_line_17((oldsize != 0), ((nlstring){(uint8_t*)"invalid unregister pointer", 26}));
  }
}
void nelua_GC_markptrs(nelua_GC_ptr self) {
  uintptr_t addrtestmask = ((~self->addrormask) | self->addrandmask);
  uintptr_t addrandmask = self->addrandmask;
  while((self->scanranges.size > 0)) {
    nelua_GCScanRange range = nelua_vector_GCScanRange__pop((&self->scanranges));
    for(uintptr_t memaddr = range.low, _end = range.high; memaddr < _end; memaddr += 8) {
      uintptr_t addr = (*(uintptr_t*)nelua_assert_deref((nlusize_ptr)memaddr));
      if(((addr & addrtestmask) == addrandmask)) {
        nelua_GCItem_ptr item = nelua_hashmap_pointer__GCItem__peek((&self->items), (void*)addr);
        if(((item != NULL) && (!nelua_hasflag(item->flags, 65536U)))) {
          item->flags = (item->flags | 65536U);
          if((!nelua_hasflag(item->flags, 262144U))) {
            nelua_vector_GCScanRange__push((&self->scanranges), (nelua_GCScanRange){addr, (addr + item->size)});
          }
        }
      }
    }
  }
}
void nelua_GC_scanrange(nelua_GC_ptr self, uintptr_t low, uintptr_t high) {
  nelua_vector_GCScanRange__push((&self->scanranges), (nelua_GCScanRange){low, high});
}
void nelua_GC_scanptr(nelua_GC_ptr self, void* ptr) {
  nelua_GCItem_ptr item = nelua_hashmap_pointer__GCItem__peek((&self->items), ptr);
  if(((item != NULL) && (!nelua_hasflag(item->flags, 65536U)))) {
    item->flags = (item->flags | 65536U);
    if((!nelua_hasflag(item->flags, 262144U))) {
      uintptr_t addr = (uintptr_t)ptr;
      nelua_vector_GCScanRange__push((&self->scanranges), (nelua_GCScanRange){addr, (addr + item->size)});
    }
  }
}
void nelua_GC_scanstack(nelua_GC_ptr self) {
  nelua_RegsBuf regsbuf;
  setjmp(regsbuf.regs);
#if defined(__GNUC__) || defined(__clang__)
  void* sp = __builtin_frame_address(0);
#endif
  uintptr_t low = ((self->stacktop == 0) ? (uintptr_t)(&regsbuf) : self->stacktop);
  uintptr_t high = self->stackbottom;
  if((high < low)) {
    uintptr_t _asgntmp_1 = high;
    uintptr_t _asgntmp_2 = low;
    low = _asgntmp_1;
    high = _asgntmp_2;
  }
  low = nelua_align_forward(low, 8U);
  nelua_GC_scanrange(self, low, high);
  nelua_GC_scanrange(self, (uintptr_t)(&regsbuf), ((uintptr_t)(&regsbuf) + (uintptr_t)sizeof(nelua_RegsBuf)));
#if defined(__GNUC__) || defined(__clang__)
  nelua_GC_scanptr(self, sp);
#endif
}
void nelua_GC_mark(nelua_GC_ptr self) {
  {
    nlmulret_function_2EyHN9k6KLqeowE1y_nelua_hashmap_iteratorT_1_nlpointer _asgnret_1 = nelua_pairs_1((&self->rootitems));
    function_2EyHN9k6KLqeowE1y __fornext = _asgnret_1.r1;
    nelua_hashmap_iteratorT_1 __forstate = _asgnret_1.r2;
    void* __fornextit = _asgnret_1.r3;
    while(true) {
      nlmulret_nlboolean_nlpointer_nlusize _asgnret_2 = __fornext((&__forstate), __fornextit);
      bool __forcont = _asgnret_2.r1;
      void* ptr = _asgnret_2.r2;
      uintptr_t item_size = _asgnret_2.r3;
      if((!__forcont)) {
        break;
      }
      __fornextit = ptr;
      {
        uintptr_t addr = (uintptr_t)ptr;
        nelua_vector_GCScanRange__push((&self->scanranges), (nelua_GCScanRange){addr, (addr + item_size)});
      }
    }
  }
  if((self->stackbottom != 0)) {
    volatile function_rmio2ccn5TvMa852 scanstack = nelua_GC_scanstack;
    scanstack(self);
  }
  nelua_GC_markptrs(self);
}
void nelua_assert_line_18(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/nix/store/fjg7d071zkmnh2jk44hjr291x4b4794z-nelua-0-unstable-2024-04-20/lib/nelua/lib/allocators/gc.nelua\033[1m:247:13: \033[31m\033[1mruntime error: \033[0m\033[1m", 150, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n      check(removed, 'gc item not found to erase')\n            \033[1m\033[32m^\033[0m\033[35m~~~~~~\033[0m\n", 98, true);
    nelua_abort();
  }
}
void nelua_assert_line_19(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/nix/store/fjg7d071zkmnh2jk44hjr291x4b4794z-nelua-0-unstable-2024-04-20/lib/nelua/lib/allocators/gc.nelua\033[1m:260:18: \033[31m\033[1mruntime error: \033[0m\033[1m", 150, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n      check(item ~= nilptr, 'gc item not found to finalize')\n                 \033[1m\033[32m^\033[0m\033[35m~~~~~~~~\033[0m\n", 115, true);
    nelua_abort();
  }
}
void nelua_assert_line_20(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/nix/store/fjg7d071zkmnh2jk44hjr291x4b4794z-nelua-0-unstable-2024-04-20/lib/nelua/lib/allocators/gc.nelua\033[1m:275:23: \033[31m\033[1mruntime error: \033[0m\033[1m", 150, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n      check(item.size ~= 0, 'gc item not found to deallocate')\n                      \033[1m\033[32m^\033[0m\033[35m~~~\033[0m\n", 117, true);
    nelua_abort();
  }
}
void nelua_GC_sweep(nelua_GC_ptr self) {
  uintptr_t membytes = self->membytes;
  {
    nlmulret_function_3dDifWjDdRxpgM1fu_nelua_hashmap_iteratorT_nlpointer _asgnret_1 = nelua_mpairs_1((&self->items));
    function_3dDifWjDdRxpgM1fu __fornext = _asgnret_1.r1;
    nelua_hashmap_iteratorT __forstate = _asgnret_1.r2;
    void* __fornextit = _asgnret_1.r3;
    while(true) {
      nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr _asgnret_2 = __fornext((&__forstate), __fornextit);
      bool __forcont = _asgnret_2.r1;
      void* ptr = _asgnret_2.r2;
      nelua_GCItem_ptr item = _asgnret_2.r3;
      if((!__forcont)) {
        break;
      }
      __fornextit = ptr;
      {
        uintptr_t item_flags = item->flags;
        if(nelua_hasflag(item_flags, 65536U)) {
          item->flags = (item_flags & 18446744073709486079ULL);
        } else if(NELUA_UNLIKELY(nelua_hasflag(item_flags, 131072U))) {
          nelua_vector_pointer__push((&self->finalizeitems), ptr);
        } else {
          membytes = (membytes - item->size);
          bool removed = nelua_hashmap_pointer__GCItem__erase((&self->items), ptr);
          nelua_assert_line_18(removed, ((nlstring){(uint8_t*)"gc item not found to erase", 26}));
          if(NELUA_LIKELY((!nelua_hasflag(item_flags, 1048576U)))) {
            nelua_GeneralAllocator_dealloc((&nelua_general_allocator), ptr);
          }
        }
      }
    }
  }
  self->membytes = membytes;
  uintptr_t i = 0U;
  while((i < self->finalizeitems.size)) {
    void* ptr = (*(void**)nelua_assert_deref(nelua_vector_pointer____atindex((&self->finalizeitems), i)));
    if(NELUA_LIKELY((ptr != NULL))) {
      nelua_GCItem_ptr item = nelua_hashmap_pointer__GCItem__peek((&self->items), ptr);
      nelua_assert_line_19((item != ((nelua_GCItem_ptr)NULL)), ((nlstring){(uint8_t*)"gc item not found to finalize", 29}));
      if(NELUA_LIKELY(((item != NULL) && (item->finalizer != NULL)))) {
        nelua_GCFinalizerCallback finalizer = item->finalizer;
        item->finalizer = (nelua_GCFinalizerCallback)NULL;
        finalizer(ptr, item->userdata);
      }
    }
    i = (i + 1);
  }
  uintptr_t i_1 = 0U;
  while((i_1 < self->finalizeitems.size)) {
    void* ptr = (*(void**)nelua_assert_deref(nelua_vector_pointer____atindex((&self->finalizeitems), i_1)));
    if(NELUA_LIKELY((ptr != NULL))) {
      nelua_GCItem item = nelua_hashmap_pointer__GCItem__remove((&self->items), ptr);
      nelua_assert_line_20((item.size != 0), ((nlstring){(uint8_t*)"gc item not found to deallocate", 31}));
      if(NELUA_LIKELY((item.size != 0))) {
        self->membytes = (self->membytes - item.size);
        if(NELUA_UNLIKELY((!nelua_hasflag(item.flags, 1048576U)))) {
          nelua_GeneralAllocator_dealloc((&nelua_general_allocator), ptr);
        }
      }
    }
    i_1 = (i_1 + 1);
  }
  nelua_vector_pointer__clear((&self->finalizeitems));
}
void nelua_GC_rehash(nelua_GC_ptr self) {
  if((((self->items.size * 4) < self->items.buckets.size) && (self->items.buckets.size > 8))) {
    nelua_hashmap_pointer__GCItem__rehash((&self->items), 0U);
  }
  if((((self->rootitems.size * 4) < self->rootitems.buckets.size) && (self->rootitems.buckets.size > 8))) {
    nelua_hashmap_pointer__usize__rehash((&self->rootitems), 0U);
  }
}
void nelua_GC_collect(nelua_GC_ptr self) {
  if((self->collecting || (self->membytes == 0))) {
    return;
  }
  self->collecting = true;
  nelua_GC_mark(self);
  nelua_GC_sweep(self);
  nelua_GC_rehash(self);
  self->lastmembytes = self->membytes;
  self->collecting = false;
}
void nelua_GC_registerroots(nelua_GC_ptr self) {
  nelua_GC_register((&nelua_gc), (void*)(&nelua_io_stdin), 8U, 131072U, (function_2gZWAqbgEuvU3TiaR)NULL, (void*)NULL);
  nelua_GC_register((&nelua_gc), (void*)(&nelua_io_stdout), 8U, 131072U, (function_2gZWAqbgEuvU3TiaR)NULL, (void*)NULL);
  nelua_GC_register((&nelua_gc), (void*)(&main_event_bus), 280U, 131072U, (function_2gZWAqbgEuvU3TiaR)NULL, (void*)NULL);
  nelua_GC_register((&nelua_gc), (void*)(&main_map), 1984U, 131072U, (function_2gZWAqbgEuvU3TiaR)NULL, (void*)NULL);
  nelua_GC_register((&nelua_gc), (void*)(&nelua_stdinfs), 16U, 131072U, (function_2gZWAqbgEuvU3TiaR)NULL, (void*)NULL);
  nelua_GC_register((&nelua_gc), (void*)(&nelua_stdoutfs), 16U, 131072U, (function_2gZWAqbgEuvU3TiaR)NULL, (void*)NULL);
}
bool nelua_GC_step(nelua_GC_ptr self) {
  if(((!self->collecting) && ((self->membytes * 100) >= (self->lastmembytes * self->pause)))) {
    nelua_GC_collect(self);
    return true;
  }
  return false;
}
void nelua_assert_line_21(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/nix/store/fjg7d071zkmnh2jk44hjr291x4b4794z-nelua-0-unstable-2024-04-20/lib/nelua/lib/allocators/gc.nelua\033[1m:382:15: \033[31m\033[1mruntime error: \033[0m\033[1m", 150, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n  assert(size > 0, 'attempt to register a pointer with size zero')\n              \033[1m\033[32m^\033[0m\033[35m~~\033[0m\n", 112, true);
    nelua_abort();
  }
}
void nelua_assert_line_22(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/nix/store/fjg7d071zkmnh2jk44hjr291x4b4794z-nelua-0-unstable-2024-04-20/lib/nelua/lib/allocators/gc.nelua\033[1m:389:21: \033[31m\033[1mruntime error: \033[0m\033[1m", 150, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    check(item.size == 0, 'cannot register pointer twice')\n                    \033[1m\033[32m^\033[0m\033[35m~~~\033[0m\n", 111, true);
    nelua_abort();
  }
}
void nelua_assert_line_23(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/nix/store/fjg7d071zkmnh2jk44hjr291x4b4794z-nelua-0-unstable-2024-04-20/lib/nelua/lib/allocators/gc.nelua\033[1m:406:18: \033[31m\033[1mruntime error: \033[0m\033[1m", 150, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    assert(flags == GCFlags.ROOT, 'attempt to register a root pointer with invalid flags')\n                 \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~\033[0m\n", 151, true);
    nelua_abort();
  }
}
void nelua_assert_line_24(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/nix/store/fjg7d071zkmnh2jk44hjr291x4b4794z-nelua-0-unstable-2024-04-20/lib/nelua/lib/allocators/gc.nelua\033[1m:407:32: \033[31m\033[1mruntime error: \033[0m\033[1m", 150, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    assert(finalizer == nilptr and userdata == nilptr, 'attempt to register a root pointer with finalizer')\n                               \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~~~~~~~\033[0m\n", 189, true);
    nelua_abort();
  }
}
void nelua_GC_register(nelua_GC_ptr self, void* ptr, uintptr_t size, uintptr_t flags, function_2gZWAqbgEuvU3TiaR finalizer, void* userdata) {
  if(NELUA_UNLIKELY((!(ptr != NULL)))) {
    return;
  }
  nelua_assert_line_21((size > 0), ((nlstring){(uint8_t*)"attempt to register a pointer with size zero", 44}));
  if(NELUA_LIKELY((!nelua_hasflag(flags, 131072U)))) {
    if(NELUA_UNLIKELY((size < 8))) {
      flags = (flags | 262144U);
    }
    if(NELUA_UNLIKELY((finalizer != NULL))) {
      flags = (flags | 131072U);
    }
    nelua_GCItem_ptr item = (&(*(nelua_GCItem*)nelua_assert_deref(nelua_hashmap_pointer__GCItem____atindex((&self->items), ptr))));
    nelua_assert_line_22((item->size == 0), ((nlstring){(uint8_t*)"cannot register pointer twice", 29}));
    (*(nelua_GCItem*)nelua_assert_deref(item)) = (nelua_GCItem){.flags = flags, .size = size, .finalizer = finalizer, .userdata = userdata};
    uintptr_t addr = (uintptr_t)ptr;
    self->addrormask = (self->addrormask | addr);
    self->addrandmask = (self->addrandmask & addr);
    self->membytes = (self->membytes + size);
    if(NELUA_LIKELY(self->running)) {
      nelua_GC_step(self);
    }
  } else {
    nelua_assert_line_23((flags == 131072U), ((nlstring){(uint8_t*)"attempt to register a root pointer with invalid flags", 53}));
    nelua_assert_line_24(((finalizer == (function_2gZWAqbgEuvU3TiaR)NULL) && (userdata == (void*)NULL)), ((nlstring){(uint8_t*)"attempt to register a root pointer with finalizer", 49}));
    (*(uintptr_t*)nelua_assert_deref(nelua_hashmap_pointer__usize____atindex((&self->rootitems), ptr))) = size;
  }
}
void nelua_assert_line_25(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/nix/store/fjg7d071zkmnh2jk44hjr291x4b4794z-nelua-0-unstable-2024-04-20/lib/nelua/lib/allocators/gc.nelua\033[1m:417:47: \033[31m\033[1mruntime error: \033[0m\033[1m", 150, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n  check(oldptr ~= nilptr and newptr ~= nilptr and newsize > 0, 'invalid reregister arguments')\n                                              \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~\033[0m\n", 184, true);
    nelua_abort();
  }
}
void nelua_assert_line_26(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/nix/store/fjg7d071zkmnh2jk44hjr291x4b4794z-nelua-0-unstable-2024-04-20/lib/nelua/lib/allocators/gc.nelua\033[1m:433:22: \033[31m\033[1mruntime error: \033[0m\033[1m", 150, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n      assert(oldsize ~= 0, 'invalid reregister pointer')\n                     \033[1m\033[32m^\033[0m\033[35m~~~\033[0m\n", 110, true);
    nelua_abort();
  }
}
void nelua_assert_line_27(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/nix/store/fjg7d071zkmnh2jk44hjr291x4b4794z-nelua-0-unstable-2024-04-20/lib/nelua/lib/allocators/gc.nelua\033[1m:452:22: \033[31m\033[1mruntime error: \033[0m\033[1m", 150, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n      assert(oldsize ~= 0, 'invalid reregister pointer')\n                     \033[1m\033[32m^\033[0m\033[35m~~~\033[0m\n", 110, true);
    nelua_abort();
  }
}
void nelua_GC_reregister(nelua_GC_ptr self, void* oldptr, void* newptr, uintptr_t newsize) {
  nelua_assert_line_25((((oldptr != (void*)NULL) && (newptr != (void*)NULL)) && (newsize > 0)), ((nlstring){(uint8_t*)"invalid reregister arguments", 28}));
  if((newptr == oldptr)) {
    nelua_GCItem_ptr item = nelua_hashmap_pointer__GCItem__peek((&self->items), oldptr);
    if(NELUA_LIKELY((item != NULL))) {
      uintptr_t oldsize = item->size;
      item->size = newsize;
      if(NELUA_LIKELY((newsize > oldsize))) {
        self->membytes = (self->membytes + (newsize - oldsize));
        if(NELUA_LIKELY(self->running)) {
          nelua_GC_step(self);
        }
      } else if((newsize < oldsize)) {
        self->membytes = (self->membytes - (oldsize - newsize));
      }
    } else {
      uintptr_t oldsize = nelua_hashmap_pointer__usize__remove((&self->rootitems), oldptr);
      nelua_assert_line_26((oldsize != 0), ((nlstring){(uint8_t*)"invalid reregister pointer", 26}));
      (*(uintptr_t*)nelua_assert_deref(nelua_hashmap_pointer__usize____atindex((&self->rootitems), newptr))) = newsize;
    }
  } else {
    nelua_GCItem item = nelua_hashmap_pointer__GCItem__remove((&self->items), oldptr);
    if(NELUA_LIKELY((item.size != 0))) {
      uintptr_t oldsize = item.size;
      self->membytes = (self->membytes - oldsize);
      for(uintptr_t i = 0U, _end = self->finalizeitems.size; i < _end; i += 1) {
        if(((*(void**)nelua_assert_deref(nelua_vector_pointer____atindex((&self->finalizeitems), i))) == oldptr)) {
          (*(void**)nelua_assert_deref(nelua_vector_pointer____atindex((&self->finalizeitems), i))) = newptr;
          break;
        }
      }
      nelua_GC_register(self, newptr, newsize, item.flags, item.finalizer, item.userdata);
    } else {
      uintptr_t oldsize = nelua_hashmap_pointer__usize__remove((&self->rootitems), oldptr);
      nelua_assert_line_27((oldsize != 0), ((nlstring){(uint8_t*)"invalid reregister pointer", 26}));
      (*(uintptr_t*)nelua_assert_deref(nelua_hashmap_pointer__usize____atindex((&self->rootitems), newptr))) = newsize;
    }
  }
}
void nelua_GC_restart(nelua_GC_ptr self) {
  self->running = true;
}
void nelua_GC_init(nelua_GC_ptr self, void* stack) {
  self->stackbottom = (uintptr_t)stack;
  self->addrandmask = 0xffffffffffffffffULL;
  self->pause = 200U;
  nelua_GC_registerroots(self);
  nelua_GC_restart(self);
}
void nelua_GC_destroy(nelua_GC_ptr self) {
  self->collecting = true;
  nelua_GC_sweep(self);
  self->collecting = false;
  nelua_hashmap_pointer__GCItem__destroy((&self->items));
  nelua_hashmap_pointer__usize__destroy((&self->rootitems));
  nelua_vector_pointer__destroy((&self->finalizeitems));
  nelua_vector_GCScanRange__destroy((&self->scanranges));
  (*(nelua_GC*)nelua_assert_deref(self)) = (nelua_GC){0};
}
int main(int argc, nlcstring_ptr argv) {
  nelua_GC_init((&nelua_gc), (void*)(&argc));
  volatile function_2kJXCPHs2QinkWNvV inner_main = nelua_main;
  int ret = inner_main(argc, argv);
  nelua_GC_destroy((&nelua_gc));
  return ret;
}
void* nelua_GCAllocator_alloc_1(nelua_GCAllocator_ptr self, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata) {
  if(NELUA_UNLIKELY((size == 0))) {
    return (void*)NULL;
  }
  uintptr_t flags_3 = 0U;
  nelua_GCFinalizerCallback finalizer_1 = (nelua_GCFinalizerCallback)NULL;
  void* userdata_1 = (void*)NULL;
  void* ptr = nelua_GeneralAllocator_alloc_1((&nelua_general_allocator), size, flags_3);
  nelua_GC_register((&nelua_gc), ptr, size, flags_3, finalizer_1, userdata_1);
  return ptr;
}
void* nelua_GCAllocator_alloc_3(nelua_GCAllocator_ptr self, uintptr_t size, uintptr_t flags, nelua_GCFinalizerCallback finalizer, void* userdata) {
  if(NELUA_UNLIKELY((size == 0))) {
    return (void*)NULL;
  }
  void* ptr = nelua_GeneralAllocator_alloc_1((&nelua_general_allocator), size, flags);
  nelua_GC_register((&nelua_gc), ptr, size, flags, finalizer, userdata);
  return ptr;
}
void* nelua_GCAllocator_alloc0_1(nelua_GCAllocator_ptr self, uintptr_t size, nlniltype flags, nelua_GCFinalizerCallback finalizer, void* userdata) {
  if(NELUA_UNLIKELY((size == 0))) {
    return (void*)NULL;
  }
  uintptr_t flags_4 = 0U;
  void* ptr = nelua_GeneralAllocator_alloc0_2((&nelua_general_allocator), size, flags_4);
  nelua_GC_register((&nelua_gc), ptr, size, flags_4, finalizer, userdata);
  return ptr;
}
void* nelua_GCAllocator_alloc0_2(nelua_GCAllocator_ptr self, uintptr_t size, uintptr_t flags, nelua_GCFinalizerCallback finalizer, void* userdata) {
  if(NELUA_UNLIKELY((size == 0))) {
    return (void*)NULL;
  }
  void* ptr = nelua_GeneralAllocator_alloc0_2((&nelua_general_allocator), size, flags);
  nelua_GC_register((&nelua_gc), ptr, size, flags, finalizer, userdata);
  return ptr;
}
void nelua_GCAllocator_dealloc(nelua_GCAllocator_ptr self, void* ptr) {
  nelua_GC_unregister_1((&nelua_gc), ptr, true);
  nelua_GeneralAllocator_dealloc((&nelua_general_allocator), ptr);
}
void* nelua_GCAllocator_realloc(nelua_GCAllocator_ptr self, void* ptr, uintptr_t newsize, uintptr_t oldsize) {
  if(NELUA_UNLIKELY((ptr == (void*)NULL))) {
    return nelua_GCAllocator_alloc_1(self, newsize, NELUA_NIL, NELUA_NIL, NELUA_NIL);
  } else if(NELUA_UNLIKELY((newsize == 0))) {
    nelua_GCAllocator_dealloc(self, ptr);
    return (void*)NULL;
  } else if(NELUA_UNLIKELY((newsize == oldsize))) {
    return ptr;
  } else {
    void* newptr = nelua_GeneralAllocator_realloc((&nelua_general_allocator), ptr, newsize, oldsize);
    if(NELUA_LIKELY((newptr != NULL))) {
      nelua_GC_reregister((&nelua_gc), ptr, newptr, newsize);
    }
    return newptr;
  }
}
nelua_span_uint8_ nelua_GCAllocator_spanalloc_2(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata) {
  uintptr_t flags_5 = 262144U;
  nelua_GCFinalizerCallback finalizer_2 = (nelua_GCFinalizerCallback)NULL;
  void* userdata_2 = (void*)NULL;
  if(NELUA_LIKELY((size > 0))) {
    nluint8_arr0_ptr data = ((nluint8_arr0_ptr)nelua_GCAllocator_alloc_3(self, (size * 1), flags_5, finalizer_2, userdata_2));
    if(NELUA_LIKELY((data != ((nluint8_arr0_ptr)NULL)))) {
      return (nelua_span_uint8_){.data = data, .size = size};
    }
  }
  return (nelua_span_uint8_){0};
}
nelua_span_uint8_ nelua_GCAllocator_spanalloc0_1(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata) {
  uintptr_t flags_6 = 262144U;
  nelua_GCFinalizerCallback finalizer_3 = (nelua_GCFinalizerCallback)NULL;
  void* userdata_3 = (void*)NULL;
  if(NELUA_LIKELY((size > 0))) {
    nluint8_arr0_ptr data = ((nluint8_arr0_ptr)nelua_GCAllocator_alloc0_2(self, (size * 1), flags_6, finalizer_3, userdata_3));
    if(NELUA_LIKELY((data != ((nluint8_arr0_ptr)NULL)))) {
      return (nelua_span_uint8_){.data = data, .size = size};
    }
  }
  return (nelua_span_uint8_){0};
}
void nelua_assert_line_28(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/nix/store/fjg7d071zkmnh2jk44hjr291x4b4794z-nelua-0-unstable-2024-04-20/lib/nelua/lib/allocators/gc.nelua\033[1m:779:16: \033[31m\033[1mruntime error: \033[0m\033[1m", 150, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    assert(ptr ~= nilptr, 'out of memory')\n               \033[1m\033[32m^\033[0m\033[35m~~~~~~~~\033[0m\n", 95, true);
    nelua_abort();
  }
}
pool_Chunk_1_ptr nelua_GCAllocator_new_4(nelua_GCAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags) {
  nelua_GCFinalizerCallback finalizer = (nelua_GCFinalizerCallback)NULL;
  pool_Chunk_1_ptr ptr;
  ptr = ((pool_Chunk_1_ptr)nelua_GCAllocator_alloc0_1((&nelua_gc_allocator), 264U, NELUA_NIL, finalizer, (void*)NULL));
  nelua_assert_line_28((ptr != ((pool_Chunk_1_ptr)NULL)), ((nlstring){(uint8_t*)"out of memory", 13}));
  return ptr;
}
void nelua_assert_line_29(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/nix/store/fjg7d071zkmnh2jk44hjr291x4b4794z-nelua-0-unstable-2024-04-20/lib/nelua/lib/allocators/gc.nelua\033[1m:779:16: \033[31m\033[1mruntime error: \033[0m\033[1m", 150, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    assert(ptr ~= nilptr, 'out of memory')\n               \033[1m\033[32m^\033[0m\033[35m~~~~~~~~\033[0m\n", 95, true);
    nelua_abort();
  }
}
pool_Chunk_2_ptr nelua_GCAllocator_new_5(nelua_GCAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags) {
  nelua_GCFinalizerCallback finalizer = (nelua_GCFinalizerCallback)NULL;
  pool_Chunk_2_ptr ptr;
  ptr = ((pool_Chunk_2_ptr)nelua_GCAllocator_alloc0_1((&nelua_gc_allocator), 264U, NELUA_NIL, finalizer, (void*)NULL));
  nelua_assert_line_29((ptr != ((pool_Chunk_2_ptr)NULL)), ((nlstring){(uint8_t*)"out of memory", 13}));
  return ptr;
}
void nelua_assert_line_30(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/nix/store/fjg7d071zkmnh2jk44hjr291x4b4794z-nelua-0-unstable-2024-04-20/lib/nelua/lib/allocators/gc.nelua\033[1m:779:16: \033[31m\033[1mruntime error: \033[0m\033[1m", 150, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    assert(ptr ~= nilptr, 'out of memory')\n               \033[1m\033[32m^\033[0m\033[35m~~~~~~~~\033[0m\n", 95, true);
    nelua_abort();
  }
}
pool_Chunk_3_ptr nelua_GCAllocator_new_6(nelua_GCAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags) {
  nelua_GCFinalizerCallback finalizer = (nelua_GCFinalizerCallback)NULL;
  pool_Chunk_3_ptr ptr;
  ptr = ((pool_Chunk_3_ptr)nelua_GCAllocator_alloc0_1((&nelua_gc_allocator), 264U, NELUA_NIL, finalizer, (void*)NULL));
  nelua_assert_line_30((ptr != ((pool_Chunk_3_ptr)NULL)), ((nlstring){(uint8_t*)"out of memory", 13}));
  return ptr;
}
void nelua_assert_line_31(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/nix/store/fjg7d071zkmnh2jk44hjr291x4b4794z-nelua-0-unstable-2024-04-20/lib/nelua/lib/allocators/gc.nelua\033[1m:779:16: \033[31m\033[1mruntime error: \033[0m\033[1m", 150, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    assert(ptr ~= nilptr, 'out of memory')\n               \033[1m\033[32m^\033[0m\033[35m~~~~~~~~\033[0m\n", 95, true);
    nelua_abort();
  }
}
pool_Chunk_4_ptr nelua_GCAllocator_new_7(nelua_GCAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags) {
  nelua_GCFinalizerCallback finalizer = (nelua_GCFinalizerCallback)NULL;
  pool_Chunk_4_ptr ptr;
  ptr = ((pool_Chunk_4_ptr)nelua_GCAllocator_alloc0_1((&nelua_gc_allocator), 264U, NELUA_NIL, finalizer, (void*)NULL));
  nelua_assert_line_31((ptr != ((pool_Chunk_4_ptr)NULL)), ((nlstring){(uint8_t*)"out of memory", 13}));
  return ptr;
}
void nelua_assert_line_32(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/nix/store/fjg7d071zkmnh2jk44hjr291x4b4794z-nelua-0-unstable-2024-04-20/lib/nelua/lib/allocators/gc.nelua\033[1m:779:16: \033[31m\033[1mruntime error: \033[0m\033[1m", 150, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    assert(ptr ~= nilptr, 'out of memory')\n               \033[1m\033[32m^\033[0m\033[35m~~~~~~~~\033[0m\n", 95, true);
    nelua_abort();
  }
}
pool_Chunk_5_ptr nelua_GCAllocator_new_8(nelua_GCAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags) {
  nelua_GCFinalizerCallback finalizer = (nelua_GCFinalizerCallback)NULL;
  pool_Chunk_5_ptr ptr;
  ptr = ((pool_Chunk_5_ptr)nelua_GCAllocator_alloc0_1((&nelua_gc_allocator), 264U, NELUA_NIL, finalizer, (void*)NULL));
  nelua_assert_line_32((ptr != ((pool_Chunk_5_ptr)NULL)), ((nlstring){(uint8_t*)"out of memory", 13}));
  return ptr;
}
void nelua_assert_line_33(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/nix/store/fjg7d071zkmnh2jk44hjr291x4b4794z-nelua-0-unstable-2024-04-20/lib/nelua/lib/allocators/gc.nelua\033[1m:779:16: \033[31m\033[1mruntime error: \033[0m\033[1m", 150, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    assert(ptr ~= nilptr, 'out of memory')\n               \033[1m\033[32m^\033[0m\033[35m~~~~~~~~\033[0m\n", 95, true);
    nelua_abort();
  }
}
pool_Chunk_6_ptr nelua_GCAllocator_new_9(nelua_GCAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags) {
  nelua_GCFinalizerCallback finalizer = (nelua_GCFinalizerCallback)NULL;
  pool_Chunk_6_ptr ptr;
  ptr = ((pool_Chunk_6_ptr)nelua_GCAllocator_alloc0_1((&nelua_gc_allocator), 264U, NELUA_NIL, finalizer, (void*)NULL));
  nelua_assert_line_33((ptr != ((pool_Chunk_6_ptr)NULL)), ((nlstring){(uint8_t*)"out of memory", 13}));
  return ptr;
}
void nelua_assert_line_34(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/nix/store/fjg7d071zkmnh2jk44hjr291x4b4794z-nelua-0-unstable-2024-04-20/lib/nelua/lib/allocators/gc.nelua\033[1m:779:16: \033[31m\033[1mruntime error: \033[0m\033[1m", 150, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    assert(ptr ~= nilptr, 'out of memory')\n               \033[1m\033[32m^\033[0m\033[35m~~~~~~~~\033[0m\n", 95, true);
    nelua_abort();
  }
}
pool_Chunk_7_ptr nelua_GCAllocator_new_10(nelua_GCAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags) {
  nelua_GCFinalizerCallback finalizer = (nelua_GCFinalizerCallback)NULL;
  pool_Chunk_7_ptr ptr;
  ptr = ((pool_Chunk_7_ptr)nelua_GCAllocator_alloc0_1((&nelua_gc_allocator), 264U, NELUA_NIL, finalizer, (void*)NULL));
  nelua_assert_line_34((ptr != ((pool_Chunk_7_ptr)NULL)), ((nlstring){(uint8_t*)"out of memory", 13}));
  return ptr;
}
void nelua_assert_line_35(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/nix/store/fjg7d071zkmnh2jk44hjr291x4b4794z-nelua-0-unstable-2024-04-20/lib/nelua/lib/allocators/gc.nelua\033[1m:779:16: \033[31m\033[1mruntime error: \033[0m\033[1m", 150, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    assert(ptr ~= nilptr, 'out of memory')\n               \033[1m\033[32m^\033[0m\033[35m~~~~~~~~\033[0m\n", 95, true);
    nelua_abort();
  }
}
pool_Chunk_8_ptr nelua_GCAllocator_new_11(nelua_GCAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags) {
  nelua_GCFinalizerCallback finalizer = (nelua_GCFinalizerCallback)NULL;
  pool_Chunk_8_ptr ptr;
  ptr = ((pool_Chunk_8_ptr)nelua_GCAllocator_alloc0_1((&nelua_gc_allocator), 264U, NELUA_NIL, finalizer, (void*)NULL));
  nelua_assert_line_35((ptr != ((pool_Chunk_8_ptr)NULL)), ((nlstring){(uint8_t*)"out of memory", 13}));
  return ptr;
}
void nelua_assert_line_36(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/nix/store/fjg7d071zkmnh2jk44hjr291x4b4794z-nelua-0-unstable-2024-04-20/lib/nelua/lib/allocators/gc.nelua\033[1m:779:16: \033[31m\033[1mruntime error: \033[0m\033[1m", 150, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    assert(ptr ~= nilptr, 'out of memory')\n               \033[1m\033[32m^\033[0m\033[35m~~~~~~~~\033[0m\n", 95, true);
    nelua_abort();
  }
}
pool_Chunk_9_ptr nelua_GCAllocator_new_12(nelua_GCAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags) {
  nelua_GCFinalizerCallback finalizer = (nelua_GCFinalizerCallback)NULL;
  pool_Chunk_9_ptr ptr;
  ptr = ((pool_Chunk_9_ptr)nelua_GCAllocator_alloc0_1((&nelua_gc_allocator), 264U, NELUA_NIL, finalizer, (void*)NULL));
  nelua_assert_line_36((ptr != ((pool_Chunk_9_ptr)NULL)), ((nlstring){(uint8_t*)"out of memory", 13}));
  return ptr;
}
void nelua_assert_line_37(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/nix/store/fjg7d071zkmnh2jk44hjr291x4b4794z-nelua-0-unstable-2024-04-20/lib/nelua/lib/allocators/gc.nelua\033[1m:779:16: \033[31m\033[1mruntime error: \033[0m\033[1m", 150, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    assert(ptr ~= nilptr, 'out of memory')\n               \033[1m\033[32m^\033[0m\033[35m~~~~~~~~\033[0m\n", 95, true);
    nelua_abort();
  }
}
pool_Chunk_10_ptr nelua_GCAllocator_new_13(nelua_GCAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags) {
  nelua_GCFinalizerCallback finalizer = (nelua_GCFinalizerCallback)NULL;
  pool_Chunk_10_ptr ptr;
  ptr = ((pool_Chunk_10_ptr)nelua_GCAllocator_alloc0_1((&nelua_gc_allocator), 264U, NELUA_NIL, finalizer, (void*)NULL));
  nelua_assert_line_37((ptr != ((pool_Chunk_10_ptr)NULL)), ((nlstring){(uint8_t*)"out of memory", 13}));
  return ptr;
}
void nelua_assert_line_38(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/nix/store/fjg7d071zkmnh2jk44hjr291x4b4794z-nelua-0-unstable-2024-04-20/lib/nelua/lib/allocators/gc.nelua\033[1m:779:16: \033[31m\033[1mruntime error: \033[0m\033[1m", 150, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    assert(ptr ~= nilptr, 'out of memory')\n               \033[1m\033[32m^\033[0m\033[35m~~~~~~~~\033[0m\n", 95, true);
    nelua_abort();
  }
}
pool_Chunk_11_ptr nelua_GCAllocator_new_14(nelua_GCAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags) {
  nelua_GCFinalizerCallback finalizer = (nelua_GCFinalizerCallback)NULL;
  pool_Chunk_11_ptr ptr;
  ptr = ((pool_Chunk_11_ptr)nelua_GCAllocator_alloc0_1((&nelua_gc_allocator), 264U, NELUA_NIL, finalizer, (void*)NULL));
  nelua_assert_line_38((ptr != ((pool_Chunk_11_ptr)NULL)), ((nlstring){(uint8_t*)"out of memory", 13}));
  return ptr;
}
void nelua_assert_line_39(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/nix/store/fjg7d071zkmnh2jk44hjr291x4b4794z-nelua-0-unstable-2024-04-20/lib/nelua/lib/allocators/gc.nelua\033[1m:779:16: \033[31m\033[1mruntime error: \033[0m\033[1m", 150, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    assert(ptr ~= nilptr, 'out of memory')\n               \033[1m\033[32m^\033[0m\033[35m~~~~~~~~\033[0m\n", 95, true);
    nelua_abort();
  }
}
pool_Chunk_12_ptr nelua_GCAllocator_new_15(nelua_GCAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags) {
  nelua_GCFinalizerCallback finalizer = (nelua_GCFinalizerCallback)NULL;
  pool_Chunk_12_ptr ptr;
  ptr = ((pool_Chunk_12_ptr)nelua_GCAllocator_alloc0_1((&nelua_gc_allocator), 264U, NELUA_NIL, finalizer, (void*)NULL));
  nelua_assert_line_39((ptr != ((pool_Chunk_12_ptr)NULL)), ((nlstring){(uint8_t*)"out of memory", 13}));
  return ptr;
}
void nelua_assert_line_40(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/nix/store/fjg7d071zkmnh2jk44hjr291x4b4794z-nelua-0-unstable-2024-04-20/lib/nelua/lib/allocators/gc.nelua\033[1m:779:16: \033[31m\033[1mruntime error: \033[0m\033[1m", 150, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    assert(ptr ~= nilptr, 'out of memory')\n               \033[1m\033[32m^\033[0m\033[35m~~~~~~~~\033[0m\n", 95, true);
    nelua_abort();
  }
}
pool_Chunk_13_ptr nelua_GCAllocator_new_16(nelua_GCAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags) {
  nelua_GCFinalizerCallback finalizer = (nelua_GCFinalizerCallback)NULL;
  pool_Chunk_13_ptr ptr;
  ptr = ((pool_Chunk_13_ptr)nelua_GCAllocator_alloc0_1((&nelua_gc_allocator), 264U, NELUA_NIL, finalizer, (void*)NULL));
  nelua_assert_line_40((ptr != ((pool_Chunk_13_ptr)NULL)), ((nlstring){(uint8_t*)"out of memory", 13}));
  return ptr;
}
void nelua_assert_line_41(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/nix/store/fjg7d071zkmnh2jk44hjr291x4b4794z-nelua-0-unstable-2024-04-20/lib/nelua/lib/allocators/gc.nelua\033[1m:779:16: \033[31m\033[1mruntime error: \033[0m\033[1m", 150, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    assert(ptr ~= nilptr, 'out of memory')\n               \033[1m\033[32m^\033[0m\033[35m~~~~~~~~\033[0m\n", 95, true);
    nelua_abort();
  }
}
pool_Chunk_14_ptr nelua_GCAllocator_new_17(nelua_GCAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags) {
  nelua_GCFinalizerCallback finalizer = (nelua_GCFinalizerCallback)NULL;
  pool_Chunk_14_ptr ptr;
  ptr = ((pool_Chunk_14_ptr)nelua_GCAllocator_alloc0_1((&nelua_gc_allocator), 264U, NELUA_NIL, finalizer, (void*)NULL));
  nelua_assert_line_41((ptr != ((pool_Chunk_14_ptr)NULL)), ((nlstring){(uint8_t*)"out of memory", 13}));
  return ptr;
}
void nelua_assert_line_42(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/nix/store/fjg7d071zkmnh2jk44hjr291x4b4794z-nelua-0-unstable-2024-04-20/lib/nelua/lib/allocators/gc.nelua\033[1m:779:16: \033[31m\033[1mruntime error: \033[0m\033[1m", 150, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    assert(ptr ~= nilptr, 'out of memory')\n               \033[1m\033[32m^\033[0m\033[35m~~~~~~~~\033[0m\n", 95, true);
    nelua_abort();
  }
}
pool_Chunk_15_ptr nelua_GCAllocator_new_18(nelua_GCAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags) {
  nelua_GCFinalizerCallback finalizer = (nelua_GCFinalizerCallback)NULL;
  pool_Chunk_15_ptr ptr;
  ptr = ((pool_Chunk_15_ptr)nelua_GCAllocator_alloc0_1((&nelua_gc_allocator), 392U, NELUA_NIL, finalizer, (void*)NULL));
  nelua_assert_line_42((ptr != ((pool_Chunk_15_ptr)NULL)), ((nlstring){(uint8_t*)"out of memory", 13}));
  return ptr;
}
void nelua_assert_line_43(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/nix/store/fjg7d071zkmnh2jk44hjr291x4b4794z-nelua-0-unstable-2024-04-20/lib/nelua/lib/allocators/gc.nelua\033[1m:779:16: \033[31m\033[1mruntime error: \033[0m\033[1m", 150, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    assert(ptr ~= nilptr, 'out of memory')\n               \033[1m\033[32m^\033[0m\033[35m~~~~~~~~\033[0m\n", 95, true);
    nelua_abort();
  }
}
pool_Chunk_16_ptr nelua_GCAllocator_new_19(nelua_GCAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags) {
  nelua_GCFinalizerCallback finalizer = (nelua_GCFinalizerCallback)NULL;
  pool_Chunk_16_ptr ptr;
  ptr = ((pool_Chunk_16_ptr)nelua_GCAllocator_alloc0_1((&nelua_gc_allocator), 264U, NELUA_NIL, finalizer, (void*)NULL));
  nelua_assert_line_43((ptr != ((pool_Chunk_16_ptr)NULL)), ((nlstring){(uint8_t*)"out of memory", 13}));
  return ptr;
}
void nelua_assert_line_44(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/nix/store/fjg7d071zkmnh2jk44hjr291x4b4794z-nelua-0-unstable-2024-04-20/lib/nelua/lib/allocators/gc.nelua\033[1m:779:16: \033[31m\033[1mruntime error: \033[0m\033[1m", 150, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    assert(ptr ~= nilptr, 'out of memory')\n               \033[1m\033[32m^\033[0m\033[35m~~~~~~~~\033[0m\n", 95, true);
    nelua_abort();
  }
}
main_Player_ptr nelua_GCAllocator_new_20(nelua_GCAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags) {
  nelua_GCFinalizerCallback finalizer = (nelua_GCFinalizerCallback)NULL;
  main_Player_ptr ptr;
  ptr = ((main_Player_ptr)nelua_GCAllocator_alloc0_1((&nelua_gc_allocator), 24U, NELUA_NIL, finalizer, (void*)NULL));
  nelua_assert_line_44((ptr != ((main_Player_ptr)NULL)), ((nlstring){(uint8_t*)"out of memory", 13}));
  return ptr;
}
void nelua_assert_line_45(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/nix/store/fjg7d071zkmnh2jk44hjr291x4b4794z-nelua-0-unstable-2024-04-20/lib/nelua/lib/allocators/gc.nelua\033[1m:779:16: \033[31m\033[1mruntime error: \033[0m\033[1m", 150, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    assert(ptr ~= nilptr, 'out of memory')\n               \033[1m\033[32m^\033[0m\033[35m~~~~~~~~\033[0m\n", 95, true);
    nelua_abort();
  }
}
main_Animal_ptr nelua_GCAllocator_new_21(nelua_GCAllocator_ptr self, nlniltype what, nlniltype size, nlniltype flags) {
  nelua_GCFinalizerCallback finalizer = (nelua_GCFinalizerCallback)NULL;
  main_Animal_ptr ptr;
  ptr = ((main_Animal_ptr)nelua_GCAllocator_alloc0_1((&nelua_gc_allocator), 32U, NELUA_NIL, finalizer, (void*)NULL));
  nelua_assert_line_45((ptr != ((main_Animal_ptr)NULL)), ((nlstring){(uint8_t*)"out of memory", 13}));
  return ptr;
}
void* nelua_GCAllocator_xalloc_1(nelua_GCAllocator_ptr self, uintptr_t size, nlniltype flags) {
  void* p = nelua_GCAllocator_alloc_1(self, size, NELUA_NIL, NELUA_NIL, NELUA_NIL);
  if(NELUA_UNLIKELY(((p == (void*)NULL) && (size > 0)))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return p;
}
void* nelua_GCAllocator_realloc0(nelua_GCAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize) {
  p = nelua_GCAllocator_realloc(self, p, newsize, oldsize);
  if(NELUA_LIKELY(((newsize > oldsize) && (p != (void*)NULL)))) {
    nelua_memory_zero((void*)(&((nluint8_arr0_ptr)p)[oldsize]), (newsize - oldsize));
  }
  return p;
}
void nelua_GCAllocator_spandealloc_1(nelua_GCAllocator_ptr self, nelua_span_uint8_ s) {
  if(NELUA_UNLIKELY((s.size == 0))) {
    return;
  }
  nelua_GCAllocator_dealloc(self, (void*)s.data);
}
nelua_span_uint8_ nelua_GCAllocator_spanrealloc_1(nelua_GCAllocator_ptr self, nelua_span_uint8_ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GCAllocator_spanalloc_2(self, NELUA_NIL, size, NELUA_NIL, NELUA_NIL, NELUA_NIL);
    return s;
  }
  nluint8_arr0_ptr p = ((nluint8_arr0_ptr)nelua_GCAllocator_realloc(self, (void*)s.data, (size * 1), (s.size * 1)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((nluint8_arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_uint8_ nelua_GCAllocator_xspanrealloc_1(nelua_GCAllocator_ptr self, nelua_span_uint8_ s, uintptr_t size) {
  s = nelua_GCAllocator_spanrealloc_1(self, s, size);
  if(NELUA_UNLIKELY((s.size != size))) {
    nelua_panic_string(((nlstring){(uint8_t*)"out of memory", 13}));
  }
  return s;
}
nelua_span_uint8_ nelua_GCAllocator_spanrealloc0_1(nelua_GCAllocator_ptr self, nelua_span_uint8_ s, uintptr_t size) {
  if(NELUA_UNLIKELY(((s.size == 0) && (size > 0)))) {
    s = nelua_GCAllocator_spanalloc0_1(self, NELUA_NIL, size, NELUA_NIL, NELUA_NIL, NELUA_NIL);
    return s;
  }
  nluint8_arr0_ptr p = ((nluint8_arr0_ptr)nelua_GCAllocator_realloc0(self, (void*)s.data, (size * 1), (s.size * 1)));
  if(NELUA_UNLIKELY(((size > 0) && (p == ((nluint8_arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
main_Player_ptr nelua_new_1(nlniltype what, nlniltype size, nlniltype flags) {
  return nelua_GCAllocator_new_20((&nelua_gc_allocator), NELUA_NIL, NELUA_NIL, NELUA_NIL);
}
main_Animal_ptr nelua_new_2(nlniltype what, nlniltype size, nlniltype flags) {
  return nelua_GCAllocator_new_21((&nelua_gc_allocator), NELUA_NIL, NELUA_NIL, NELUA_NIL);
}
void pool_PoolT_1_newChunk(pool_PoolT_1_ptr self) {
  pool_Chunk_1_ptr chunk = nelua_GCAllocator_new_4((&pool_allocator), NELUA_NIL, NELUA_NIL, NELUA_NIL);
  for(int64_t i = 0; i < 16; i += 1) {
    pool_Slot_1_ptr slot = (&chunk->slots[nelua_assert_bounds_nlint64(i, 16)]);
    slot->next_free_slot = ({
      pool_Slot_1_ptr _expr;
      if((i == 15)) {
        _expr = NULL;
        goto _doexprlabel_1;
      } else {
        _expr = (&chunk->slots[nelua_assert_bounds_nlint64((i + 1), 16)]);
        goto _doexprlabel_1;
      }
      _doexprlabel_1: _expr;
    });
  }
  chunk->next = self->current_chunk;
  self->current_chunk = chunk;
}
void pool_PoolT_1_init(pool_PoolT_1_ptr self) {
  pool_PoolT_1_newChunk(self);
  self->free_slot = (&self->current_chunk->slots[0]);
}
void pool_PoolT_2_newChunk(pool_PoolT_2_ptr self) {
  pool_Chunk_2_ptr chunk = nelua_GCAllocator_new_5((&pool_allocator), NELUA_NIL, NELUA_NIL, NELUA_NIL);
  for(int64_t i = 0; i < 16; i += 1) {
    pool_Slot_2_ptr slot = (&chunk->slots[nelua_assert_bounds_nlint64(i, 16)]);
    slot->next_free_slot = ({
      pool_Slot_2_ptr _expr;
      if((i == 15)) {
        _expr = NULL;
        goto _doexprlabel_1;
      } else {
        _expr = (&chunk->slots[nelua_assert_bounds_nlint64((i + 1), 16)]);
        goto _doexprlabel_1;
      }
      _doexprlabel_1: _expr;
    });
  }
  chunk->next = self->current_chunk;
  self->current_chunk = chunk;
}
void pool_PoolT_2_init(pool_PoolT_2_ptr self) {
  pool_PoolT_2_newChunk(self);
  self->free_slot = (&self->current_chunk->slots[0]);
}
void pool_PoolT_3_newChunk(pool_PoolT_3_ptr self) {
  pool_Chunk_3_ptr chunk = nelua_GCAllocator_new_6((&pool_allocator), NELUA_NIL, NELUA_NIL, NELUA_NIL);
  for(int64_t i = 0; i < 16; i += 1) {
    pool_Slot_3_ptr slot = (&chunk->slots[nelua_assert_bounds_nlint64(i, 16)]);
    slot->next_free_slot = ({
      pool_Slot_3_ptr _expr;
      if((i == 15)) {
        _expr = NULL;
        goto _doexprlabel_1;
      } else {
        _expr = (&chunk->slots[nelua_assert_bounds_nlint64((i + 1), 16)]);
        goto _doexprlabel_1;
      }
      _doexprlabel_1: _expr;
    });
  }
  chunk->next = self->current_chunk;
  self->current_chunk = chunk;
}
void pool_PoolT_3_init(pool_PoolT_3_ptr self) {
  pool_PoolT_3_newChunk(self);
  self->free_slot = (&self->current_chunk->slots[0]);
}
event_Subscription_1_ptr pool_PoolT_3_add(pool_PoolT_3_ptr self) {
  pool_Slot_3_ptr slot = self->free_slot;
  if((!(slot->next_free_slot != NULL))) {
    pool_PoolT_3_newChunk(self);
    slot->next_free_slot = (&self->current_chunk->slots[0]);
  }
  self->free_slot = slot->next_free_slot;
  return (&slot->element);
}
void pool_PoolT_4_newChunk(pool_PoolT_4_ptr self) {
  pool_Chunk_4_ptr chunk = nelua_GCAllocator_new_7((&pool_allocator), NELUA_NIL, NELUA_NIL, NELUA_NIL);
  for(int64_t i = 0; i < 16; i += 1) {
    pool_Slot_4_ptr slot = (&chunk->slots[nelua_assert_bounds_nlint64(i, 16)]);
    slot->next_free_slot = ({
      pool_Slot_4_ptr _expr;
      if((i == 15)) {
        _expr = NULL;
        goto _doexprlabel_1;
      } else {
        _expr = (&chunk->slots[nelua_assert_bounds_nlint64((i + 1), 16)]);
        goto _doexprlabel_1;
      }
      _doexprlabel_1: _expr;
    });
  }
  chunk->next = self->current_chunk;
  self->current_chunk = chunk;
}
void pool_PoolT_4_init(pool_PoolT_4_ptr self) {
  pool_PoolT_4_newChunk(self);
  self->free_slot = (&self->current_chunk->slots[0]);
}
list_Node_2_ptr pool_PoolT_4_add(pool_PoolT_4_ptr self) {
  pool_Slot_4_ptr slot = self->free_slot;
  if((!(slot->next_free_slot != NULL))) {
    pool_PoolT_4_newChunk(self);
    slot->next_free_slot = (&self->current_chunk->slots[0]);
  }
  self->free_slot = slot->next_free_slot;
  return (&slot->element);
}
void pool_PoolT_5_newChunk(pool_PoolT_5_ptr self) {
  pool_Chunk_5_ptr chunk = nelua_GCAllocator_new_8((&pool_allocator), NELUA_NIL, NELUA_NIL, NELUA_NIL);
  for(int64_t i = 0; i < 16; i += 1) {
    pool_Slot_5_ptr slot = (&chunk->slots[nelua_assert_bounds_nlint64(i, 16)]);
    slot->next_free_slot = ({
      pool_Slot_5_ptr _expr;
      if((i == 15)) {
        _expr = NULL;
        goto _doexprlabel_1;
      } else {
        _expr = (&chunk->slots[nelua_assert_bounds_nlint64((i + 1), 16)]);
        goto _doexprlabel_1;
      }
      _doexprlabel_1: _expr;
    });
  }
  chunk->next = self->current_chunk;
  self->current_chunk = chunk;
}
void pool_PoolT_5_init(pool_PoolT_5_ptr self) {
  pool_PoolT_5_newChunk(self);
  self->free_slot = (&self->current_chunk->slots[0]);
}
event_Subscription_2_ptr pool_PoolT_5_add(pool_PoolT_5_ptr self) {
  pool_Slot_5_ptr slot = self->free_slot;
  if((!(slot->next_free_slot != NULL))) {
    pool_PoolT_5_newChunk(self);
    slot->next_free_slot = (&self->current_chunk->slots[0]);
  }
  self->free_slot = slot->next_free_slot;
  return (&slot->element);
}
void pool_PoolT_6_newChunk(pool_PoolT_6_ptr self) {
  pool_Chunk_6_ptr chunk = nelua_GCAllocator_new_9((&pool_allocator), NELUA_NIL, NELUA_NIL, NELUA_NIL);
  for(int64_t i = 0; i < 16; i += 1) {
    pool_Slot_6_ptr slot = (&chunk->slots[nelua_assert_bounds_nlint64(i, 16)]);
    slot->next_free_slot = ({
      pool_Slot_6_ptr _expr;
      if((i == 15)) {
        _expr = NULL;
        goto _doexprlabel_1;
      } else {
        _expr = (&chunk->slots[nelua_assert_bounds_nlint64((i + 1), 16)]);
        goto _doexprlabel_1;
      }
      _doexprlabel_1: _expr;
    });
  }
  chunk->next = self->current_chunk;
  self->current_chunk = chunk;
}
void pool_PoolT_6_init(pool_PoolT_6_ptr self) {
  pool_PoolT_6_newChunk(self);
  self->free_slot = (&self->current_chunk->slots[0]);
}
list_Node_3_ptr pool_PoolT_6_add(pool_PoolT_6_ptr self) {
  pool_Slot_6_ptr slot = self->free_slot;
  if((!(slot->next_free_slot != NULL))) {
    pool_PoolT_6_newChunk(self);
    slot->next_free_slot = (&self->current_chunk->slots[0]);
  }
  self->free_slot = slot->next_free_slot;
  return (&slot->element);
}
void pool_PoolT_7_newChunk(pool_PoolT_7_ptr self) {
  pool_Chunk_7_ptr chunk = nelua_GCAllocator_new_10((&pool_allocator), NELUA_NIL, NELUA_NIL, NELUA_NIL);
  for(int64_t i = 0; i < 16; i += 1) {
    pool_Slot_7_ptr slot = (&chunk->slots[nelua_assert_bounds_nlint64(i, 16)]);
    slot->next_free_slot = ({
      pool_Slot_7_ptr _expr;
      if((i == 15)) {
        _expr = NULL;
        goto _doexprlabel_1;
      } else {
        _expr = (&chunk->slots[nelua_assert_bounds_nlint64((i + 1), 16)]);
        goto _doexprlabel_1;
      }
      _doexprlabel_1: _expr;
    });
  }
  chunk->next = self->current_chunk;
  self->current_chunk = chunk;
}
void pool_PoolT_7_init(pool_PoolT_7_ptr self) {
  pool_PoolT_7_newChunk(self);
  self->free_slot = (&self->current_chunk->slots[0]);
}
event_Subscription_3_ptr pool_PoolT_7_add(pool_PoolT_7_ptr self) {
  pool_Slot_7_ptr slot = self->free_slot;
  if((!(slot->next_free_slot != NULL))) {
    pool_PoolT_7_newChunk(self);
    slot->next_free_slot = (&self->current_chunk->slots[0]);
  }
  self->free_slot = slot->next_free_slot;
  return (&slot->element);
}
void pool_PoolT_8_newChunk(pool_PoolT_8_ptr self) {
  pool_Chunk_8_ptr chunk = nelua_GCAllocator_new_11((&pool_allocator), NELUA_NIL, NELUA_NIL, NELUA_NIL);
  for(int64_t i = 0; i < 16; i += 1) {
    pool_Slot_8_ptr slot = (&chunk->slots[nelua_assert_bounds_nlint64(i, 16)]);
    slot->next_free_slot = ({
      pool_Slot_8_ptr _expr;
      if((i == 15)) {
        _expr = NULL;
        goto _doexprlabel_1;
      } else {
        _expr = (&chunk->slots[nelua_assert_bounds_nlint64((i + 1), 16)]);
        goto _doexprlabel_1;
      }
      _doexprlabel_1: _expr;
    });
  }
  chunk->next = self->current_chunk;
  self->current_chunk = chunk;
}
void pool_PoolT_8_init(pool_PoolT_8_ptr self) {
  pool_PoolT_8_newChunk(self);
  self->free_slot = (&self->current_chunk->slots[0]);
}
list_Node_4_ptr pool_PoolT_8_add(pool_PoolT_8_ptr self) {
  pool_Slot_8_ptr slot = self->free_slot;
  if((!(slot->next_free_slot != NULL))) {
    pool_PoolT_8_newChunk(self);
    slot->next_free_slot = (&self->current_chunk->slots[0]);
  }
  self->free_slot = slot->next_free_slot;
  return (&slot->element);
}
void pool_PoolT_9_newChunk(pool_PoolT_9_ptr self) {
  pool_Chunk_9_ptr chunk = nelua_GCAllocator_new_12((&pool_allocator), NELUA_NIL, NELUA_NIL, NELUA_NIL);
  for(int64_t i = 0; i < 16; i += 1) {
    pool_Slot_9_ptr slot = (&chunk->slots[nelua_assert_bounds_nlint64(i, 16)]);
    slot->next_free_slot = ({
      pool_Slot_9_ptr _expr;
      if((i == 15)) {
        _expr = NULL;
        goto _doexprlabel_1;
      } else {
        _expr = (&chunk->slots[nelua_assert_bounds_nlint64((i + 1), 16)]);
        goto _doexprlabel_1;
      }
      _doexprlabel_1: _expr;
    });
  }
  chunk->next = self->current_chunk;
  self->current_chunk = chunk;
}
void pool_PoolT_9_init(pool_PoolT_9_ptr self) {
  pool_PoolT_9_newChunk(self);
  self->free_slot = (&self->current_chunk->slots[0]);
}
event_Subscription_4_ptr pool_PoolT_9_add(pool_PoolT_9_ptr self) {
  pool_Slot_9_ptr slot = self->free_slot;
  if((!(slot->next_free_slot != NULL))) {
    pool_PoolT_9_newChunk(self);
    slot->next_free_slot = (&self->current_chunk->slots[0]);
  }
  self->free_slot = slot->next_free_slot;
  return (&slot->element);
}
void pool_PoolT_10_newChunk(pool_PoolT_10_ptr self) {
  pool_Chunk_10_ptr chunk = nelua_GCAllocator_new_13((&pool_allocator), NELUA_NIL, NELUA_NIL, NELUA_NIL);
  for(int64_t i = 0; i < 16; i += 1) {
    pool_Slot_10_ptr slot = (&chunk->slots[nelua_assert_bounds_nlint64(i, 16)]);
    slot->next_free_slot = ({
      pool_Slot_10_ptr _expr;
      if((i == 15)) {
        _expr = NULL;
        goto _doexprlabel_1;
      } else {
        _expr = (&chunk->slots[nelua_assert_bounds_nlint64((i + 1), 16)]);
        goto _doexprlabel_1;
      }
      _doexprlabel_1: _expr;
    });
  }
  chunk->next = self->current_chunk;
  self->current_chunk = chunk;
}
void pool_PoolT_10_init(pool_PoolT_10_ptr self) {
  pool_PoolT_10_newChunk(self);
  self->free_slot = (&self->current_chunk->slots[0]);
}
list_Node_5_ptr pool_PoolT_10_add(pool_PoolT_10_ptr self) {
  pool_Slot_10_ptr slot = self->free_slot;
  if((!(slot->next_free_slot != NULL))) {
    pool_PoolT_10_newChunk(self);
    slot->next_free_slot = (&self->current_chunk->slots[0]);
  }
  self->free_slot = slot->next_free_slot;
  return (&slot->element);
}
void pool_PoolT_11_newChunk(pool_PoolT_11_ptr self) {
  pool_Chunk_11_ptr chunk = nelua_GCAllocator_new_14((&pool_allocator), NELUA_NIL, NELUA_NIL, NELUA_NIL);
  for(int64_t i = 0; i < 16; i += 1) {
    pool_Slot_11_ptr slot = (&chunk->slots[nelua_assert_bounds_nlint64(i, 16)]);
    slot->next_free_slot = ({
      pool_Slot_11_ptr _expr;
      if((i == 15)) {
        _expr = NULL;
        goto _doexprlabel_1;
      } else {
        _expr = (&chunk->slots[nelua_assert_bounds_nlint64((i + 1), 16)]);
        goto _doexprlabel_1;
      }
      _doexprlabel_1: _expr;
    });
  }
  chunk->next = self->current_chunk;
  self->current_chunk = chunk;
}
void pool_PoolT_11_init(pool_PoolT_11_ptr self) {
  pool_PoolT_11_newChunk(self);
  self->free_slot = (&self->current_chunk->slots[0]);
}
event_Subscription_5_ptr pool_PoolT_11_add(pool_PoolT_11_ptr self) {
  pool_Slot_11_ptr slot = self->free_slot;
  if((!(slot->next_free_slot != NULL))) {
    pool_PoolT_11_newChunk(self);
    slot->next_free_slot = (&self->current_chunk->slots[0]);
  }
  self->free_slot = slot->next_free_slot;
  return (&slot->element);
}
void pool_PoolT_12_newChunk(pool_PoolT_12_ptr self) {
  pool_Chunk_12_ptr chunk = nelua_GCAllocator_new_15((&pool_allocator), NELUA_NIL, NELUA_NIL, NELUA_NIL);
  for(int64_t i = 0; i < 16; i += 1) {
    pool_Slot_12_ptr slot = (&chunk->slots[nelua_assert_bounds_nlint64(i, 16)]);
    slot->next_free_slot = ({
      pool_Slot_12_ptr _expr;
      if((i == 15)) {
        _expr = NULL;
        goto _doexprlabel_1;
      } else {
        _expr = (&chunk->slots[nelua_assert_bounds_nlint64((i + 1), 16)]);
        goto _doexprlabel_1;
      }
      _doexprlabel_1: _expr;
    });
  }
  chunk->next = self->current_chunk;
  self->current_chunk = chunk;
}
void pool_PoolT_12_init(pool_PoolT_12_ptr self) {
  pool_PoolT_12_newChunk(self);
  self->free_slot = (&self->current_chunk->slots[0]);
}
list_Node_6_ptr pool_PoolT_12_add(pool_PoolT_12_ptr self) {
  pool_Slot_12_ptr slot = self->free_slot;
  if((!(slot->next_free_slot != NULL))) {
    pool_PoolT_12_newChunk(self);
    slot->next_free_slot = (&self->current_chunk->slots[0]);
  }
  self->free_slot = slot->next_free_slot;
  return (&slot->element);
}
void pool_PoolT_13_newChunk(pool_PoolT_13_ptr self) {
  pool_Chunk_13_ptr chunk = nelua_GCAllocator_new_16((&pool_allocator), NELUA_NIL, NELUA_NIL, NELUA_NIL);
  for(int64_t i = 0; i < 16; i += 1) {
    pool_Slot_13_ptr slot = (&chunk->slots[nelua_assert_bounds_nlint64(i, 16)]);
    slot->next_free_slot = ({
      pool_Slot_13_ptr _expr;
      if((i == 15)) {
        _expr = NULL;
        goto _doexprlabel_1;
      } else {
        _expr = (&chunk->slots[nelua_assert_bounds_nlint64((i + 1), 16)]);
        goto _doexprlabel_1;
      }
      _doexprlabel_1: _expr;
    });
  }
  chunk->next = self->current_chunk;
  self->current_chunk = chunk;
}
void pool_PoolT_13_init(pool_PoolT_13_ptr self) {
  pool_PoolT_13_newChunk(self);
  self->free_slot = (&self->current_chunk->slots[0]);
}
event_Subscription_6_ptr pool_PoolT_13_add(pool_PoolT_13_ptr self) {
  pool_Slot_13_ptr slot = self->free_slot;
  if((!(slot->next_free_slot != NULL))) {
    pool_PoolT_13_newChunk(self);
    slot->next_free_slot = (&self->current_chunk->slots[0]);
  }
  self->free_slot = slot->next_free_slot;
  return (&slot->element);
}
void pool_PoolT_14_newChunk(pool_PoolT_14_ptr self) {
  pool_Chunk_14_ptr chunk = nelua_GCAllocator_new_17((&pool_allocator), NELUA_NIL, NELUA_NIL, NELUA_NIL);
  for(int64_t i = 0; i < 16; i += 1) {
    pool_Slot_14_ptr slot = (&chunk->slots[nelua_assert_bounds_nlint64(i, 16)]);
    slot->next_free_slot = ({
      pool_Slot_14_ptr _expr;
      if((i == 15)) {
        _expr = NULL;
        goto _doexprlabel_1;
      } else {
        _expr = (&chunk->slots[nelua_assert_bounds_nlint64((i + 1), 16)]);
        goto _doexprlabel_1;
      }
      _doexprlabel_1: _expr;
    });
  }
  chunk->next = self->current_chunk;
  self->current_chunk = chunk;
}
void pool_PoolT_14_init(pool_PoolT_14_ptr self) {
  pool_PoolT_14_newChunk(self);
  self->free_slot = (&self->current_chunk->slots[0]);
}
list_Node_7_ptr pool_PoolT_14_add(pool_PoolT_14_ptr self) {
  pool_Slot_14_ptr slot = self->free_slot;
  if((!(slot->next_free_slot != NULL))) {
    pool_PoolT_14_newChunk(self);
    slot->next_free_slot = (&self->current_chunk->slots[0]);
  }
  self->free_slot = slot->next_free_slot;
  return (&slot->element);
}
void pool_PoolT_15_newChunk(pool_PoolT_15_ptr self) {
  pool_Chunk_15_ptr chunk = nelua_GCAllocator_new_18((&pool_allocator), NELUA_NIL, NELUA_NIL, NELUA_NIL);
  for(int64_t i = 0; i < 16; i += 1) {
    pool_Slot_15_ptr slot = (&chunk->slots[nelua_assert_bounds_nlint64(i, 16)]);
    slot->next_free_slot = ({
      pool_Slot_15_ptr _expr;
      if((i == 15)) {
        _expr = NULL;
        goto _doexprlabel_1;
      } else {
        _expr = (&chunk->slots[nelua_assert_bounds_nlint64((i + 1), 16)]);
        goto _doexprlabel_1;
      }
      _doexprlabel_1: _expr;
    });
  }
  chunk->next = self->current_chunk;
  self->current_chunk = chunk;
}
void pool_PoolT_15_init(pool_PoolT_15_ptr self) {
  pool_PoolT_15_newChunk(self);
  self->free_slot = (&self->current_chunk->slots[0]);
}
list_Node_8_ptr pool_PoolT_15_add(pool_PoolT_15_ptr self) {
  pool_Slot_15_ptr slot = self->free_slot;
  if((!(slot->next_free_slot != NULL))) {
    pool_PoolT_15_newChunk(self);
    slot->next_free_slot = (&self->current_chunk->slots[0]);
  }
  self->free_slot = slot->next_free_slot;
  return (&slot->element);
}
void pool_PoolT_15_remove(pool_PoolT_15_ptr self, list_Node_8_ptr x) {
  pool_Slot_15_ptr slot = ((pool_Slot_15_ptr)x);
  slot->next_free_slot = self->free_slot;
  self->free_slot = slot;
}
void pool_PoolT_16_newChunk(pool_PoolT_16_ptr self) {
  pool_Chunk_16_ptr chunk = nelua_GCAllocator_new_19((&pool_allocator), NELUA_NIL, NELUA_NIL, NELUA_NIL);
  for(int64_t i = 0; i < 16; i += 1) {
    pool_Slot_16_ptr slot = (&chunk->slots[nelua_assert_bounds_nlint64(i, 16)]);
    slot->next_free_slot = ({
      pool_Slot_16_ptr _expr;
      if((i == 15)) {
        _expr = NULL;
        goto _doexprlabel_1;
      } else {
        _expr = (&chunk->slots[nelua_assert_bounds_nlint64((i + 1), 16)]);
        goto _doexprlabel_1;
      }
      _doexprlabel_1: _expr;
    });
  }
  chunk->next = self->current_chunk;
  self->current_chunk = chunk;
}
void pool_PoolT_16_init(pool_PoolT_16_ptr self) {
  pool_PoolT_16_newChunk(self);
  self->free_slot = (&self->current_chunk->slots[0]);
}
nltype nelua_require_pool(nlniltype modname) {
  pool_allocator = nelua_gc_allocator;
  return NELUA_NIL;
}
nltype nelua_require_pool_cached(nlniltype modname) {
  static bool loaded = false;
  static nltype cache;
  if(!loaded) {
    cache = nelua_require_pool(NELUA_NIL);
    loaded = true;
  }
  return cache;
}
void list_SListT_init(list_SListT_ptr self) {
  pool_PoolT_2_init((&self->pool));
  self->head = ((list_Node_1_ptr)NULL);
}
void list_SListT_1_init(list_SListT_1_ptr self) {
  pool_PoolT_4_init((&self->pool));
  self->head = ((list_Node_2_ptr)NULL);
}
list_Node_2_ptr list_SListT_1_push(list_SListT_1_ptr self, event_Subscription_1_ptr x) {
  list_Node_2_ptr n = pool_PoolT_4_add((&self->pool));
  n->next = self->head;
  n->data = x;
  self->head = n;
  return n;
}
void list_DList_2_init(list_DList_2_ptr self) {
  pool_PoolT_15_init((&self->pool));
  self->head = ((list_Node_8_ptr)NULL);
  self->tail = ((list_Node_8_ptr)NULL);
}
list_Node_8_ptr list_DList_2_insertBefore(list_DList_2_ptr self, list_Node_8_ptr x, main_Object_ptr v) {
  list_Node_8_ptr n = pool_PoolT_15_add((&self->pool));
  n->next = x;
  if((x->prev != NULL)) {
    x->prev->next = n;
    n->prev = x->prev;
  } else {
    self->head = n;
  }
  x->prev = n;
  n->data = v;
  return n;
}
list_Node_8_ptr list_DList_2_pushHead(list_DList_2_ptr self, main_Object_ptr x) {
  if((self->head != NULL)) {
    return list_DList_2_insertBefore(self, self->head, x);
  }
  self->head = pool_PoolT_15_add((&self->pool));
  self->tail = self->head;
  self->head->data = x;
  return self->head;
}
void list_DList_2_unlink(list_DList_2_ptr self, list_Node_8_ptr x) {
  if((x->prev != NULL)) {
    x->prev->next = x->next;
  } else {
    self->head = x->next;
  }
  if((x->next != NULL)) {
    x->next->prev = x->prev;
  } else {
    self->tail = x->prev;
  }
}
void list_DList_2_remove(list_DList_2_ptr self, list_Node_8_ptr n) {
  list_DList_2_unlink(self, n);
  pool_PoolT_15_remove((&self->pool), n);
}
bool list_DList_2_isEmpty(list_DList_2_ptr self) {
  return (!(self->head != NULL));
}
nlmulret_nlboolean_list_Node_2_ptr_event_Subscription_1_ptr list_SListT_1___next(list_SListT_1_ptr self, list_Node_2_ptr n) {
  list_Node_2_ptr nn = ({
    list_Node_2_ptr _expr;
    if((!(n != NULL))) {
      _expr = self->head;
      goto _doexprlabel_1;
    } else {
      _expr = n->next;
      goto _doexprlabel_1;
    }
    _doexprlabel_1: _expr;
  });
  if((!(nn != NULL))) {
    return (nlmulret_nlboolean_list_Node_2_ptr_event_Subscription_1_ptr){false, ((list_Node_2_ptr)NULL), ((event_Subscription_1_ptr)NULL)};
  }
  return (nlmulret_nlboolean_list_Node_2_ptr_event_Subscription_1_ptr){true, nn, nn->data};
}
nlmulret_function_3pW14qWtCTEhgcCu8_list_SListT_1_ptr_nlnilptr list_SListT_1_each(list_SListT_1_ptr self) {
  return (nlmulret_function_3pW14qWtCTEhgcCu8_list_SListT_1_ptr_nlnilptr){list_SListT_1___next, self, NULL};
}
void list_SListT_2_init(list_SListT_2_ptr self) {
  pool_PoolT_6_init((&self->pool));
  self->head = ((list_Node_3_ptr)NULL);
}
list_Node_3_ptr list_SListT_2_push(list_SListT_2_ptr self, event_Subscription_2_ptr x) {
  list_Node_3_ptr n = pool_PoolT_6_add((&self->pool));
  n->next = self->head;
  n->data = x;
  self->head = n;
  return n;
}
nlmulret_nlboolean_list_Node_3_ptr_event_Subscription_2_ptr list_SListT_2___next(list_SListT_2_ptr self, list_Node_3_ptr n) {
  list_Node_3_ptr nn = ({
    list_Node_3_ptr _expr;
    if((!(n != NULL))) {
      _expr = self->head;
      goto _doexprlabel_1;
    } else {
      _expr = n->next;
      goto _doexprlabel_1;
    }
    _doexprlabel_1: _expr;
  });
  if((!(nn != NULL))) {
    return (nlmulret_nlboolean_list_Node_3_ptr_event_Subscription_2_ptr){false, ((list_Node_3_ptr)NULL), ((event_Subscription_2_ptr)NULL)};
  }
  return (nlmulret_nlboolean_list_Node_3_ptr_event_Subscription_2_ptr){true, nn, nn->data};
}
nlmulret_function_4dNpuBYcNpbgam6wu_list_SListT_2_ptr_nlnilptr list_SListT_2_each(list_SListT_2_ptr self) {
  return (nlmulret_function_4dNpuBYcNpbgam6wu_list_SListT_2_ptr_nlnilptr){list_SListT_2___next, self, NULL};
}
void list_SListT_3_init(list_SListT_3_ptr self) {
  pool_PoolT_8_init((&self->pool));
  self->head = ((list_Node_4_ptr)NULL);
}
list_Node_4_ptr list_SListT_3_push(list_SListT_3_ptr self, event_Subscription_3_ptr x) {
  list_Node_4_ptr n = pool_PoolT_8_add((&self->pool));
  n->next = self->head;
  n->data = x;
  self->head = n;
  return n;
}
nlmulret_nlboolean_list_Node_4_ptr_event_Subscription_3_ptr list_SListT_3___next(list_SListT_3_ptr self, list_Node_4_ptr n) {
  list_Node_4_ptr nn = ({
    list_Node_4_ptr _expr;
    if((!(n != NULL))) {
      _expr = self->head;
      goto _doexprlabel_1;
    } else {
      _expr = n->next;
      goto _doexprlabel_1;
    }
    _doexprlabel_1: _expr;
  });
  if((!(nn != NULL))) {
    return (nlmulret_nlboolean_list_Node_4_ptr_event_Subscription_3_ptr){false, ((list_Node_4_ptr)NULL), ((event_Subscription_3_ptr)NULL)};
  }
  return (nlmulret_nlboolean_list_Node_4_ptr_event_Subscription_3_ptr){true, nn, nn->data};
}
nlmulret_function_5xCyqTDq2WN4Nxi7_list_SListT_3_ptr_nlnilptr list_SListT_3_each(list_SListT_3_ptr self) {
  return (nlmulret_function_5xCyqTDq2WN4Nxi7_list_SListT_3_ptr_nlnilptr){list_SListT_3___next, self, NULL};
}
void list_SListT_4_init(list_SListT_4_ptr self) {
  pool_PoolT_10_init((&self->pool));
  self->head = ((list_Node_5_ptr)NULL);
}
list_Node_5_ptr list_SListT_4_push(list_SListT_4_ptr self, event_Subscription_4_ptr x) {
  list_Node_5_ptr n = pool_PoolT_10_add((&self->pool));
  n->next = self->head;
  n->data = x;
  self->head = n;
  return n;
}
nlmulret_nlboolean_list_Node_5_ptr_event_Subscription_4_ptr list_SListT_4___next(list_SListT_4_ptr self, list_Node_5_ptr n) {
  list_Node_5_ptr nn = ({
    list_Node_5_ptr _expr;
    if((!(n != NULL))) {
      _expr = self->head;
      goto _doexprlabel_1;
    } else {
      _expr = n->next;
      goto _doexprlabel_1;
    }
    _doexprlabel_1: _expr;
  });
  if((!(nn != NULL))) {
    return (nlmulret_nlboolean_list_Node_5_ptr_event_Subscription_4_ptr){false, ((list_Node_5_ptr)NULL), ((event_Subscription_4_ptr)NULL)};
  }
  return (nlmulret_nlboolean_list_Node_5_ptr_event_Subscription_4_ptr){true, nn, nn->data};
}
nlmulret_function_5bJJn15qp3DNA8yzW_list_SListT_4_ptr_nlnilptr list_SListT_4_each(list_SListT_4_ptr self) {
  return (nlmulret_function_5bJJn15qp3DNA8yzW_list_SListT_4_ptr_nlnilptr){list_SListT_4___next, self, NULL};
}
void list_SListT_5_init(list_SListT_5_ptr self) {
  pool_PoolT_12_init((&self->pool));
  self->head = ((list_Node_6_ptr)NULL);
}
list_Node_6_ptr list_SListT_5_push(list_SListT_5_ptr self, event_Subscription_5_ptr x) {
  list_Node_6_ptr n = pool_PoolT_12_add((&self->pool));
  n->next = self->head;
  n->data = x;
  self->head = n;
  return n;
}
void list_SListT_7_init(list_SListT_7_ptr self) {
  pool_PoolT_16_init((&self->pool));
  self->head = ((list_Node_9_ptr)NULL);
}
nlmulret_nlboolean_list_Node_6_ptr_event_Subscription_5_ptr list_SListT_5___next(list_SListT_5_ptr self, list_Node_6_ptr n) {
  list_Node_6_ptr nn = ({
    list_Node_6_ptr _expr;
    if((!(n != NULL))) {
      _expr = self->head;
      goto _doexprlabel_1;
    } else {
      _expr = n->next;
      goto _doexprlabel_1;
    }
    _doexprlabel_1: _expr;
  });
  if((!(nn != NULL))) {
    return (nlmulret_nlboolean_list_Node_6_ptr_event_Subscription_5_ptr){false, ((list_Node_6_ptr)NULL), ((event_Subscription_5_ptr)NULL)};
  }
  return (nlmulret_nlboolean_list_Node_6_ptr_event_Subscription_5_ptr){true, nn, nn->data};
}
nlmulret_function_2cfA3uKMBDnNKyrSf_list_SListT_5_ptr_nlnilptr list_SListT_5_each(list_SListT_5_ptr self) {
  return (nlmulret_function_2cfA3uKMBDnNKyrSf_list_SListT_5_ptr_nlnilptr){list_SListT_5___next, self, NULL};
}
void list_SListT_6_init(list_SListT_6_ptr self) {
  pool_PoolT_14_init((&self->pool));
  self->head = ((list_Node_7_ptr)NULL);
}
list_Node_7_ptr list_SListT_6_push(list_SListT_6_ptr self, event_Subscription_6_ptr x) {
  list_Node_7_ptr n = pool_PoolT_14_add((&self->pool));
  n->next = self->head;
  n->data = x;
  self->head = n;
  return n;
}
nlmulret_nlboolean_list_Node_7_ptr_event_Subscription_6_ptr list_SListT_6___next(list_SListT_6_ptr self, list_Node_7_ptr n) {
  list_Node_7_ptr nn = ({
    list_Node_7_ptr _expr;
    if((!(n != NULL))) {
      _expr = self->head;
      goto _doexprlabel_1;
    } else {
      _expr = n->next;
      goto _doexprlabel_1;
    }
    _doexprlabel_1: _expr;
  });
  if((!(nn != NULL))) {
    return (nlmulret_nlboolean_list_Node_7_ptr_event_Subscription_6_ptr){false, ((list_Node_7_ptr)NULL), ((event_Subscription_6_ptr)NULL)};
  }
  return (nlmulret_nlboolean_list_Node_7_ptr_event_Subscription_6_ptr){true, nn, nn->data};
}
nlmulret_function_4oongp4zBQ9NUBLmT_list_SListT_6_ptr_nlnilptr list_SListT_6_each(list_SListT_6_ptr self) {
  return (nlmulret_function_4oongp4zBQ9NUBLmT_list_SListT_6_ptr_nlnilptr){list_SListT_6___next, self, NULL};
}
void nelua_require_list(nlniltype modname) {
  nelua_require_pool_cached(NELUA_NIL);
}
void nelua_require_list_cached(nlniltype modname) {
  static bool loaded = false;
  if(!loaded) {
    nelua_require_list(NELUA_NIL);
    loaded = true;
  }
}
void event_SubListT_init(event_SubListT_ptr self) {
  pool_PoolT_1_init((&self->pool));
  list_SListT_init((&self->list));
}
void event_SubListT_1_init(event_SubListT_1_ptr self) {
  pool_PoolT_3_init((&self->pool));
  list_SListT_1_init((&self->list));
}
void event_SubListT_1_sub(event_SubListT_1_ptr self, void* subscriber, function_SPt3RC6SJoHTFZr8 handler) {
  event_Subscription_1_ptr sub = pool_PoolT_3_add((&self->pool));
  sub->subscriber = subscriber;
  sub->handler = handler;
  list_SListT_1_push((&self->list), sub);
}
void event_SubListT_1_emit(event_SubListT_1_ptr self, main_event_Event_AnimalDeath_ptr event) {
  {
    nlmulret_function_3pW14qWtCTEhgcCu8_list_SListT_1_ptr_nlnilptr _asgnret_1 = list_SListT_1_each((&self->list));
    function_3pW14qWtCTEhgcCu8 __fornext = _asgnret_1.r1;
    list_SListT_1_ptr __forstate = _asgnret_1.r2;
    list_Node_2_ptr __fornextit = ((list_Node_2_ptr)_asgnret_1.r3);
    while(true) {
      nlmulret_nlboolean_list_Node_2_ptr_event_Subscription_1_ptr _asgnret_2 = __fornext(__forstate, __fornextit);
      bool __forcont = _asgnret_2.r1;
      list_Node_2_ptr _ = _asgnret_2.r2;
      event_Subscription_1_ptr sub = _asgnret_2.r3;
      if((!__forcont)) {
        break;
      }
      __fornextit = _;
      {
        sub->handler(sub->subscriber, event);
      }
    }
  }
}
void event_SubListT_2_init(event_SubListT_2_ptr self) {
  pool_PoolT_5_init((&self->pool));
  list_SListT_2_init((&self->list));
}
void event_SubListT_2_sub(event_SubListT_2_ptr self, void* subscriber, function_5WmHNW6Q3YTCamKZg handler) {
  event_Subscription_2_ptr sub = pool_PoolT_5_add((&self->pool));
  sub->subscriber = subscriber;
  sub->handler = handler;
  list_SListT_2_push((&self->list), sub);
}
void event_SubListT_2_emit(event_SubListT_2_ptr self, main_event_Event_ObjectMoved_ptr event) {
  {
    nlmulret_function_4dNpuBYcNpbgam6wu_list_SListT_2_ptr_nlnilptr _asgnret_1 = list_SListT_2_each((&self->list));
    function_4dNpuBYcNpbgam6wu __fornext = _asgnret_1.r1;
    list_SListT_2_ptr __forstate = _asgnret_1.r2;
    list_Node_3_ptr __fornextit = ((list_Node_3_ptr)_asgnret_1.r3);
    while(true) {
      nlmulret_nlboolean_list_Node_3_ptr_event_Subscription_2_ptr _asgnret_2 = __fornext(__forstate, __fornextit);
      bool __forcont = _asgnret_2.r1;
      list_Node_3_ptr _ = _asgnret_2.r2;
      event_Subscription_2_ptr sub = _asgnret_2.r3;
      if((!__forcont)) {
        break;
      }
      __fornextit = _;
      {
        sub->handler(sub->subscriber, event);
      }
    }
  }
}
void event_SubListT_3_init(event_SubListT_3_ptr self) {
  pool_PoolT_7_init((&self->pool));
  list_SListT_3_init((&self->list));
}
void event_SubListT_3_sub(event_SubListT_3_ptr self, void* subscriber, function_2mNVtgWabEqXKo4yi handler) {
  event_Subscription_3_ptr sub = pool_PoolT_7_add((&self->pool));
  sub->subscriber = subscriber;
  sub->handler = handler;
  list_SListT_3_push((&self->list), sub);
}
void event_SubListT_3_emit(event_SubListT_3_ptr self, main_event_Event_PlayerAttack_ptr event) {
  {
    nlmulret_function_5xCyqTDq2WN4Nxi7_list_SListT_3_ptr_nlnilptr _asgnret_1 = list_SListT_3_each((&self->list));
    function_5xCyqTDq2WN4Nxi7 __fornext = _asgnret_1.r1;
    list_SListT_3_ptr __forstate = _asgnret_1.r2;
    list_Node_4_ptr __fornextit = ((list_Node_4_ptr)_asgnret_1.r3);
    while(true) {
      nlmulret_nlboolean_list_Node_4_ptr_event_Subscription_3_ptr _asgnret_2 = __fornext(__forstate, __fornextit);
      bool __forcont = _asgnret_2.r1;
      list_Node_4_ptr _ = _asgnret_2.r2;
      event_Subscription_3_ptr sub = _asgnret_2.r3;
      if((!__forcont)) {
        break;
      }
      __fornextit = _;
      {
        sub->handler(sub->subscriber, event);
      }
    }
  }
}
void event_SubListT_4_init(event_SubListT_4_ptr self) {
  pool_PoolT_9_init((&self->pool));
  list_SListT_4_init((&self->list));
}
void event_SubListT_4_sub(event_SubListT_4_ptr self, void* subscriber, function_3mHTWKBsxSdaL6ffP handler) {
  event_Subscription_4_ptr sub = pool_PoolT_9_add((&self->pool));
  sub->subscriber = subscriber;
  sub->handler = handler;
  list_SListT_4_push((&self->list), sub);
}
void event_SubListT_4_emit(event_SubListT_4_ptr self, main_event_Event_AnimalDamaged_ptr event) {
  {
    nlmulret_function_5bJJn15qp3DNA8yzW_list_SListT_4_ptr_nlnilptr _asgnret_1 = list_SListT_4_each((&self->list));
    function_5bJJn15qp3DNA8yzW __fornext = _asgnret_1.r1;
    list_SListT_4_ptr __forstate = _asgnret_1.r2;
    list_Node_5_ptr __fornextit = ((list_Node_5_ptr)_asgnret_1.r3);
    while(true) {
      nlmulret_nlboolean_list_Node_5_ptr_event_Subscription_4_ptr _asgnret_2 = __fornext(__forstate, __fornextit);
      bool __forcont = _asgnret_2.r1;
      list_Node_5_ptr _ = _asgnret_2.r2;
      event_Subscription_4_ptr sub = _asgnret_2.r3;
      if((!__forcont)) {
        break;
      }
      __fornextit = _;
      {
        sub->handler(sub->subscriber, event);
      }
    }
  }
}
void event_SubListT_5_init(event_SubListT_5_ptr self) {
  pool_PoolT_11_init((&self->pool));
  list_SListT_5_init((&self->list));
}
void event_SubListT_5_sub(event_SubListT_5_ptr self, void* subscriber, function_2X5NxKm2r8X1th4sE handler) {
  event_Subscription_5_ptr sub = pool_PoolT_11_add((&self->pool));
  sub->subscriber = subscriber;
  sub->handler = handler;
  list_SListT_5_push((&self->list), sub);
}
void event_SubListT_5_emit(event_SubListT_5_ptr self, main_event_Event_ObjectTryMove_ptr event) {
  {
    nlmulret_function_2cfA3uKMBDnNKyrSf_list_SListT_5_ptr_nlnilptr _asgnret_1 = list_SListT_5_each((&self->list));
    function_2cfA3uKMBDnNKyrSf __fornext = _asgnret_1.r1;
    list_SListT_5_ptr __forstate = _asgnret_1.r2;
    list_Node_6_ptr __fornextit = ((list_Node_6_ptr)_asgnret_1.r3);
    while(true) {
      nlmulret_nlboolean_list_Node_6_ptr_event_Subscription_5_ptr _asgnret_2 = __fornext(__forstate, __fornextit);
      bool __forcont = _asgnret_2.r1;
      list_Node_6_ptr _ = _asgnret_2.r2;
      event_Subscription_5_ptr sub = _asgnret_2.r3;
      if((!__forcont)) {
        break;
      }
      __fornextit = _;
      {
        sub->handler(sub->subscriber, event);
      }
    }
  }
}
void event_SubListT_6_init(event_SubListT_6_ptr self) {
  pool_PoolT_13_init((&self->pool));
  list_SListT_6_init((&self->list));
}
void event_SubListT_6_sub(event_SubListT_6_ptr self, void* subscriber, function_3UduMYNKBeNiJPjWr handler) {
  event_Subscription_6_ptr sub = pool_PoolT_13_add((&self->pool));
  sub->subscriber = subscriber;
  sub->handler = handler;
  list_SListT_6_push((&self->list), sub);
}
void event_SubListT_6_emit(event_SubListT_6_ptr self, main_event_Event_KeyPressed_ptr event) {
  {
    nlmulret_function_4oongp4zBQ9NUBLmT_list_SListT_6_ptr_nlnilptr _asgnret_1 = list_SListT_6_each((&self->list));
    function_4oongp4zBQ9NUBLmT __fornext = _asgnret_1.r1;
    list_SListT_6_ptr __forstate = _asgnret_1.r2;
    list_Node_7_ptr __fornextit = ((list_Node_7_ptr)_asgnret_1.r3);
    while(true) {
      nlmulret_nlboolean_list_Node_7_ptr_event_Subscription_6_ptr _asgnret_2 = __fornext(__forstate, __fornextit);
      bool __forcont = _asgnret_2.r1;
      list_Node_7_ptr _ = _asgnret_2.r2;
      event_Subscription_6_ptr sub = _asgnret_2.r3;
      if((!__forcont)) {
        break;
      }
      __fornextit = _;
      {
        sub->handler(sub->subscriber, event);
      }
    }
  }
}
nltype nelua_require_event(nlniltype modname) {
  nelua_require_list_cached(NELUA_NIL);
  nelua_require_pool_cached(NELUA_NIL);
  return NELUA_NIL;
}
uintptr_t nelua_assert_bounds_nlusize(uintptr_t index, uintptr_t len) {
  if(NELUA_UNLIKELY((uintptr_t)index >= len)) {
    nelua_panic_cstring("array index: position out of bounds");
  }
  return index;
}
nlstring nelua_strconv_1_int2str_2(nluint8_arr48_ptr buf, intptr_t x, nlniltype base) {
  uintptr_t pos = 47U;
  buf->v[nelua_assert_bounds_nlusize(pos, 48)] = 0U;
  pos = (pos - 1);
  bool neg = (x < 0);
  if((x == 0)) {
    buf->v[nelua_assert_bounds_nlusize(pos, 48)] = 48U;
    pos = (pos - 1);
  } else {
    while((x != 0)) {
      intptr_t quot = (x / 10);
      intptr_t rema = (x - (quot * 10));
      if((rema < 0)) {
        rema = (-rema);
      }
      x = quot;
      buf->v[nelua_assert_bounds_nlusize(pos, 48)] = (uint8_t)(rema + 48);
      pos = (pos - 1);
    }
  }
  if(neg) {
    buf->v[nelua_assert_bounds_nlusize(pos, 48)] = 45U;
    pos = (pos - 1);
  }
  return (nlstring){.data = ((nluint8_arr0_ptr)(&buf->v[nelua_assert_bounds_nlusize((pos + 1), 48)])), .size = ((48 - pos) - 2)};
}
void nelua_stringbuilderT_destroy(nelua_stringbuilderT_ptr self) {
  nelua_GCAllocator_spandealloc_1((&self->allocator), self->data);
  self->data = (nelua_span_uint8_){0};
  self->size = 0U;
}
bool nelua_stringbuilderT_grow(nelua_stringbuilderT_ptr self, uintptr_t newsize) {
  uintptr_t needed = (newsize + 1);
  uintptr_t cap = self->data.size;
  if((needed <= cap)) {
    return true;
  }
  if((cap == 0)) {
    cap = 16U;
  }
  while((cap < needed)) {
    cap = (cap * 2);
    if((cap <= 16U)) {
      return false;
    }
  }
  self->data = nelua_GCAllocator_spanrealloc0_1((&self->allocator), self->data, cap);
  if((self->data.size != cap)) {
    self->data = nelua_GCAllocator_spanrealloc0_1((&self->allocator), self->data, needed);
  }
  return (needed <= self->data.size);
}
nelua_span_uint8_ nelua_stringbuilderT_prepare(nelua_stringbuilderT_ptr self, uintptr_t n) {
  if((!nelua_stringbuilderT_grow(self, (self->size + n)))) {
    return (nelua_span_uint8_){0};
  }
  return (nelua_span_uint8_){.data = ((nluint8_arr0_ptr)(&(*(uint8_t*)nelua_assert_deref(nelua_span_uint8____atindex(self->data, self->size))))), .size = ((self->data.size - self->size) - 1)};
}
void nelua_assert_line_46(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/nix/store/fjg7d071zkmnh2jk44hjr291x4b4794z-nelua-0-unstable-2024-04-20/lib/nelua/lib/stringbuilder.nelua\033[1m:150:19: \033[31m\033[1mruntime error: \033[0m\033[1m", 150, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n    check(newsize <= self.data.size, 'not enough space in string buffer')\n                  \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~~\033[0m\n", 137, true);
    nelua_abort();
  }
}
void nelua_stringbuilderT_commit(nelua_stringbuilderT_ptr self, uintptr_t n) {
  uintptr_t newsize = (self->size + n);
  nelua_assert_line_46((newsize <= self->data.size), ((nlstring){(uint8_t*)"not enough space in string buffer", 33}));
  self->size = newsize;
}
nlstring nelua_stringbuilderT_promote(nelua_stringbuilderT_ptr self) {
  if(NELUA_UNLIKELY((self->size == 0))) {
    nelua_stringbuilderT_destroy(self);
    return (nlstring){0};
  }
  uintptr_t size = self->size;
  nelua_span_uint8_ data = nelua_GCAllocator_xspanrealloc_1((&self->allocator), self->data, (size + 1));
  (*(uint8_t*)nelua_assert_deref(nelua_span_uint8____atindex(data, size))) = 0U;
  self->data = (nelua_span_uint8_){0};
  self->size = 0U;
  return (nlstring){.data = data.data, .size = size};
}
void nelua_assert_line_47(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/nix/store/fjg7d071zkmnh2jk44hjr291x4b4794z-nelua-0-unstable-2024-04-20/lib/nelua/lib/string.nelua\033[1m:35:14: \033[31m\033[1mruntime error: \033[0m\033[1m", 142, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n  check(size > 0, 'attempt to create an empty string')\n             \033[1m\033[32m^\033[0m\033[35m~~\033[0m\n", 99, true);
    nelua_abort();
  }
}
nlstring nelua_nlstring_create(uintptr_t size) {
  nelua_assert_line_47((size > 0), ((nlstring){(uint8_t*)"attempt to create an empty string", 33}));
  nlstring s = (nlstring){.data = ((nluint8_arr0_ptr)nelua_GCAllocator_xalloc_1((&nelua_gc_allocator), (size + 1), NELUA_NIL)), .size = size};
  s.data[size] = 0U;
  return s;
}
void nelua_nlstring_destroy(nlstring_ptr self) {
  if(NELUA_UNLIKELY((self->size == 0))) {
    return;
  }
  nelua_GCAllocator_dealloc((&nelua_gc_allocator), (void*)self->data);
  self->data = ((nluint8_arr0_ptr)NULL);
  self->size = 0U;
}
nlstring nelua_nlstring_copy(nlstring s) {
  nlstring clone = (nlstring){0};
  if(NELUA_UNLIKELY((s.size == 0))) {
    return clone;
  }
  clone.data = ((nluint8_arr0_ptr)nelua_GCAllocator_xalloc_1((&nelua_gc_allocator), (s.size + 1), NELUA_NIL));
  nelua_memory_copy((void*)clone.data, (void*)s.data, s.size);
  clone.data[s.size] = 0U;
  clone.size = s.size;
  return clone;
}
void nelua_assert_line_48(bool cond, nlstring msg) {
  if(NELUA_UNLIKELY(!cond)) {
    nelua_write_stderr("/nix/store/fjg7d071zkmnh2jk44hjr291x4b4794z-nelua-0-unstable-2024-04-20/lib/nelua/lib/string.nelua\033[1m:311:16: \033[31m\033[1mruntime error: \033[0m\033[1m", 143, false);
    nelua_write_stderr((const char*)msg.data, msg.size, false);
    nelua_write_stderr("\033[0m\n  check(i >= 1 and i <= s.size, 'index out of range')\n               \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~\033[0m\n", 112, true);
    nelua_abort();
  }
}
nluint8_ptr nelua_nlstring___atindex(nlstring s, uintptr_t i) {
  nelua_assert_line_48(((i >= 1) && (i <= s.size)), ((nlstring){(uint8_t*)"index out of range", 18}));
  return (&s.data[(i - 1)]);
}
intptr_t nelua_nlstring___len(nlstring a) {
  return (intptr_t)a.size;
}
nlstring nelua_nlstring___concat_1(int32_t a, nlstring b) {
  nlstring a_3 = nelua_tostring_2(a);
  if((a_3.size == 0)) {
    nlstring _ret_1 = nelua_nlstring_copy(b);
    { /* defer */
      nelua_nlstring_destroy((&a_3));
    }
    return _ret_1;
  } else if((b.size == 0)) {
    nlstring _ret_2 = nelua_nlstring_copy(a_3);
    { /* defer */
      nelua_nlstring_destroy((&a_3));
    }
    return _ret_2;
  }
  nlstring s = nelua_nlstring_create((a_3.size + b.size));
  nelua_memory_copy((void*)s.data, (void*)a_3.data, a_3.size);
  nelua_memory_copy((void*)(&s.data[a_3.size]), (void*)b.data, b.size);
  nlstring _ret_3 = s;
  { /* defer */
    nelua_nlstring_destroy((&a_3));
  }
  return _ret_3;
}
nlstring nelua_nlstring___concat_2(nlstring a, nlstring b) {
  if((a.size == 0)) {
    return nelua_nlstring_copy(b);
  } else if((b.size == 0)) {
    return nelua_nlstring_copy(a);
  }
  nlstring s = nelua_nlstring_create((a.size + b.size));
  nelua_memory_copy((void*)s.data, (void*)a.data, a.size);
  nelua_memory_copy((void*)(&s.data[a.size]), (void*)b.data, b.size);
  return s;
}
nlstring nelua_tostring_2(int32_t x) {
  nluint8_arr48 buf;
  nlstring s = nelua_strconv_1_int2str_2((&buf), (intptr_t)x, NELUA_NIL);
  return nelua_nlstring_copy(s);
}
FILE_ptr nelua_filestream__getfp(nelua_filestream_ptr self) {
  if((!(self->fs != NULL))) {
    return ((FILE_ptr)NULL);
  }
  return self->fs->fp;
}
nlstring nelua_cstring2string(const char* s) {
  if(s == NULL) {
    return (nlstring){0};
  }
  uintptr_t size = strlen(s);
  if(size == 0) {
    return (nlstring){0};
  }
  return (nlstring){(uint8_t*)s, size};
}
nlmulret_nlstring_nlint64 nelua_geterrno(void) {
  return (nlmulret_nlstring_nlint64){nelua_cstring2string(strerror(errno)), (int64_t)errno};
}
nlmulret_nlboolean_nlstring nelua_readchars(nelua_stringbuilderT_ptr sb, FILE_ptr fp, uintptr_t n) {
  nelua_span_uint8_ p = nelua_stringbuilderT_prepare(sb, n);
  if(nelua_span_uint8__empty(p)) {
    return (nlmulret_nlboolean_nlstring){false, ((nlstring){(uint8_t*)"out of buffer memory", 20})};
  }
  size_t nr = fread((void*)p.data, 1U, (size_t)n, fp);
  nelua_stringbuilderT_commit(sb, (uintptr_t)nr);
  return (nlmulret_nlboolean_nlstring){(nr > 0), (nlstring){0}};
}
nlmulret_nlstring_nlstring_nlint64 nelua_filestream_read_1(nelua_filestream_ptr self, int64_t fmt) {
  FILE_ptr fp = nelua_filestream__getfp(self);
  if((!(fp != NULL))) {
    return (nlmulret_nlstring_nlstring_nlint64){(nlstring){0}, ((nlstring){(uint8_t*)"attempt to use a closed file", 28}), -1};
  }
  nelua_stringbuilderT sb = (nelua_stringbuilderT){0};
  bool success = false;
  nlstring errmsg = (nlstring){0};
  clearerr(fp);
  nlmulret_nlboolean_nlstring _asgnret_1 = nelua_readchars((&sb), fp, nelua_assert_narrow_nlint64_nlusize(fmt));
  success = _asgnret_1.r1;
  errmsg = _asgnret_1.r2;
  int64_t status = 0;
  if((ferror(fp) != 0)) {
    success = false;
    nlmulret_nlstring_nlint64 _asgnret_2 = nelua_geterrno();
    errmsg = _asgnret_2.r1;
    status = _asgnret_2.r2;
  }
  nlstring s = (nlstring){0};
  if(success) {
    s = nelua_stringbuilderT_promote((&sb));
  } else {
    if((nelua_nlstring___len(errmsg) == 0)) {
      errmsg = ((nlstring){(uint8_t*)"eof", 3});
      status = (int64_t)EOF;
    } else if((status == 0)) {
      status = -1;
    }
    nelua_stringbuilderT_destroy((&sb));
  }
  return (nlmulret_nlstring_nlstring_nlint64){s, errmsg, status};
}
nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_write_1(nelua_filestream_ptr self, nlstring __arg1) {
  FILE_ptr fp = nelua_filestream__getfp(self);
  if((!(fp != NULL))) {
    return (nlmulret_nlboolean_nlstring_nlint64){false, ((nlstring){(uint8_t*)"attempt to use a closed file", 28}), -1};
  }
  {
    nlstring s = __arg1;
    if((s.size > 0)) {
      bool ok = (fwrite((void*)s.data, 1U, (size_t)s.size, fp) == s.size);
      if((!ok)) {
        nlmulret_nlstring_nlint64 _ret_1 = nelua_geterrno();
        return (nlmulret_nlboolean_nlstring_nlint64){false, _ret_1.r1, _ret_1.r2};
      }
    }
  }
  return (nlmulret_nlboolean_nlstring_nlint64){true, ((nlstring){(uint8_t*)"", 0}), 0};
}
nlmulret_nlstring_nlstring_nlint64 nelua_io_read_1(int64_t fmt) {
  nlmulret_nlstring_nlstring_nlint64 _mulret_1;
  nlmulret_nlstring_nlstring_nlint64 _ret_1 = nelua_filestream_read_1((&nelua_io_stdin), fmt);
  _mulret_1.r1 = _ret_1.r1;
  _mulret_1.r2 = _ret_1.r2;
  _mulret_1.r3 = _ret_1.r3;
  return _mulret_1;
}
nlmulret_nlboolean_nlstring_nlint64 nelua_io_write_1(nlstring __arg1) {
  nlmulret_nlboolean_nlstring_nlint64 _ret_1 = nelua_filestream_write_1((&nelua_io_stdout), __arg1);
  return (nlmulret_nlboolean_nlstring_nlint64){_ret_1.r1, _ret_1.r2, _ret_1.r3};
}
nltype nelua_require_io(nlniltype modname) {
  nelua_stdinfs = (nelua_FStream){.fp = stdin};
  nelua_io_stdin = (nelua_filestream){.fs = (&nelua_stdinfs)};
  nelua_stdoutfs = (nelua_FStream){.fp = stdout};
  nelua_io_stdout = (nelua_filestream){.fs = (&nelua_stdoutfs)};
  return NELUA_NIL;
}
void nelua_require_entmgr(nlniltype modname) {
  nelua_require_list_cached(NELUA_NIL);
  nelua_require_pool_cached(NELUA_NIL);
}
nlstring main_vec2___tostring(main_vec2_ptr self) {
  return nelua_nlstring___concat_2(((nlstring){(uint8_t*)"(", 1}), nelua_nlstring___concat_1(self->x, nelua_nlstring___concat_2(((nlstring){(uint8_t*)", ", 2}), nelua_nlstring___concat_1(self->y, ((nlstring){(uint8_t*)")", 1})))));
}
void main_EventBusT_init(main_EventBusT_ptr self) {
  event_SubListT_1_init((&self->sublist_AnimalDeath));
  event_SubListT_5_init((&self->sublist_ObjectTryMove));
  event_SubListT_3_init((&self->sublist_PlayerAttack));
  event_SubListT_6_init((&self->sublist_KeyPressed));
  event_SubListT_init((&self->sublist_AfterEventProcessing));
  event_SubListT_4_init((&self->sublist_AnimalDamaged));
  event_SubListT_2_init((&self->sublist_ObjectMoved));
}
void main_EventBusT_subscribeTo_1(main_EventBusT_ptr self, nlniltype event, void* subscriber, function_4WmBbjumsffDobLkA handler) {
  event_SubListT_6_sub((&self->sublist_KeyPressed), subscriber, (function_2RMqu9Y13j8kEs2Lg)handler);
}
void main_EventBusT_subscribeTo_2(main_EventBusT_ptr self, nlniltype event, void* subscriber, function_15AWPgqbccPV11c7 handler) {
  event_SubListT_4_sub((&self->sublist_AnimalDamaged), subscriber, (function_oRZ7yVG9JpaZWeAa)handler);
}
void main_EventBusT_subscribeTo_3(main_EventBusT_ptr self, nlniltype event, void* subscriber, function_3s38JSQJHhFrY9ris handler) {
  event_SubListT_3_sub((&self->sublist_PlayerAttack), subscriber, (function_rgZz7Vgcn1eBw8fD)handler);
}
void main_EventBusT_subscribeTo_4(main_EventBusT_ptr self, nlniltype event, void* subscriber, function_2htbwEnNf7AXuQQHo handler) {
  event_SubListT_3_sub((&self->sublist_PlayerAttack), subscriber, (function_2unX1KsA8mAv3LfB4)handler);
}
void main_EventBusT_subscribeTo_5(main_EventBusT_ptr self, nlniltype event, void* subscriber, function_oBKPg1FFcB5Dg4Aw handler) {
  event_SubListT_2_sub((&self->sublist_ObjectMoved), subscriber, (function_HUcGJ63PhNaPPbUN)handler);
}
void main_EventBusT_subscribeTo_6(main_EventBusT_ptr self, nlniltype event, void* subscriber, function_51hrVrGsWPLUqgN7q handler) {
  event_SubListT_1_sub((&self->sublist_AnimalDeath), subscriber, (function_smbtA6kyWbJcVXmB)handler);
}
void main_EventBusT_subscribeTo_7(main_EventBusT_ptr self, nlniltype event, void* subscriber, function_3Rhiu8maLRfEDva9C handler) {
  event_SubListT_5_sub((&self->sublist_ObjectTryMove), subscriber, (function_mgToF1Ks5bFq6EaH)handler);
}
void main_EventBusT_subscribeTo_8(main_EventBusT_ptr self, nlniltype event, void* subscriber, function_4Y2Xurfya4ueffdc3 handler) {
  event_SubListT_2_sub((&self->sublist_ObjectMoved), subscriber, (function_4SCqEa4iBBx8mdkem)handler);
}
void main_EventBusT_emit_1(main_EventBusT_ptr self, main_event_Event_KeyPressed event) {
  event_SubListT_6_emit((&self->sublist_KeyPressed), (&event));
}
void main_EventBusT_emit_2(main_EventBusT_ptr self, main_event_Event_PlayerAttack_ptr event) {
  event_SubListT_3_emit((&self->sublist_PlayerAttack), event);
}
void main_EventBusT_emit_3(main_EventBusT_ptr self, main_event_Event_AnimalDeath_ptr event) {
  event_SubListT_1_emit((&self->sublist_AnimalDeath), event);
}
void main_EventBusT_emit_4(main_EventBusT_ptr self, main_event_Event_AnimalDamaged_ptr event) {
  event_SubListT_4_emit((&self->sublist_AnimalDamaged), event);
}
void main_EventBusT_emit_5(main_EventBusT_ptr self, main_event_Event_ObjectTryMove_ptr event) {
  event_SubListT_5_emit((&self->sublist_ObjectTryMove), event);
}
void main_EventBusT_emit_6(main_EventBusT_ptr self, main_event_Event_ObjectMoved_ptr event) {
  event_SubListT_2_emit((&self->sublist_ObjectMoved), event);
}
void main_Object_subscribeTo_1(main_Player_ptr self, nlniltype event, function_4WmBbjumsffDobLkA handler) {
  main_EventBusT_subscribeTo_1((&main_event_bus), NELUA_NIL, (void*)self, handler);
}
void main_Object_subscribeTo_2(main_Player_ptr self, nlniltype event, function_15AWPgqbccPV11c7 handler) {
  main_EventBusT_subscribeTo_2((&main_event_bus), NELUA_NIL, (void*)self, handler);
}
void main_Object_subscribeTo_3(main_Animal_ptr self, nlniltype event, function_3s38JSQJHhFrY9ris handler) {
  main_EventBusT_subscribeTo_3((&main_event_bus), NELUA_NIL, (void*)self, handler);
}
void main_Object_raiseEvent_1(main_Player_ptr self, main_event_Event_PlayerAttack_ptr event) {
  main_EventBusT_emit_2((&main_event_bus), event);
}
void main_Object_raiseEvent_2(main_Animal_ptr self, main_event_Event_AnimalDeath_ptr event) {
  main_EventBusT_emit_3((&main_event_bus), event);
}
void main_Object_raiseEvent_3(main_Animal_ptr self, main_event_Event_AnimalDamaged_ptr event) {
  main_EventBusT_emit_4((&main_event_bus), event);
}
void main_Object_raiseEvent_4(main_Object_ptr self, main_event_Event_ObjectTryMove_ptr event) {
  main_EventBusT_emit_5((&main_event_bus), event);
}
void main_Object_raiseEvent_5(main_Object_ptr self, main_event_Event_ObjectMoved_ptr event) {
  main_EventBusT_emit_6((&main_event_bus), event);
}
void main_Object_tryMoveTo_1(main_Player_ptr ptr, main_vec2 pos) {
  main_Object_ptr self = ((main_Object_ptr)ptr);
  main_event_Event_ObjectTryMove attempt = (main_event_Event_ObjectTryMove){.obj = self, .destination = pos, .cancel = false};
  main_Object_raiseEvent_4(self, (&attempt));
  if(attempt.cancel) {
    return;
  }
  main_vec2 oldpos = self->pos;
  self->pos = pos;
  main_event_Event_ObjectMoved ev = (main_event_Event_ObjectMoved){0};
  ev.obj = self;
  ev.oldpos = oldpos;
  main_Object_raiseEvent_5(self, (&ev));
}
void nelua_print_1(nlstring a1, nlstring a2) {
  if(a1.size > 0) {
    fwrite(a1.data, 1, a1.size, stdout);
  }
  fputs("	", stdout);
  if(a2.size > 0) {
    fwrite(a2.data, 1, a2.size, stdout);
  }
  fputs("\n", stdout);
  fflush(stdout);
}
void main_Player_say_1(main_Player_ptr self, nlstring __arg1) {
  nelua_print_1(((nlstring){(uint8_t*)"Player: ", 8}), __arg1);
}
void main_Player_KeyPressed_handler(main_Player_ptr self_1, main_event_Event_KeyPressed_ptr event) {
  main_vec2 pos = self_1->pos;
  switch(event->key) {
    case 119U: {
      main_Object_tryMoveTo_1(self_1, (main_vec2){pos.x, (pos.y - 1)});
      break;
    }
    case 97U: {
      main_Object_tryMoveTo_1(self_1, (main_vec2){(pos.x - 1), pos.y});
      break;
    }
    case 115U: {
      main_Object_tryMoveTo_1(self_1, (main_vec2){pos.x, (pos.y + 1)});
      break;
    }
    case 100U: {
      main_Object_tryMoveTo_1(self_1, (main_vec2){(pos.x + 1), pos.y});
      break;
    }
    case 105U: {
      {
          main_event_Event_PlayerAttack ev = (main_event_Event_PlayerAttack){0};
          ev.player = self_1;
          ev.attack_pos = (main_vec2){pos.x, (pos.y - 1)};
          main_Object_raiseEvent_1(self_1, (&ev));
      };
      break;
    }
    case 106U: {
      {
          main_event_Event_PlayerAttack ev = (main_event_Event_PlayerAttack){0};
          ev.player = self_1;
          ev.attack_pos = (main_vec2){(pos.x - 1), pos.y};
          main_Object_raiseEvent_1(self_1, (&ev));
      };
      break;
    }
    case 107U: {
      {
          main_event_Event_PlayerAttack ev = (main_event_Event_PlayerAttack){0};
          ev.player = self_1;
          ev.attack_pos = (main_vec2){pos.x, (pos.y + 1)};
          main_Object_raiseEvent_1(self_1, (&ev));
      };
      break;
    }
    case 108U: {
      {
          main_event_Event_PlayerAttack ev = (main_event_Event_PlayerAttack){0};
          ev.player = self_1;
          ev.attack_pos = (main_vec2){(pos.x + 1), pos.y};
          main_Object_raiseEvent_1(self_1, (&ev));
      };
      break;
    }
  }
}
void main_Player_AnimalDamaged_handler(main_Player_ptr self_2, main_event_Event_AnimalDamaged_ptr event) {
  main_Player_say_1(self_2, ((nlstring){(uint8_t*)"Take that foul beast!", 21}));
}
void main_Player_init(main_Player_ptr self) {
  self->typeid = 0U;
  main_Object_subscribeTo_1(self, NELUA_NIL, main_Player_KeyPressed_handler);
  main_Object_subscribeTo_2(self, NELUA_NIL, main_Player_AnimalDamaged_handler);
}
main_Player_ptr main_Player_create(main_vec2 pos) {
  main_Player_ptr out = nelua_new_1(NELUA_NIL, NELUA_NIL, NELUA_NIL);
  main_Player_init(out);
  out->pos = pos;
  return out;
}
void nelua_print_2(nlstring a1) {
  if(a1.size > 0) {
    fwrite(a1.data, 1, a1.size, stdout);
  }
  fputs("\n", stdout);
  fflush(stdout);
}
void main_Animal_PlayerAttack_handler(main_Animal_ptr self_3, main_event_Event_PlayerAttack_ptr event) {
  if((((!(event->attack_pos, true)), self_3->pos, false) || (self_3->health <= 0))) {
    return;
  }
  nelua_print_2(((nlstring){(uint8_t*)"Animal: baaah!", 14}));
  self_3->health = (self_3->health - 25);
  if((self_3->health <= 0)) {
    main_event_Event_AnimalDeath ev = (main_event_Event_AnimalDeath){0};
    ev.animal = self_3;
    main_Object_raiseEvent_2(self_3, (&ev));
  } else {
    main_event_Event_AnimalDamaged ev = (main_event_Event_AnimalDamaged){0};
    ev.animal = self_3;
    main_Object_raiseEvent_3(self_3, (&ev));
  }
}
void main_Animal_init(main_Animal_ptr self) {
  self->typeid = 1U;
  main_Object_subscribeTo_3(self, NELUA_NIL, main_Animal_PlayerAttack_handler);
}
main_Animal_ptr main_Animal_create(main_vec2 pos) {
  main_Animal_ptr out = nelua_new_2(NELUA_NIL, NELUA_NIL, NELUA_NIL);
  main_Animal_init(out);
  out->pos = pos;
  out->health = 100;
  return out;
}
void main_Narrator_subscribeTo_1(main_Narrator_ptr self, nlniltype event, function_2htbwEnNf7AXuQQHo handler) {
  main_EventBusT_subscribeTo_4((&main_event_bus), NELUA_NIL, (void*)self, handler);
}
void main_Narrator_subscribeTo_2(main_Narrator_ptr self, nlniltype event, function_oBKPg1FFcB5Dg4Aw handler) {
  main_EventBusT_subscribeTo_5((&main_event_bus), NELUA_NIL, (void*)self, handler);
}
void main_Narrator_subscribeTo_3(main_Narrator_ptr self, nlniltype event, function_51hrVrGsWPLUqgN7q handler) {
  main_EventBusT_subscribeTo_6((&main_event_bus), NELUA_NIL, (void*)self, handler);
}
void main_Narrator_PlayerAttack_handler(main_Narrator_ptr self_4, main_event_Event_PlayerAttack_ptr event) {
  nelua_print_1(((nlstring){(uint8_t*)"The player has attacked position ", 33}), main_vec2___tostring((&event->attack_pos)));
}
void main_Narrator_ObjectMoved_handler(main_Narrator_ptr self_5, main_event_Event_ObjectMoved_ptr event) {
  if((event->obj->typeid == 0)) {
    nelua_print_1(((nlstring){(uint8_t*)"The player has moved to ", 24}), main_vec2___tostring((&event->obj->pos)));
  }
}
void main_Narrator_AnimalDeath_handler(main_Narrator_ptr self_6, main_event_Event_AnimalDeath_ptr event) {
  nelua_print_2(((nlstring){(uint8_t*)"An animal has been slain by the player", 38}));
}
void main_Narrator_init(main_Narrator_ptr self) {
  main_Narrator_subscribeTo_1(self, NELUA_NIL, main_Narrator_PlayerAttack_handler);
  main_Narrator_subscribeTo_2(self, NELUA_NIL, main_Narrator_ObjectMoved_handler);
  main_Narrator_subscribeTo_3(self, NELUA_NIL, main_Narrator_AnimalDeath_handler);
}
bool main_Tile_hasObject(main_Tile_ptr self) {
  return (!list_DList_2_isEmpty((&self->objects)));
}
list_Node_8_ptr main_Tile_addObject_1(main_Tile_ptr self, main_Object_ptr ptr) {
  return list_DList_2_pushHead((&self->objects), ptr);
}
list_Node_8_ptr main_Tile_addObject_2(main_Tile_ptr self, main_Player_ptr ptr) {
  return list_DList_2_pushHead((&self->objects), ((main_Object_ptr)ptr));
}
list_Node_8_ptr main_Tile_addObject_3(main_Tile_ptr self, main_Animal_ptr ptr) {
  return list_DList_2_pushHead((&self->objects), ((main_Object_ptr)ptr));
}
void main_Tile_removeObject_1(main_Tile_ptr self, main_Object_ptr ptr) {
  list_DList_2_remove((&self->objects), ptr->tile_node);
}
void main_Map_subscribeTo_1(main_Map_ptr self, nlniltype event, function_3Rhiu8maLRfEDva9C handler) {
  main_EventBusT_subscribeTo_7((&main_event_bus), NELUA_NIL, (void*)self, handler);
}
void main_Map_subscribeTo_2(main_Map_ptr self, nlniltype event, function_4Y2Xurfya4ueffdc3 handler) {
  main_EventBusT_subscribeTo_8((&main_event_bus), NELUA_NIL, (void*)self, handler);
}
int64_t nelua_assert_imod_nlint64(int64_t a, int64_t b) {
  if(NELUA_UNLIKELY(b == -1)) return 0;
  if(NELUA_UNLIKELY(b == 0)) nelua_panic_cstring("division by zero");
  int64_t r = a % b;
  return (r != 0 && (a ^ b) < 0) ? r + b : r;
}
main_vec2 main_Map_getTilePosFromOffset(int32_t offset) {
  return (main_vec2){(int32_t)nelua_assert_imod_nlint64(offset, 7), (int32_t)(offset / (double)7)};
}
main_Tile_ptr main_Map_getTile(main_Map_ptr self, main_vec2 pos) {
  return (&self->tiles[nelua_assert_bounds_nlint64((pos.x + (7 * pos.y)), 49)]);
}
int32_t nelua_assert_narrow_nlint64_nlint32(int64_t x) {
  if(NELUA_UNLIKELY(x > 0x7fffffff || x < (-2147483647-1))) {
    nelua_panic_cstring("narrow casting from int64 to int32 failed");
  }
  return (int32_t)x;
}
void main_readInit(main_Map_ptr self_7, nlstring initstr_1) {
  int64_t tileidx = 0;
  {
    nlmulret_function_r1xBQ225tRe7LZWm_nlstring_ptr_nlint64 _asgnret_1 = nelua_ipairs_1((&initstr_1));
    function_r1xBQ225tRe7LZWm __fornext = _asgnret_1.r1;
    nlstring_ptr __forstate = _asgnret_1.r2;
    int64_t __fornextit = _asgnret_1.r3;
    while(true) {
      nlmulret_nlboolean_nlint64_nluint8 _asgnret_2 = __fornext(__forstate, __fornextit);
      bool __forcont = _asgnret_2.r1;
      int64_t _ = _asgnret_2.r2;
      uint8_t c = _asgnret_2.r3;
      if((!__forcont)) {
        break;
      }
      __fornextit = _;
      {
        if((tileidx >= 49)) {
          break;
        }
        main_vec2 pos = main_Map_getTilePosFromOffset(nelua_assert_narrow_nlint64_nlint32(tileidx));
        switch(c) {
          case 88U: {
            self_7->tiles[nelua_assert_bounds_nlint64(tileidx, 49)].kind = 1;
            tileidx = (tileidx + 1);
            break;
          }
          case 80U: {
            main_Player_ptr player = main_Player_create(pos);
            player->tile_node = main_Tile_addObject_2((&self_7->tiles[nelua_assert_bounds_nlint64(tileidx, 49)]), player);
            tileidx = (tileidx + 1);
            break;
          }
          case 65U: {
            main_Animal_ptr animal = main_Animal_create(pos);
            animal->tile_node = main_Tile_addObject_3((&self_7->tiles[nelua_assert_bounds_nlint64(tileidx, 49)]), animal);
            tileidx = (tileidx + 1);
            break;
          }
          case 46U: {
            self_7->tiles[nelua_assert_bounds_nlint64(tileidx, 49)].kind = 0;
            tileidx = (tileidx + 1);
            break;
          }
        }
      }
    }
  }
}
void main_Map_ObjectTryMove_handler(main_Map_ptr self_8, main_event_Event_ObjectTryMove_ptr event) {
  main_Tile_ptr tile = main_Map_getTile(self_8, event->destination);
  if((1 == tile->kind)) {
    event->cancel = true;
  }
}
void main_Map_ObjectMoved_handler(main_Map_ptr self_9, main_event_Event_ObjectMoved_ptr event) {
  main_Tile_ptr oldtile = main_Map_getTile(self_9, event->oldpos);
  main_Tile_ptr newtile = main_Map_getTile(self_9, event->obj->pos);
  main_Tile_removeObject_1(oldtile, event->obj);
  event->obj->tile_node = main_Tile_addObject_1(newtile, event->obj);
}
void main_Map_init(main_Map_ptr self, nlstring initstr) {
  list_SListT_7_init((&self->deferred_removal));
  {
    nlmulret_function_34gvaBKj3vvkM3dS7_main_Tile_arr49_ptr_nlint64 _asgnret_1 = nelua_mipairs_1((&(((main_Tile_arr49_cast*)&self->tiles)->a)));
    function_34gvaBKj3vvkM3dS7 __fornext = _asgnret_1.r1;
    main_Tile_arr49_ptr __forstate = _asgnret_1.r2;
    int64_t __fornextit = _asgnret_1.r3;
    while(true) {
      nlmulret_nlboolean_nlint64_main_Tile_ptr _asgnret_2 = __fornext(__forstate, __fornextit);
      bool __forcont = _asgnret_2.r1;
      int64_t _ = _asgnret_2.r2;
      main_Tile_ptr tile = _asgnret_2.r3;
      if((!__forcont)) {
        break;
      }
      __fornextit = _;
      {
        list_DList_2_init((&tile->objects));
      }
    }
  }
  main_readInit(self, initstr);
  main_Map_subscribeTo_1(self, NELUA_NIL, main_Map_ObjectTryMove_handler);
  main_Map_subscribeTo_2(self, NELUA_NIL, main_Map_ObjectMoved_handler);
}
void main_Map_render(main_Map_ptr self) {
  for(int64_t y = 0; y < 7; y += 1) {
    for(int64_t x = 0; x < 7; x += 1) {
      main_Tile_ptr tile = main_Map_getTile(self, (main_vec2){(int32_t)x, (int32_t)y});
      if((tile->kind == 1)) {
        nelua_io_write_1(((nlstring){(uint8_t*)"X", 1}));
      } else {
        if(main_Tile_hasObject(tile)) {
          nlstring c = ((nlstring){(uint8_t*)"?", 1});
          list_Node_8_ptr n = tile->objects.head;
          while((n != NULL)) {
            main_Object_ptr o = n->data;
            switch(o->typeid) {
              case 0: {
                c = ((nlstring){(uint8_t*)"P", 1});
                goto _breaklabel_1;
              }
              case 1: {
                c = ((nlstring){(uint8_t*)"A", 1});
                break;
              }
            }
            n = n->next;
          }
          _breaklabel_1:;
          nelua_io_write_1(c);
        } else {
          nelua_io_write_1(((nlstring){(uint8_t*)".", 1}));
        }
      }
    }
    nelua_io_write_1(((nlstring){(uint8_t*)"\n", 1}));
  }
}
int nelua_main(int argc, char** argv) {
  nelua_require_pool_cached(NELUA_NIL);
  nelua_require_list_cached(NELUA_NIL);
  nelua_require_event(NELUA_NIL);
  nelua_require_io(NELUA_NIL);
  nelua_require_entmgr(NELUA_NIL);
	// setup non-canonical mode so keypresses on stdin are flushed 
	// immediately
	struct termios mode;
	tcgetattr(0, &mode);

	struct termios newmode = mode;
	newmode.c_lflag &= ~(ICANON|ECHO);
	newmode.c_cc[VMIN] = 1; // min characters needed for non-canonical read
	newmode.c_cc[VTIME] = 0; // timeout for read in non-canonical
	tcsetattr(0, TCSAFLUSH, &newmode);
  main_EventBusT_init((&main_event_bus));
  nelua_print_2(main_vec2___tostring(NELUA_LITERAL_REF(main_vec2, (main_Map_getTilePosFromOffset(1)))));
  nelua_print_2(main_vec2___tostring(NELUA_LITERAL_REF(main_vec2, (main_Map_getTilePosFromOffset(2)))));
  nelua_print_2(main_vec2___tostring(NELUA_LITERAL_REF(main_vec2, (main_Map_getTilePosFromOffset(3)))));
  main_Narrator_init((&main_narrator));
  main_Map_init((&main_map), ((nlstring){(uint8_t*)"\tXXXXXXX\n\tX...A.X\n\tX.....X\n\tX.....X\n\tX.P...X\n\tX.....X\n\tXXXXXXX\n", 63}));
  while(true) {
    main_Map_render((&main_map));
    nlstring s = nelua_io_read_1(1).r1;
    main_EventBusT_emit_1((&main_event_bus), (main_event_Event_KeyPressed){(*(uint8_t*)nelua_assert_deref(nelua_nlstring___atindex(s, 1U)))});
  }
  return 0;
}
