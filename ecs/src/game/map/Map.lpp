$ local cmn = require "common"

@@lpp.import "asset/AssetMgr.lh"
@@lpp.import "asset/SourceData.lh"
@@lpp.import "Engine.lh"
@@lpp.import "game/map/Map.lh"
@@lpp.import "game/map/Map.schema.lh"
@@lpp.import "game/GameMgr.lh"
@@lpp.import "game/EntityLoader.lh"
@@lpp.import "game/Spawner.comp.lh"
@@lpp.import "game/Transform.comp.lh"

#include "iro/Logger.h"

@cmn.defFileLogger(game.map, Info)

/* ----------------------------------------------------------------------------
 */
b8 Tile::init(
    const MapTileDef& def, 
    u32               layer_idx, 
    AssetMgr&         assetmgr,
    EntityMgr&        entmgr,
    gfx::Renderer&    renderer)
{
  TRACE("initializing tile at (",def.pos.x,",",def.pos.y,",",layer_idx,")\n");
  if (r_texture.isValid())
    return ERROR("duplicate tiles at (",def.pos.x,",",def.pos.y,",",
      layer_idx,")\n");

  this->def = &def;
  
  if (notnil(def.texture))
  {
    r_texture.track(gfx::CompiledTexture::load(
      def.texture,
      assetmgr,
      renderer));
  }

  for (const SourceData* ent_data : def.entities)
  {
    auto entid = loadEntity(*ent_data, entmgr, assetmgr, renderer);
    auto* ent = entmgr.getEntity(entid);
    auto* transform = ent->tryComp<Transform>();
    transform->pos = def.pos;
    transform->placement_layer = layer_idx;
  }

  return true;
}

/* ----------------------------------------------------------------------------
 */
b8 Layer::init(
    const MapLayerDef& def, 
    u32                layer_idx, 
    AssetMgr&          assetmgr,
    EntityMgr&         entmgr,
    gfx::Renderer&     renderer)
{
  TRACE("initializing layer at (",def.pos.x,",",def.pos.y,",",layer_idx,")\n");
  assert(isnil(tiles));

  this->def = &def;

  if (!tiles.init())
    return ERROR("failed to initialize block array\n");

  tiles.resize(def.size.x * def.size.y);

  for (const MapTileDef& block_def : def.tiles)
  {
    Tile* block = 
      tiles.arr + block_def.pos.x + block_def.pos.y * def.size.x;

    if (!block->init(
          block_def, 
          layer_idx, 
          assetmgr,
          entmgr,
          renderer))
      return false;
  }

  return true;
}

/* ----------------------------------------------------------------------------
 */
b8 Map::init(const MapDef& def, InitParams& params)
{
  // INFO("initializing map '",def.name,"'\n");
  assert(isnil(layers));

  this->def = &def;

  AssetMgr&      assetmgr = params.assetmgr;
  EntityMgr&     entmgr   = params.entmgr;
  ComponentMgr&  cmpmgr   = entmgr.cmpmgr;
  gfx::Renderer& renderer = params.renderer;

  if (!layers.init())
    return ERROR("failed to initialize layer array\n");

  layers.resize(def.layers.len());
  
  for (u32 i = 0; i < def.layers.len(); ++i)
  {
    MapLayerDef* layer_def = def.layers.arr + i;
    Layer* layer = layers.arr + i;
    
    if (!layer->init(*layer_def, i, assetmgr, entmgr, renderer))
      return false;
  }

  // Iterate over PlayerSpawners 
  if (params.mind && params.eye)
  {
    MindSys& mind = *params.mind;
    EyeSys&  eye  = *params.eye;

    for (PlayerSpawner& spawner : cmpmgr.iterate<PlayerSpawner>())
    {
      auto player_entid = 
        entmgr.createEntityFromSourceData(
          "assets/entities/Test.ent"_str,
          assetmgr,
          renderer);

      mind.attach(player_entid);
      eye.attach(player_entid);

      auto player_ent = entmgr.getEntity(player_entid);
      auto* player_transform = player_ent->tryComp<Transform>();

      auto spawner_ent = entmgr.getEntity(spawner.owner);
      auto* spawner_transform = spawner_ent->tryComp<Transform>();

      player_transform->pos = spawner_transform->pos;
      player_transform->placement_layer = spawner_transform->placement_layer;
    }
  }

  return true;
}
