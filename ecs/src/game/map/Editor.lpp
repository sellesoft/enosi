$ local cmn = require "common"
$ local ui = require "ui.UI"
$ local Processor = require "reflect.Processor"
$ local ast = require "reflect.AST"

$$$
-- Import specific files we want to have reflected info of.

local imported = cmn.buffer.new()

imported:put(
  lpp.import "Editor.lh",
  lpp.import "game/map/Map.schema.lh")

local p = Processor.new(tostring(imported))
p:run()
$$$
@imported:get

$ local decls =
$ {
$   editor = p.decls.map["struct ui::MapEditor"],
$   tile_kind = p.decls.map["enum TileKind"],
$ }

@@lpp.import "Engine.lh"
@@lpp.import "game/map/Map.lh"
@@lpp.import "asset/Packing.lh"

#include "iro/Platform.h"
#include "math/util.h"

namespace ui
{

@defFileLogger(map.editor, Info)

/* ----------------------------------------------------------------------------
 */
MapEditor* MapEditor::create(UI& ui, gfx::Renderer* renderer)
{
  auto* editor = ui.allocateAndInitItem<MapEditor>("game.map.editor"_str);
  if (editor == nullptr)
    return nullptr;

  @ui.style(editor, MapEditor,
  | size: 100% 100%
  | border: 2
  | display: hidden
  | background_color: 0x000000ff)

  editor->renderer = renderer;
  editor->update_triggers.set(UpdateReason::MouseHover);

  DrawCmd* map_render = ui.drawcmds.add();
  map_render->tex.init(
    *renderer,
    600,
    400,
    gfx::ImageFormat::RGBA,
    gfx::ImageAddressMode::ClampToBlack,
    gfx::ImageFilter::Nearest,
    nullptr);
  map_render->alloc(&ui, gfx::putFilledRectCounts());

  editor->map_render = map_render;

  editor->framebuffer.init(
    *renderer,
    600,
    400,
    map_render->tex,
    {0,0,0,255});

  if (!editor->entmgr.init())
  {
    ERROR("failed to init entmgr\n");
    return nullptr;
  }

  //TODO(delle) Look into updating the renderer to support multiple
  // viewports so we dont have to make an entire new render system for
  // this. Might also be cool in gameplay to have a "security camera"
  // view that we could use to render the map from a different perspective.
  if (!editor->rendersys.init(*renderer, ui.eng->assetmgr))
  {
    ERROR("failed to init rendersys\n");
    return nullptr;
  }

  editor->world_pos = Text::make(ui, "map.editor.world_pos"_str);

  Engine& eng = *ui.eng;

  eng.subscribeToBroadcast<PreMapRender>(
    editor, &MapEditor::onPreMapRender);

  eng.subscribeToBroadcast<PreSpriteRender>(
    editor, &MapEditor::onPreSpriteRender);

  eng.subscribeToBroadcast<PostRender>(
    editor, &MapEditor::onPostRender);

  editor->left_panel = Item::begin(ui);
  {
    @ui.style(editor->left_panel, Item,
    | size: 250 100%
    | border: 2
    | background_color: 0x111111ff)

$ local toolButton = function(toolname)
    {
      auto* button = editor->select_button.$(toolname:lower()) =
        ui::Button::begin<MapEditor>(
          ui,
          editor,
          [] (Button*          button,
              MapEditor*       editor,
              ButtonActivation activation)
          {
            editor->tool = Tool::$(toolname);
            editor->selected_tool->set("$(toolname)"_str);
            editor->selected_tool->dirty = true;
          },
          "game.map.editor.select_tool_$(toolname:lower())"_str);

      @ui.style(button, Button,
      | size: 100 auto
      | background_color: 0x224422ff
      | border: 0 0 0 2
      | triggers: Released)

      Text::make(ui, ""_str, "$(toolname)"_str);

      ui.endItem();
    }
$ end

    @toolButton(None)
    @toolButton(Add)
    @toolButton(Remove)

    editor->selected_tool = Text::make(ui, ""_str, "None"_str);

    editor->add_options = Item::begin(ui, "game.map.editor.add_options"_str);
    {

    }
    ui.endItem();
  }
  ui.endItem();

  // Initial render.
  // editor->renderMap(ui);

  editor->need_render = true;

  return editor;
}

/* ----------------------------------------------------------------------------
 */
void MapEditor::destroy()
{
  if (h_selected_map.isValid())
    h_selected_map.release();
}

/* ----------------------------------------------------------------------------
 */
void MapEditor::selectMap(SourceDataFileHandle& h_map)
{
  h_selected_map = h_map;
}

/* ----------------------------------------------------------------------------
 */
void MapEditor::generate(UI* ui)
{
  // Draw rendered map quad.
  {
    auto [vp, ip] = map_render->getPtrs(ui);

    map_render->counts_used = {};

    map_render->counts_used +=
      gfx::putFilledRect(
        vp,
        ip,
        map_render->counts_used,
        pos_screen,
        size,
        {0.f, 1.f},
        {1.f, 1.f},
        {1.f, 0.f},
        {0.f, 0.f},
        {255,255,255,255});
  }
}

/* ----------------------------------------------------------------------------
 */
void MapEditor::evaluate(UI* ui)
{
  // Rerender the map in case our size changed.
  // TODO(sushi) it would be nice if UI Item provided a callback for
  //             an Item's size changing so we could detect this a little
  //             better. Look into that when we get around to reworking UI
  //             Items to be transform based.

  map_render->tex.deinit(*renderer);
  b8 tex_init = map_render->tex.init(
    *renderer,
    size.x,
    size.y,
    gfx::ImageFormat::RGBA,
    gfx::ImageAddressMode::ClampToBlack,
    gfx::ImageFilter::Nearest,
    nullptr);

  if (!tex_init)
    return;

  framebuffer.deinit(*renderer);
  framebuffer.init(
    *renderer,
    size.x,
    size.y,
    map_render->tex,
    {0,0,0,255});

  need_render = true; //TODO(delle) see if we still need this
}

/* ----------------------------------------------------------------------------
 *  TODO(sushi) map rendering needs to be moved back into here so that it
 *              doesnt render before we adjust position.
 */
void MapEditor::update(UI* ui, UpdateReason reason)
{
  InputMgr& input = ui->eng->input;

  vec2f mvp = input.mouse.window - pos_screen;
  vec2f mw = eye.screenToWorld(mvp, size);

  SourceDataFile* sdfile = h_selected_map.getFile();

  switch (control_state)
  {
  case ControlState::None:
    if (input.wasMouseButtonPressed(MouseButton::Left))
    {
      switch (tool)
      {
      case Tool::None:
        {
          drag_start_viewport = mvp;
          drag_start_eye = eye.pos;
          control_state = ControlState::Dragging;
        }
        break;

      case Tool::Add:
        {

        }
        break;
      }

      Tile* tile;
      Layer* layer;
      if (map.getTileAndLayerAtPos(&layer, &tile, mw))
      {
        u32 layer_idx = layer - map.layers.arr;
        u32 tile_idx = tile - layer->tiles.arr;

        INFO(
          "selected layer ", layer_idx, " ",
          "and tile ", tile_idx, "\n");

        SourceData* map_data = h_selected_map.getFile()->returned_data;
        SourceData* layers_data = map_data->findChildByName("layers"_str);
        SourceData* layer_data = layers_data->children[layer_idx];
        SourceData* tiles_data = layer_data->findChildByName("tiles"_str);
        SourceData* tile_data = tiles_data->children[tile_idx];
        tile_data->dump();

        // tile_data->children.clear();
      }
    }
    break;

  case ControlState::Dragging:
    {
      vec2f new_pos =
        drag_start_eye + eye.screenToWorld(drag_start_viewport, size) - mw;

      if (eye.pos != new_pos)
      {
        eye.pos = new_pos;
        need_render = true;
      }

      if (input.wasMouseButtonReleased(MouseButton::Left))
        control_state = ControlState::None;
    }
    break;
  }

  if (input.scroll != 0.f)
  {
    if (input.isKeyDown(Key::LShift))
    {
      eye.rotation += input.scroll * math::degreesToRadians(10);
    }
    else
    {
      // TODO(sushi) figure out why adjusting the eye pos on zoom to zoom
      //             towards the mouse is not working.
      // vec2f old_mw = eye.screenToWorld(mvp, size);
      eye.zoom -= eye.zoom / 10.f * input.scroll;
      // vec2f new_mw = eye.screenToWorld(mvp, size);
      // eye.pos += old_mw - new_mw;
    }

    need_render = true;
  }

  if (need_render)
  {
    // renderMap(*ui);
  }

  io::StaticBuffer<512> text;
  io::formatv(&text,
    eye.pos,      " ",
    eye.rotation, " ",
    eye.zoom,     " ",
    mw,           " ",
    mvp,          " ",
    eye.worldToScreen(mw, size));

  world_pos->set(text.asStr());
}

/* ----------------------------------------------------------------------------
 */
void MapEditor::renderMap(UI& ui)
{
  if (!need_render)
    return;

  need_render = false;

  AssetMgr& assetmgr = ui.eng->assetmgr;
  BroadcastEventBus& broadcast = ui.eng->eventbus.broadcast;

  if (!h_selected_map.isValid())
    return;

  entmgr.destroyAllEntities();
  if (notnil(map.layers))
  {
    map.deinit();
    destroyPackedData(&mapdef);
  }

  renderer->bindFramebuffer(framebuffer);

  packSourceDataIntoType(
    *h_selected_map.getFile()->returned_data,
    &mapdef,
    assetmgr,
    *renderer);

  Map::InitParams map_params =
  {
    .assetmgr = assetmgr,
    .entmgr   = entmgr,
    .renderer = *renderer,
  };

  map.init(mapdef, map_params);

  RenderSys::UpdateParams params =
  {
    .viewport =
    {
      { s32(pos_screen.x), s32(pos_screen.y) },
      { s32(size.x), s32(size.y) },
    },
    .renderer = *renderer,
    .entmgr = &entmgr,
    .map = &map,
    .debug = true,
    .broadcast = &broadcast,
  };

  eye.getViewMat(&params.view);

  rendersys.update(params);

  renderer->bindFramebuffer({0});
  renderer->setViewport({0,0}, {ui.eng->window.size.x,ui.eng->window.size.y});
}

/* ----------------------------------------------------------------------------
 */
void MapEditor::onPreMapRender(PreMapRender& event)
{

}

/* ----------------------------------------------------------------------------
 */
void MapEditor::onPreSpriteRender(PreSpriteRender& event)
{
  auto* vp = (gfx::Vertex*)rendersys.external_vertex_buffer.mapped_data;
  auto* ip = (gfx::Index*)rendersys.external_index_buffer.mapped_data;

  // Draw grid lines.
  {
    // TODO(sushi) dynamically size lines relative to zoom and
    //             their separation.
    vec2f bl_world = floor(eye.screenToWorld({0.f, size.y}, size));
    vec2f tr_world = ceil(eye.screenToWorld({size.x, 0.f}, size));

    const f32 grid_line_width = 0.025f;
    const Color grid_line_color = 0xfb364066;

    for (f32 y = bl_world.y; y <= tr_world.y; y += 1.f)
    {
      rendersys.external_counts +=
        gfx::putLine(
          vp, ip,
          rendersys.external_counts,
          {tr_world.x, y},
          {bl_world.x, y},
          grid_line_width,
          grid_line_color);
    }

    for (f32 x = bl_world.x; x <= tr_world.x; x += 1.f)
    {
      rendersys.external_counts +=
        gfx::putLine(
          vp, ip,
          rendersys.external_counts,
          {x, tr_world.y},
          {x, bl_world.y},
          grid_line_width,
          grid_line_color);
    }
  }

  // Draw layer outlines.
  {
    for (const Layer& layer : map.layers)
    {
      rendersys.external_counts +=
        gfx::putBorders(
          vp, ip,
          rendersys.external_counts,
          {0.1f,0.1f,0.1f,0.1f},
          layer.def->pos,
          layer.def->size,
          0xdf99f0);
    }
  }
}

/* ----------------------------------------------------------------------------
 */
void MapEditor::onPostRender(PostRender& event)
{
}

/* ----------------------------------------------------------------------------
 */
void MapEditor::reportDrawCmds(UI* ui, DrawCmdList& pre, DrawCmdList& post)
{
  pre.push(map_render);
}

}
