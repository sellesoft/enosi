$ require "common"

@@lpp.import "game/server/NetMgr.lh"
@@lpp.import "game/shared/NetMgr.lh"
@@lpp.import "game/shared/Net.events.lh"

#include "iro/Common.h"
#include "iro/Logger.h"
#include "iro/memory/Allocator.h"

using namespace iro;
using namespace net;

@log.ger(sv.NetMgr, Info)

/* ----------------------------------------------------------------------------
 */
static void handleChallengeEvent(void* netmgr_ptr, ChallengeNetEvent& event)
{
  sv::NetMgr* netmgr = (sv::NetMgr*)netmgr_ptr;
  sv::NetMgr::Session* session = (sv::NetMgr::Session*)event.session;
  assertpointer(session);
  if (event.challenge_value == session->challenge_value)
  {
    session->connection.state = Connection::State::Connected;
    @log.info("CONNECTED [", session->connection.address, "]\n");

    ConnectionSuccessNetEvent connection_success_event = {
      .session = session,
    };
    netmgr->queueEvent(connection_success_event);
  }
}

/* ----------------------------------------------------------------------------
 */
static void handleMessageEvent(void* netmgr_ptr, MessageNetEvent& event)
{
  if (event.message_length > 0 && event.message_length < 513)
  {
    @log.info("Message Received: \"",
              String::from(event.message, event.message_length), "\"\n");
  }
}

/* ----------------------------------------------------------------------------
 */
static b8 handleConnectionlessPacket(
  void* server_ptr,
  Address address,
  Fragment& fragment)
{
  sv::NetMgr* netmgr = (sv::NetMgr*)server_ptr;

  //NOTE(delle) fragment length validated externally
  if (fragment.len < sizeof(CONNECTIONLESS_PROTOCOL_ID))
    return false;

  u64 connectionless_protocol_id = *(u64*)(fragment.arr);
  if (connectionless_protocol_id != CONNECTIONLESS_PROTOCOL_ID)
    return false;

  void* connectionless_data =
    fragment.arr + sizeof(CONNECTIONLESS_PROTOCOL_ID);
  u32 connectionless_data_size =
    fragment.len - sizeof(CONNECTIONLESS_PROTOCOL_ID);

  String connect_message = "connect"_str;
  if (   connectionless_data_size == connect_message.len
      && mem::equal(connectionless_data, connect_message.ptr,
                    connect_message.len))
  {
    sv::NetMgr::Session* free_session = nullptr;
    for (u16 i = 0; i < netmgr->sessions_capacity; i++)
    {
      sv::NetMgr::Session& session = netmgr->sessions[i];
      if (session.connection.address == address)
        return true; // skip extra connection requests from connected clients

      if (session.connection.state == Connection::State::Disconnected)
        free_session = &session;
    }

    if (netmgr->session_count >= netmgr->sessions_capacity)
    {
      String string = "server_full"_str;
      if (!netmgr->sendOnlinePacket(address, string.ptr, string.len))
        @log.error("Failed to send server full message\n");

      @log.info("Rejecting connection from ", address,
                " because the server is full\n");
      return true;
    }

    sv::NetMgr::Session* session = free_session;
    if (!session->connection.init(address, netmgr))
      return true;

    session->connection.state = Connection::State::Challenging;
    session->challenge_value = (u32)TimePoint::monotonic().ns;
    session->last_challenge_time = TimePoint::monotonic();
    netmgr->session_count++;
  }

  return true;
}

namespace sv
{

/* ----------------------------------------------------------------------------
 */
b8 NetMgr::init(
  mem::Allocator* allocator,
  PasswordBuffer& password,
  ServerPublicity publicity,
  u16 max_sessions)
{
  if (!SharedNetMgr::init(allocator))
    return false;

  this->sessions_capacity = max_sessions;
  this->sessions = allocator->allocateType<Session>(max_sessions);
  if (!this->sessions)
    return @log.error("failed to init the server sessions array\n");

  this->password.copy(password);
  this->publicity = publicity;
  if (publicity != ServerPublicity::Offline)
  {
    if (!this->bind(net::SERVER_PORT))
    {
      @log.error("failed to bind server port\n");
      return false;
    }
  }

  this->subscribeToEvent<ChallengeNetEvent>(this, handleChallengeEvent);
  this->subscribeToEvent<MessageNetEvent>(this, handleMessageEvent);

  return true;
}

/* ----------------------------------------------------------------------------
 */
void NetMgr::deinit()
{
  this->allocator->free(this->sessions);
  SharedNetMgr::deinit();
}

/* ----------------------------------------------------------------------------
 */
void NetMgr::receiveMessages()
{
  //NOTE(delle) lock before offline connection receive/send
  this->lockOfflinePacketMutex(Source::Client);
  defer { this->unlockOfflinePacketMutex(Source::Client); };

  // receive messages from clients
  if (this->publicity == ServerPublicity::Offline)
  {
    Fragment fragment;
    if (!this->receiveOfflinePacket(Source::Client, fragment))
      return;

    if (handleConnectionlessPacket(this, Address::createOffline(), fragment))
      return;

    if (this->session_count > 0)
      this->sessions[0].connection.receive(Source::Client, fragment);
  }
  else
  {
    Address packet_address;
    Fragment fragment;
    while (this->receiveOnlinePacket(packet_address, fragment))
    {
      // range validated in receiveOnlinePacket
      assertrange(fragment.len,
        sizeof(FragmentHeader), MAX_FRAGMENT_SIZE);

      b8 packet_handled = false;
      for (u16 i = 0; i < this->sessions_capacity; i++)
      {
        Session& session = this->sessions[i];
        if (session.connection.address == packet_address)
        {
          session.connection.receive(Source::Client, fragment);
          packet_handled = true;
          break;
        }
      }
      if (packet_handled)
        continue;

      handleConnectionlessPacket(this, packet_address, fragment);
    }
  }

  // parse messages from clients
  for (u16 i = 0; i < this->sessions_capacity; i++)
  {
    Session& session = this->sessions[i];
    if (session.connection.state == Connection::State::Disconnected)
      continue;
    if (session.connection.incoming_message_pending_fragments)
      continue;

    Message message;
    message.init(session.connection.incoming_message_data,
                session.connection.incoming_message_size);

    if (!this->parseEventsFromMessage(message, &session))
      @log.error("failed to parse network message\n");
  }

  // if a client has been disconencting for too long, disconnect it
  for (u16 i = 0; i < this->sessions_capacity; i++)
  {
    Session& session = this->sessions[i];
    if (session.connection.state == Connection::State::Disconnecting)
    {
      TimeSpan time_since_disconnect = TimePoint::monotonic()
                                      - session.last_challenge_time;
      if (time_since_disconnect.toMilliseconds() > 1000)
      {
        session.connection.deinit();
        this->session_count--;
      }
    }
  }
}

/* ----------------------------------------------------------------------------
 */
void NetMgr::sendMessages()
{
  //NOTE(delle) lock before offline connection receive/send
  this->lockOfflinePacketMutex(Source::Server);
  defer { this->unlockOfflinePacketMutex(Source::Server); };

  u8 message_data[Message::MAX_SIZE];
  for (u16 i = 0; i < this->sessions_capacity; i++)
  {
    Session& session = this->sessions[i];
    if (session.connection.state == Connection::State::Disconnected)
      continue;

    if (session.connection.state == Connection::State::Challenging)
    {
      TimeSpan time_since_challenge = TimePoint::monotonic()
                                    - session.last_challenge_time;
      if (time_since_challenge.toMilliseconds() > 1000)
      {
        //TODO(delle) drop connection if time since challenge is too long
        @log.info("CHALLENGE TIMED OUT [", session.connection.address, "]\n");
        session.connection.state = Connection::State::Disconnecting;
        session.last_challenge_time = TimePoint::monotonic();
        continue;
      }

      ChallengeNetEvent challenge_event = {
        .session = &session,
        .challenge_value = session.challenge_value,
      };
      this->queueEvent(challenge_event);
      session.last_challenge_time = TimePoint::monotonic();
      @log.info("CHALLENGED [", session.connection.address, "]\n");
    }

    Message message;
    message.init(message_data, 0);
    this->packEventsIntoMessage(message, &session);
    if (message.size == 0)
      continue;

    if (!message.writeOverflowed())
    {
      session.connection.send(Source::Server, message, false);
      if (session.connection.outgoing_message_pending_fragments)
        session.connection.sendNextFragment();
    }
    else
    {
      @log.error("Message overflow when packing events\n");
    }
  }
}

} // namespace sv