$ require "common"

@@lpp.import "game/client/editor/Editor.lh"

@@lpp.import "game/client/Client.lh"
@@lpp.import "game/client/editor/MenuBar.lh"
@@lpp.import "game/shared/Eye.sys.lh"

#include "math/util.h"

using namespace ui;

@log.ger(editor, Info)

namespace cl
{

/* ----------------------------------------------------------------------------
 */
b8 Editor::init(Client* client, AssetLoader& loader)
{
  this->client = client;

  if (!loader.load(&skin, "assets/skins/Editor.skin"_str))
    return ERROR("failed to load editor skin\n");

  return true;
}

/* ----------------------------------------------------------------------------
 */
void Editor::deinit()
{
}

/* ----------------------------------------------------------------------------
 */
b8 Editor::update(UI& ui, cl::GameSim& sim)
{
  if (!paused)
  {
    InputState sim_input = {};
    client->input.cloneInputState(&sim_input);

    cl::GameSim::UpdateParams sim_params = 
    {
      .input = sim_input,
    };

    if (!sim.update(sim_params))
      return ERROR("failed to update game sim\n");
  }

  if (!sim.render(client->renderer, view))
    return ERROR("failed to render game sim\n");

  InputState ui_input = {};
  client->input.cloneInputState(&ui_input);

  // Make sure that UI doesn't get any mouse input when dragging the view.
  if (control_state == ControlState::Dragging)
    ui_input.consumeAllMouseButtons();

  ui::UI::FrameParams ui_params = 
  {
    .input = ui_input,
    .viewport = Rect::from(vec2f(0,0), vec2f(client->window.size)),
  };

  ui.beginFrame(ui_params);

  if (ui.putButton(
        "pause"_fid, 
        {0.f, 0.f, 80.f, 20.f}, 
        "pause"_str, 
        skin->button))
  {
    paused = !paused;
  }

  InputState game_input = {};

  ui.endFrame(&game_input);

  switch (control_state)
  {
  case ControlState::None:
    if (game_input.tryConsumePressedMouseButton(MouseButton::Left))
    {
      drag_start_viewport = game_input.getCursorPos();
      drag_start_world = view.pos;
      control_state = ControlState::Dragging;
    }
    break;

  case ControlState::Dragging:
    {
      vec2f cursor_world = view.viewportPointToWorld(
        game_input.getCursorPos(),
        vec2f(client->window.size));

      vec2f offset = view.viewportPointToWorld(
        drag_start_viewport,
        vec2f(client->window.size));

      view.pos = drag_start_world + offset - cursor_world;

      if (game_input.wasMouseButtonReleased(MouseButton::Left))
        control_state = ControlState::None;
    }
    break;
  }

  f32 scroll = game_input.getScroll();
  if (scroll != 0.f)
  {
    game_input.consumeScroll();

    if (game_input.tryConsumeDownKey(Key::LShift))
    {
      view.rotation += scroll * math::degreesToRadians(1.f);
    }
    else
    {
      vec2f old_cw = view.viewportPointToWorld(
        game_input.getCursorPos(), vec2f(client->window.size));

      view.zoom -= view.zoom / 10.f * scroll;

      vec2f new_cw = view.viewportPointToWorld(
        game_input.getCursorPos(), vec2f(client->window.size));

      view.pos -= new_cw - old_cw;
    }
  }

  if (game_input.wasKeyPressed(Key::F10))
  {
    // Reset view to the game's incase it gets messed up too much.
    // TODO(sushi) make other ways to do this.
    view = sim.gamemgr.entsysmgr.get<EyeSys>().view;
  }

  INFO(view.zoom, '\n');
  
  return true;
}

/* ----------------------------------------------------------------------------
 */


}
