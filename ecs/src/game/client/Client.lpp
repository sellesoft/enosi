/*
 *  Definition of the Client, as well as its interface.
 *
 *  TODO(sushi) move the client-specific stuff from Engine into here, such
 *              as the Renderer, since the server should never use it.
 */

$ require "common"
$ local ui = require "ui.UI"

@@lpp.import "game/client/Client.lh"

@@lpp.import "game/client/GameSim.lh"

@@lpp.import "game/server/Server.lh"

@@lpp.import "Engine.lh"

@@lpp.import "ui/UI.lh"
@@lpp.import "graphics/Renderer.lh"
@@lpp.import "input/InputMgr.lh"
@@lpp.import "graphics/Ref.defs.lh"
@@lpp.import "net/Net.events.lh"

@log.ger(client, Debug)

/* ----------------------------------------------------------------------------
 */
static void handleChallengeEvent(void* client_ptr, ChallengeNetEvent& event)
{
  Client* client = (Client*)client_ptr;
  client->challenge_value = event.challenge_value;
  client->connection.state = net::Connection::State::Challenging;
}

/* ----------------------------------------------------------------------------
 */
static void handleMessageEvent(void* client_ptr, MessageNetEvent& event)
{
  if (event.message_length > 0 && event.message_length < 513)
  {
    io::StaticBuffer<512> string_buffer;
    string_buffer.len = event.message_length;
    mem::copy(string_buffer.buffer, event.message, event.message_length);
    @log.info("Message Received: \"", string_buffer, "\"\n");
  }
}


/* ----------------------------------------------------------------------------
 */
b8 Client::init(Engine* engine)
{
  this->engine = engine;

  connection.address.type = net::AddressType::Invalid;

$ local function init(act, name)
  {
    auto start = TimePoint::monotonic();
    if (!$(act))
      return FATAL("failed to initialize $(name)\n");
    INFO("finished initializing ", color::cyan("$(name)"), " in ",
         WithUnits(TimePoint::monotonic() - start), "\n");
  }
$ end

  @init(input.init(), InputMgr);

  @init(Window::initializeBackend(), Window backend);
  @init(window.init("ecs"_str, input), Window);

  gfx::Renderer::InitParams renderer_params =
  {
    .assetmgr  = engine->assetmgr,
    .window    = window,
    .allocator = mem::stl_allocator,
  };
  @init(renderer.init(renderer_params), Renderer);

  // TODO(sushi) this is dumb, get rid of it by just making the texture
  //             manually through gfx::Texture.
  gfx::CompiledTexture::CompileParams white_texture_params =
  {
    .name         = "assets/textures/white"_str,
    .width        = 2,
    .height       = 2,
    .format       = gfx::ImageFormat::BW,
    .usage        = gfx::ImageUsage::Sampled,
    .filter       = gfx::ImageFilter::Nearest,
    .address_mode = gfx::ImageAddressMode::ClampToWhite,
    .allocator    = &mem::stl_allocator,
    .assetmgr     = &engine->assetmgr,
  };

  u8 pixels[16] =
  {
    0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff,
  };

  gfx::CompiledTexture::compileFromMemory(pixels, white_texture_params);

  auto* white_texture_compiled =
    gfx::CompiledTexture::load(
      "assets/textures/white"_str, engine->assetmgr, renderer);
  if (white_texture_compiled == nullptr)
    return ERROR("failed to load white texture\n");
  white_texture = white_texture_compiled->gfx_texture;

  AssetLoader asset_loader =
  {
    .renderer = renderer,
    .assetmgr = engine->assetmgr,
    .sfilereg = engine->source_data_file_reg,
  };

  // ui::UI::InitParams ui_params = 
  // {
  //   .assetmgr = engine->assetmgr,
  //   .renderer = renderer,
  //
  //   .white_texture = white_texture,
  //
  //   .viewport = Rect::from({0,0}, window.size),
  //
  //   .loader   = asset_loader,
  // };
  // \@init(ui.init(ui_params), UI);

  SourceDataFileHandle hskin = 
    asset_loader.sfilereg.loadFromDisk("assets/skins/Test.skin"_str);

  SourceDataFile* fskin = hskin.getFile();

  fskin->returned_data->dump();

  ui::UI::InitParams ui_params = 
  {
    .assetmgr = engine->assetmgr,
    .renderer = renderer,

    .white_texture = white_texture,

    .loader = asset_loader,
  };
  @init(ui.init(ui_params), UI);

  cl::GameSim::InitParams sim_params =
  {
    .loader   = asset_loader,
    .viewport = Rect::from({0,0}, window.size),
    .renderer = renderer,
    .assetmgr = engine->assetmgr,
    .sfilereg = engine->source_data_file_reg,
  };
  @init(sim.init(sim_params), cl::GameSim);

  // \@init(editor.init(this), Editor);

  asset_loader.load(&test_skin, "assets/skins/Test.skin"_str);

  this->net_event_bus.init(&mem::stl_allocator);
  this->net_event_bus.subscribe<ChallengeNetEvent>(this, handleChallengeEvent);
  this->net_event_bus.subscribe<MessageNetEvent>(this, handleMessageEvent);

  return true;
}

/* ----------------------------------------------------------------------------
 */
static void receiveNetMessages(Client* client)
{
  assertpointer(client);

  net::Connection& connection = client->connection;
  if (connection.address.type == net::AddressType::Offline)
  {
    //NOTE(delle) lock during offline packet processing
    net::lockOfflinePacketMutex(net::Source::Server);
    defer { net::unlockOfflinePacketMutex(net::Source::Server); };

    net::Fragment fragment;
    connection.receive(net::Source::Server, fragment);
    if (connection.incoming_message_pending_fragments)
      return;
    @log.trace("received packet from [offline]\n");

    net::Message message;
    message.init(connection.incoming_message_data,
                connection.incoming_message_size);
    if (!client->net_event_bus.parseMessage(message, client))
      @log.error("failed to parse network message\n");
  }
  else
  {
    net::Address packet_address;
    net::Fragment fragment;
    while (net::receiveOnlinePacket(packet_address, fragment))
    {
      // range validated in net::receiveOnlinePacket
      assertrange(fragment.len,
        sizeof(net::FragmentHeader), net::MAX_FRAGMENT_SIZE);

      if (!mem::equal(connection.address, packet_address))
        continue;

      connection.receive(net::Source::Server, fragment);
      if (connection.incoming_message_pending_fragments)
        continue;
      @log.trace("received packet from ", connection.address, "\n");

      net::Message message;
      message.init(connection.incoming_message_data,
                  connection.incoming_message_size);
      if (!client->net_event_bus.parseMessage(message, client))
        @log.error("failed to parse network message\n");
    }
  }
}

/* ----------------------------------------------------------------------------
 */
static void sendNetMessages(Client* client)
{
  assertpointer(client);

  //NOTE(delle) lock before offline connection receive/send
  if (client->connection.address.type == net::AddressType::Offline)
  {
    net::lockOfflinePacketMutex(net::Source::Client);
    defer { net::unlockOfflinePacketMutex(net::Source::Client); };
  }

  net::Connection& connection = client->connection;
  if (connection.state == net::Connection::State::Connected)
  {
    u8 message_data[net::Message::MAX_SIZE];
    net::Message message;
    message.init(message_data, 0);
    client->net_event_bus.packEvents(message);
    if (!message.writeOverflowed())
    {
      connection.send(net::Source::Client, message, false);
      if (connection.outgoing_message_pending_fragments)
        connection.sendNextFragment();
    }
    else
    {
      @log.error("message overflow when packing events\n");
    }
  }
  else if (connection.state == net::Connection::State::Challenging)
  {
    TimeSpan time_since_challenge = TimePoint::monotonic()
                                  - client->last_challenge_time;
    if (time_since_challenge.toMilliseconds() > 1000)
    {
      //TODO(delle) drop connection if time since challenge is too long
      @log.info("CHALLENGE TIMED OUT [", connection.address, "]\n");
      return;
    }

    u8 message_data[256]; // TODO(delle) fix this hardcoded size
    net::Message message;
    message.init(message_data, 0);

    ChallengeNetEvent challenge_event = {
      .challenge_value = client->challenge_value,
    };
    client->net_event_bus.queue(challenge_event);
    
    client->net_event_bus.packEvents(message);
    if (!message.writeOverflowed())
    {
      connection.send(net::Source::Client, message, true);
      if (connection.outgoing_message_pending_fragments)
        connection.sendNextFragment();
    }
    else
    {
      @log.error("message overflow when packing events\n");
    }

    @log.info("CHALLENGING [", connection.address, "]\n");
    client->last_challenge_time = TimePoint::monotonic();
  }
  else
  {
    assert(connection.state == net::Connection::State::Connecting);

    auto time_since_challenge = TimePoint::monotonic()
                              - client->last_challenge_time;
    if (time_since_challenge.toMilliseconds() > 1000)
    {
      u8 message_data[64];
      net::Message message;
      message.init(message_data, 0);

      message.writeU64(net::CONNECTIONLESS_PROTOCOL_ID);
      iro::String string = "connect"_str;
      message.writeData(string.ptr, string.len);
      //TODO(delle) password

      if (!connection.send(net::Source::Client, message, true))
        @log.error("failed to send challenge message\n");

      @log.info("CONNECTING [", connection.address, "]\n");
      client->last_challenge_time = TimePoint::monotonic();
    }
  }
}

/* ----------------------------------------------------------------------------
 */
b8 Client::update()
{
  // Prepares input state for this frame.
  if (!input.update())
    return ERROR("failed to update input\n");

  // Handles OS window events and notifies the inputmgr about any input
  // events.
  if (!window.update(input))
    return ERROR("failed to update window\n");

  // Check for and parse incoming packets.
  if (connection.address.type != net::AddressType::Invalid)
    receiveNetMessages(this);

  gfx::Renderer::UpdateParams renderer_params =
  {
    .window = window,
  };

  if (!renderer.update(renderer_params))
    return ERROR("failed to update renderer\n");

  InputState sim_input = {};
  input.cloneInputState(&sim_input);

  cl::GameSim::UpdateParams sim_params =
  {
    .input = sim_input,
  };

  if (!sim.update(sim_params))
    return ERROR("failed to update game sim\n");

  if (!sim.render(renderer))
    return ERROR("failed to render game sim\n");

  InputState ui_input = {};
  input.cloneInputState(&ui_input);

  ui::UI::FrameParams ui_params = 
  {
    .input = ui_input,
    .viewport = Rect::from(vec2f(0,0), window.size),
  };

  ui.beginFrame(ui_params);
  {
    ui.pushLayer("layer0"_fid, {10.f, 10.f, 50.f, 30.f}, {});
    {
      if (ui.putButton(
            "test"_fid, 
            {10.f, 10.f, 35.f, 15.f}, 
            "hello"_str, 
            test_skin->button))
      {
        INFO("hello\n");
      }
    }
    ui.popLayer();

    ui.pushLayer("layer1"_fid, { 10.f, 40.f, 50.f, 30.f}, {});
    {
      if (ui.putButton(
            "test"_fid, 
            {10.f, 10.f, 35.f, 15.f}, 
            "goodbye"_str, 
            test_skin->button))
      {
        INFO("goodbye\n");
      }
    }
    ui.popLayer();

    if (ui.putButton(
          "test"_fid, 
          {10.f, 15.f, 50.f, 30.f}, 
          "blah"_str, 
          test_skin->button))
    {
      INFO("blah\n");
    }
  }
  ui.endFrame();

  // Send messages to the server.
  if (connection.address.type != net::AddressType::Invalid)
    sendNetMessages(this);

  return true;
}

/* ----------------------------------------------------------------------------
 */
b8 Client::wantHotReload()
{
  // TODO(sushi) do this some other way later.
  // if (input.real_state.wasKeyPressed(Key::R))
  //   return true;
  return false;
}

/* ----------------------------------------------------------------------------
 */
b8 Client::connectToServer(net::Address address)
{
  @log.trace("connecting to a server\n");
  if (address.type == net::AddressType::Invalid)
    return @log.error("invalid address\n");

  if (address.type == net::AddressType::Offline)
  {
    sv::CreateParams server_params =
    {
      .engine = *this->engine,
      .global_allocation_size = unit::megabytes(1),
      .match_allocation_size = unit::megabytes(1),
      .tick_allocation_size = unit::megabytes(2),
      .target_tickrate_ms = 48,
      .publicity = sv::ServerPublicity::Offline,
      .max_sessions = 1,
      .password = {},
    };
    engine->server_thread = sv::create(server_params);
    if (engine->server_thread == nullptr)
      return FATAL("failed to create server thread\n");
  }

  // TODO(delle) client allocators
  if(!connection.init(address, &mem::stl_allocator))
    return @log.error("failed to initialize connection\n");
  connection.state = net::Connection::State::Connecting;
  last_challenge_time = TimePoint::monotonic();
  return true;
}

/* ----------------------------------------------------------------------------
 */
void Client::disconnectFromServer()
{
  if (connection.address.type == net::AddressType::Offline)
    sv::destroy(engine->server_thread);
  connection.deinit();
}