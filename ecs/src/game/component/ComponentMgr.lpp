$ local cmn = require "common"
$ local buffer = require "string.buffer"
$ local glob = require "Glob"
$ local ast = require "reflect.AST"

$ local comp = require "game.component.Component"
$ local comps = comp.importComponents()
@@comps:get

#include "iro/Logger.h"
#include "iro/containers/LinkedPool.h"

using namespace iro;

@cmn.defFileLogger(compmgr, Info)

@@lpp.import "ComponentMgr.lh"

$ local TComponent = comps.p.decls.map["struct Component"]
$ local function eachComp(f)
$   comps:eachDecl(function(name, decl)
$     if decl:is(ast.Record) and decl:isDerivedFrom(TComponent) then
$       f(name, decl)
$     end
$   end)
$ end

/* ============================================================================
 */
struct CompPools
{

$ eachComp(function(name, decl)
  DLinkedPool<$(name)> $(name)_pool;
$ end)

  b8 init()
  {
$ eachComp(function(name, decl)
    if (!$(name)_pool.init())
      return ERROR("failed to init $(name) component pool\n");
$ end)
    return true;
  }

  void deinit()
  {
$ eachComp(function(name, decl)
    for (Component& comp : $(name)_pool)
    {
      comp.kind = 0;
      comp.owner = nil;
    }
    $(name)_pool.deinit();
$ end)
  }

  template<typename T>
  T* allocateComponent();
};

$ eachComp(function(name, decl)

/* ----------------------------------------------------------------------------
 */
template<>
$(name)* ComponentMgr::allocateComponent<$(name)>()
{
  auto* node = pools->$(name)_pool.pushHead();
  auto* cmp = node->data;
  cmp->node = node;
  Component::onCreate<$(name)>(cmp);
  return cmp;
}


/* ----------------------------------------------------------------------------
 */
template<>
ComponentIter<$(name)> ComponentMgr::iterate<$(name)>()
{
  return ComponentIter<$(name)>{pools->$(name)_pool.headNode()};
}

$ end)

/* ----------------------------------------------------------------------------
 */
void ComponentMgr::deallocateComponent(Component* cmp)
{
  switch (cmp->kind)
  {
$ eachComp(function(name, decl)
  case "$(name)"_hashed:
    pools->$(name)_pool.remove(
      (DLinkedPool<$(name)>::Node*)cmp->node);
    break;
$ end)
  }
}

/* ----------------------------------------------------------------------------
 */
b8 ComponentMgr::init()
{
  pools = mem::stl_allocator.construct<CompPools>();

  if (!pools->init())
    return false;

  return true;
}

/* ----------------------------------------------------------------------------
 */
void ComponentMgr::deinit()
{
  pools->deinit();
  mem::stl_allocator.deconstruct(pools);
}

