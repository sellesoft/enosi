/*
 *  Base of Entity systems.
 */

$ require "common"

@@lpp.import "game/entity/EntityMgr.lh"
@@lpp.import "game/entity/EntityEventBus.lh"

/* ============================================================================
 */
struct EntitySystem
{
  EntityMgr* entmgr;

  template<typename T>
  b8 init_entsys(EntityMgr* emgr)
  {
    entmgr = emgr;
    ((T*)this)->init();
    return true;
  }

  template<typename TComp, typename TEvent, typename TSys>
  void subscribeTo(void (TSys::* cb)(EntComp<TComp>,TEvent&))
  {
    // Evil magic necessary to convince clang that passing this
    // as the sub of the callback is ok.
    static union
    {
      void (TSys::* x)(EntComp<TComp>, TEvent&);
      void (*y)(void*, EntComp<TComp>, TEvent&);
    } x { cb };

    entmgr->eventbus.subscribeTo<TComp,TEvent>(this, x.y);
  }

  template<typename TEvent, typename TSys>
  void subscribeTo(void (TSys::* cb)(TEvent&))
  {
    // Evil magic necessary to convince clang that passing this
    // as the sub of the callback is ok.
    static union
    {
      void (TSys::* x)(TEvent&);
      void (*y)(void*, TEvent&);
    } x { cb };

    entmgr->eventbus.subscribeTo<TEvent>(this, x.y);
  }

  template<typename TEvent>
  void raise(EntityId id, TEvent& event)
  {
    entmgr->eventbus.raise(id, event);
  }

  template<typename TEvent>
  void raise(EntityId id, TEvent&& event)
  {
    raise(id, event);
  }

  template<typename TEvent>
  void raise(TEvent& event)
  {
    entmgr->eventbus.raise(event);
  }

  template<typename TEvent>
  void raise(TEvent&& event) { raise<TEvent>(event); }

  // template<typename TEvent, typename TSys>
  // void subscribeTo(void (TSys::* cb)(TEvent&))
  // {
  //   // Evil magic necessary to convince clang that passing this
  //   // as the sub of the callback is ok.
  //   static union
  //   {
  //     void (TSys::* x)(TEvent&);
  //     void (*y)(void*, TEvent&);
  //   } x { cb };
  //
  //   // TODO(sushi) obviously not a fan of this, but we need ent systems to be 
  //   //             able to raise and subscribe to events that aren't related
  //   //             to a specific entity containing a component. We should 
  //   //             probably support these kinds of events in the entity event
  //   //             bus but I don't feel like setting that up at the moment.
  //   entmgr->gamemgr->engine->eventbus.broadcast.subscribeTo<TEvent>(this, cb);
  // }
  //
  // template<typename TEvent>
  // void raise(TEvent& event)
  // {
  //   entmgr->gamemgr->engine->eventbus.broadcast.raise(event);
  // }

  template<typename TComp>
  TComp* tryComp(EntityId id) { return entmgr->tryComp<TComp>(id); }

  template<typename TComp, typename X>
  TComp* tryComp(EntComp<X> id) { return entmgr->tryComp<TComp>(id); }

  template<typename TComp>
  ComponentIter<TComp> iterateComp()
  {
    return entmgr->cmpmgr.iterate<TComp>();
  }
};

