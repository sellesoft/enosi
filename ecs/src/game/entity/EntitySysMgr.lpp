$ local cmn = require "common"
$ local ast = require "reflect.AST"

$ local TEntSys
$$$
local importer = require "reflect.Importer"
{
  patterns = { "src/**/*.sys.lh" },

  filter = function(p, decl)
    TEntSys = p.processed_clang_objs["struct EntitySystem"]
    if TEntSys then
      if decl:is(ast.Record) and decl:isDerivedFrom(TEntSys) then
        return true
      end
    end
  end,
}
$$$
@@importer:get

@@lpp.import "game/entity/EntitySysMgr.lh"

#include "iro/Logger.h"
#include "iro/time/Time.h"

@log.ger(entsysmgr, Debug)

$ local function isSys(decl)
$   if decl:is(ast.Record) and decl:isDerivedFrom(TEntSys) then
$     return true
$   end
$ end

$ local systems_by_canonical_name = {}
$ local systems = cmn.List{}
$ importer:eachDecl(function(name, decl)
$   if isSys(decl) then
$     local system = 
$     {
$       name = name:match("([%w_]-)Sys"):lower(),
$       typename = name,
$       decl = decl,
$     }
$     systems_by_canonical_name[decl.name] = system
$     systems:push(system)
$   end
$ end)

/* ============================================================================
 */
struct EntitySystems
{
$ systems:each(function(sys)
  $(sys.typename) $(sys.name);
$ end)
};

/* ----------------------------------------------------------------------------
 */
b8 EntitySysMgr::init(EntityMgr* entmgr)
{
  INFO("initializing entity systems...\n");
  auto init_start = TimePoint::now();

  systems = mem::stl_allocator.allocateType<EntitySystems>();
  mem::zero(systems, sizeof(EntitySystems));

  INFO("allocated ", color::green(io::ByteUnits(sizeof(EntitySystems))), 
       " for systems\n");

$ systems:each(function(sys)
$   if not sys.decl:hasMethod "init" then
$     error("system "..sys.typename.." is missing an 'init' function")
$   end
  $(sys.typename) $(sys.name) = 
  {
    {.entmgr = entmgr,},
$   for field in sys.decl:eachFieldWithIndex() do
$     local is_ptr = field.type:is(ast.PointerType) 
$     local is_ref = field.type:is(ast.ReferenceType) 
$     if is_ptr or is_ref then
$       local decl = field.type.subtype:getDecl()
$       if decl and isSys(decl) then
$         local sysname = 
$           "systems->"..systems_by_canonical_name[decl.name].name
$         if is_ptr then
    .$(field.name) = &$(sysname),
$         elseif is_ref then
    .$(field.name) = $(sysname),
$         end
$       end
$     end
$   end
  };
  mem::copy(&systems->$(sys.name), &$(sys.name), sizeof($(sys.typename)));
$ end)

  TimePoint sys_init_start;

$ systems:each(function(sys)
  sys_init_start = TimePoint::now();
  if (!systems->$(sys.name).init())
    return false;
  INFO("initialized ", color::cyan("$(sys.typename)"_str), " in ", 
       WithUnits(TimePoint::now() - sys_init_start), "\n");
$ end)

  return true;
}

/* ----------------------------------------------------------------------------
 */
b8 EntitySysMgr::update()
{
$ systems:each(function(sys)
$   if sys.decl:hasMethod "update" then
  systems->$(sys.name).update();
$   end
$ end)
  return true;
}

$ systems:each(function(sys)
/* ----------------------------------------------------------------------------
 */
template<>
$(sys.typename)& EntitySysMgr::get()
{
  return systems->$(sys.name);
}
$ end)

