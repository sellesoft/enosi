$ require "common"
$ require "Log"

@@lpp.import "graphics/RendererInternal.lh"

@@lpp.import "asset/AssetMgr.lh"
@@lpp.import "Engine.lh"
@@lpp.import "graphics/Renderer.lh"
@@lpp.import "window/Window.lh"
@@lpp.import "window/Window.events.lh"
@@lpp.import "graphics/Vulkan.lh"
@@lpp.import "graphics/Pipeline.lh"
@@lpp.import "graphics/RenderTarget.lh"

#include "iro/Logger.h"
#include "Color.h"

@log.ger(gfx, Info)

namespace gfx
{

/* ----------------------------------------------------------------------------
 */
b8 Renderer::init(InitParams& params)
{
  vk = params.allocator.allocateType<Vulkan>();
  mem::zero(vk, sizeof(Vulkan));

  mem::LenientBump init_allocator;
  init_allocator.init();
  defer { init_allocator.deinit(); };

  Vulkan::InitParams vk_params = 
  {
    .allocator = &params.allocator,
    .temp_allocator = init_allocator,
    .window = params.window,
  };

  if (!vk->init(vk_params))
    return ERROR("failed to initialize Vulkan\n");

  if (!resource_mgr.init())
    return ERROR("failed to initialize resource manager\n");

  DescriptorSetLayout::Binding ubo_binding = 
  {
    .binding = 0,
    .count = 1,
    .kind = DescriptorKind::UniformBuffer,
    .stages = ShaderStage::Vertex | ShaderStage::Fragment,
  };

  default_ubo_set_layout = DescriptorSetLayout::create(
    *this,
    makeSlice(&ubo_binding, 1),
    "default ubo"_str);

  if (isnil(default_ubo_set_layout))
    return ERROR("failed to create default uniform buffer descriptor set "
                 "layout\n");

  DescriptorSetLayout::Binding sampler_binding = 
  {
    .binding = 0,
    .count = 1,
    .kind = DescriptorKind::CombinedImageSampler,
    .stages = ShaderStage::Fragment,
  };

  default_sampler_set_layout = DescriptorSetLayout::create(
    *this,
    makeSlice(&sampler_binding, 1),
    "default sampler"_str);

  if (isnil(default_sampler_set_layout))
    return ERROR("failed to create default sampler descriptor set layout\n");

  return true;
}

/* ----------------------------------------------------------------------------
 */
static VkClearValue colorToVkClearValue(Color color)
{
  VkClearValue clear_value = {};
  clear_value.color.uint32[0] = color.r;
  clear_value.color.uint32[1] = color.g;
  clear_value.color.uint32[2] = color.b;
  clear_value.color.uint32[3] = color.a;
  return clear_value;
}

/* ----------------------------------------------------------------------------
 */
static b8 beginRenderPassVk(
    Vulkan*     vk,
    vec2i       render_area_pos,
    vec2u       render_area_size,
    VkImage     image,
    VkImageView view,
    Color       clear_color)
{
  if (vk->state.command_buffer != VK_NULL_HANDLE)
    return ERROR("attempt to start a render pass while one is already "
                 "active\n");

  vk->state.command_buffer = vk->command_buffer;
  
  VkRect2D render_rect = 
  {
    .offset = 
    {
      .x = render_area_pos.x,
      .y = render_area_pos.y,
    },
    .extent = 
    {
      .width = render_area_size.x,
      .height = render_area_size.y,
    },
  };

  // NOTE(sushi) the image transition occurs inside this function, however
  //             that should probably be pulled out and done here.
  vk->cmdBeginRendering(
    vk->state.command_buffer,
    render_rect,
    image,
    view,
    colorToVkClearValue(clear_color));

  return true;
}

/* ----------------------------------------------------------------------------
 */
b8 Renderer::beginRenderPass(
    vec2i render_area_pos,
    vec2u render_area_size,
    RenderTarget target,
    Color clear_color)
{
  if (isnil(target.image))
    return ERROR("attempt to begin a render pass with a nil target\n");

  if (isnil(target.view))
    return ERROR("attempt to begin a render pass with a nil target\n view");

  return beginRenderPassVk(
    vk,
    render_area_pos,
    render_area_size,
    ((DeviceImage*)target.image.handle)->handle,
    (VkImageView)target.view.handle,
    clear_color);
}

/* ----------------------------------------------------------------------------
 */
b8 Renderer::beginRenderPassOverSwapchainImage(
    vec2i render_area_pos,
    vec2u render_area_size,
    Color clear_color)
{
  // TODO(sushi) this is probably not how we want to do this.
  u32 next_image = vk->acquireNextImageIndex();

  return beginRenderPassVk(
    vk,
    render_area_pos,
    render_area_size,
    vk->swapchain_buffers[next_image].image,
    vk->swapchain_buffers[next_image].view,
    clear_color);
}

/* ----------------------------------------------------------------------------
 */
void Renderer::endRenderPass()
{
  if (vk->state.command_buffer == VK_NULL_HANDLE)
  {
    ERROR("attempt to end a render pass outside a render pass instance\n");
    return;
  }

  vk->cmdEndRendering(vk->state.command_buffer);
  vk->state.command_buffer = VK_NULL_HANDLE;
}

/* ----------------------------------------------------------------------------
 */
void Renderer::setScissor(vec2i pos, vec2u size)
{
  TRACE("setting scissor to ", pos, ' ', size, "\n");

  VkRect2D scissor = 
  {
    .offset = 
    {
      .x = pos.x,
      .y = pos.y,
    },
    .extent = 
    {
      .width = size.x,
      .height = size.y,
    }
  };

  vkCmdSetScissor(vk->command_buffer, 0, 1, &scissor);
}

/* ----------------------------------------------------------------------------
 */
void Renderer::setViewport(vec2f pos, vec2f size)
{
  TRACE("setting viewport to ", pos, ' ', size, '\n');

  VkViewport viewport = 
  {
    .x = pos.x,
    .y = pos.y,
    .width = size.x,
    .height = size.y,
    .minDepth = 0.f,
    .maxDepth = 1.f,
  };

  vkCmdSetViewport(vk->command_buffer, 0, 1, &viewport);
}

/* ----------------------------------------------------------------------------
 */
void Renderer::bindPipeline(Pipeline pipeline)
{
  if (isnil(pipeline))
  {
    ERROR("attempt to bind nil gfx::Pipeline\n");
    return;
  }

  DevicePipeline* dpipeline = vk->pipeline_pool.get(pipeline.index);

  if (dpipeline == vk->state.bound_pipeline)
    // Already bound.
    return;

  TRACE("binding ", pipeline, '\n');

  vkCmdBindPipeline(
    vk->command_buffer, 
    VK_PIPELINE_BIND_POINT_GRAPHICS,
    dpipeline->pipeline);
}

/* ----------------------------------------------------------------------------
 */
void Renderer::bindDescriptorSet(u32 set_idx, DescriptorSet set)
{
  if (isnil(set))
  {
    ERROR("attempt to bind nil gfx::DescriptorSet\n");
    return;
  }

  if (vk->state.bound_pipeline == nullptr)
  {
    ERROR("attempt to bind a gfx::DescriptorSet before binding a pipeline\n");
    return;
  }

  vkCmdBindDescriptorSets(
    vk->state.command_buffer,
    VK_PIPELINE_BIND_POINT_GRAPHICS,
    vk->state.bound_pipeline->layout,
    set_idx,
    1,
    &(VkDescriptorSet&)set.handle,
    0,
    nullptr);
}

/* ----------------------------------------------------------------------------
 */
void Renderer::bindVertexBuffer(Buffer buffer)
{
  if (isnil(buffer))
  {
    ERROR("attempt to bind a nil gfx::Buffer as a vertex buffer\n");
    return;
  }

  VkDeviceSize offset = 0;
  vkCmdBindVertexBuffers(
    vk->state.command_buffer,
    0,
    1,
    &(VkBuffer&)((DeviceBuffer*)buffer.handle)->handle,
    &offset);
}

/* ----------------------------------------------------------------------------
 */
void Renderer::bindIndexBuffer(Buffer buffer)
{
  if (isnil(buffer))
  {
    ERROR("attempt to bind a nil gfx::Buffer as an index buffer\n");
    return;
  }

  vkCmdBindIndexBuffer(
    vk->state.command_buffer,
    (VkBuffer)((DeviceBuffer*)buffer.handle)->handle,
    0,
    VK_INDEX_TYPE_UINT32);
}

/* ----------------------------------------------------------------------------
 */
void Renderer::bindUniformBuffer(Buffer buffer)
{
  if (isnil(buffer))
  {
    ERROR("attempt to bind a nil gfx::Buffer as a uniform buffer\n");
    return;
  }

  vkCmdBindDescriptorSets(
    vk->state.command_buffer,
    VK_PIPELINE_BIND_POINT_GRAPHICS,
    vk->state.bound_pipeline->layout,
    0,
    1,
    &((DeviceBuffer*)buffer.handle)->set,
    0,
    nullptr);
}

/* ----------------------------------------------------------------------------
 */
void Renderer::pushConstant(
    void* data, 
    u32 size, 
    u32 offset,
    ShaderStage stage)
{
  if (data == nullptr)
  {
    ERROR("data pointer passed to pushConstant is null\n");
    return;
  }

  if (size == 0)
  {
    ERROR("size passed to pushConstant is 0\n");
    return;
  }

  if (vk->state.bound_pipeline == nullptr)
  {
    ERROR("attempt to push a constant before binding a pipeline\n");
  }
  
  vkCmdPushConstants(
    vk->state.command_buffer,
    vk->state.bound_pipeline->layout,
    shaderStageToVulkan(stage),
    offset,
    size,
    data);
}

/* ----------------------------------------------------------------------------
 */
void Renderer::draw(u32 index_start, u32 index_count, u32 vertex_start)
{
  vkCmdDrawIndexed(
    vk->state.command_buffer,
    index_count,
    1,
    index_start,
    vertex_start,
    0);
}

/* ----------------------------------------------------------------------------
 */
void Renderer::debugBeginLabel(Color color, String label)
{
  if (vk->func_vkCmdBeginDebugUtilsLabelEXT != nullptr)
  {
    vec4f fcol = color.asVec4Norm();
    
    VkDebugUtilsLabelEXT info = 
    {
      .sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT,
      .pLabelName = (char*)label.ptr,
      .color = { fcol.x, fcol.y, fcol.z, fcol.w },
    };
    vk->func_vkCmdBeginDebugUtilsLabelEXT(vk->state.command_buffer, &info);
  }
}

/* ----------------------------------------------------------------------------
 */
void Renderer::debugEndLabel()
{
  if (vk->func_vkCmdEndDebugUtilsLabelEXT != nullptr)
  {
    vk->func_vkCmdEndDebugUtilsLabelEXT(vk->state.command_buffer);
  }
}

/* ----------------------------------------------------------------------------
 */
void Renderer::debugInsertLabel(Color color, String label)
{
  if (vk->func_vkCmdInsertDebugUtilsLabelEXT != nullptr)
  {
    vec4f fcol = color.asVec4Norm();
    
    VkDebugUtilsLabelEXT info = 
    {
      .sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT,
      .pLabelName = (char*)label.ptr,
      .color = { fcol.x, fcol.y, fcol.z, fcol.w },
    };
    vk->func_vkCmdInsertDebugUtilsLabelEXT(vk->state.command_buffer, &info);
  }
}

}
