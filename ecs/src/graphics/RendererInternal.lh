/*
 *  Renderer info relevant to the backend.
 */

$ require "common"

$ if IRO_LINUX then
#define VK_USE_PLATFORM_XLIB_KHR
#include <vulkan/vulkan.h>
$ elseif IRO_WIN32 then --if IRO_LINUX
#define VK_USE_PLATFORM_WIN32_KHR
#include <vulkan/vulkan.h>
#undef ERROR
#undef min
#undef max
$ else -- elseif IRO_WIN32
#error "unhandled platform"
$ end -- if IRO_LINUX

#include "iro/containers/FixedPool.h"
#include "iro/io/Format.h"
#include "iro/io/IO.h"
#include "math/vec.h"

@@lpp.import "Renderer.lh"

namespace gfx
{

/* ----------------------------------------------------------------------------
 */
struct RendererTexture
{
  VkImage image;
  VkDeviceMemory memory;
  VkImageView view;
  VkSampler sampler;
  VkDescriptorSet descriptor_set;
};

/* ----------------------------------------------------------------------------
 */
struct RendererFramebuffer
{
  VkFramebuffer framebuffer;
  VkRenderPass renderpass;
  u32 width;
  u32 height;
  vec4f clear_color;
};

/* ----------------------------------------------------------------------------
 */
struct RendererShader
{
  VkShaderModule module;
  VkShaderStageFlagBits stage;
};

/* ----------------------------------------------------------------------------
 */
struct RendererBuffer
{
  VkBuffer buffer;
  VkDeviceMemory memory;
  VkDescriptorSet descriptor_set;
  u64 mapped_offset;
  u64 mapped_size;
};

/* ----------------------------------------------------------------------------
 */
struct RendererPipeline
{
  VkPipeline pipeline;
  VkPipelineLayout layout;
};

/* ----------------------------------------------------------------------------
 */
struct RendererInternal
{
  // Pools
  u32 texture_count;
  iro::FixedPool<RendererTexture, 512> texture_pool;

  u32 framebuffer_count;
  iro::FixedPool<RendererFramebuffer, 4> framebuffer_pool;

  u32 shader_count;
  iro::FixedPool<RendererShader, 32> shader_pool;

  u32 buffer_count;
  iro::FixedPool<RendererBuffer, 512> buffer_pool;

  u32 pipeline_count;
  iro::FixedPool<RendererPipeline, 8> pipeline_pool;

  // Vulkan Objects
  VkAllocationCallbacks allocator;

  VkInstance instance;

$ if ECS_DEBUG then
  VkDebugUtilsMessengerEXT debug_messenger;
  PFN_vkCmdBeginDebugUtilsLabelEXT func_vkCmdBeginDebugUtilsLabelEXT;
  PFN_vkCmdEndDebugUtilsLabelEXT func_vkCmdEndDebugUtilsLabelEXT;
  PFN_vkCmdInsertDebugUtilsLabelEXT func_vkCmdInsertDebugUtilsLabelEXT;
  PFN_vkSetDebugUtilsObjectNameEXT func_vkSetDebugUtilsObjectNameEXT;
$ end -- if ECS_DEBUG

  VkSurfaceKHR surface;
  VkSurfaceFormatKHR surface_format;
  VkPresentModeKHR surface_present_mode;
  VkExtent2D surface_extent;

  VkPhysicalDevice physical_device;
  VkPhysicalDeviceProperties physical_device_properties;
  VkPhysicalDeviceFeatures physical_device_features;
  VkPhysicalDeviceFeatures physical_device_enabled_features;
  u32 physical_device_graphics_and_compute_queue_family;
  u32 physical_device_present_queue_family;

  VkDevice device;
  VkQueue graphics_queue;
  VkQueue present_queue;

  VkCommandPool command_pool;
  VkCommandBuffer command_buffer;

  VkDescriptorSetLayout default_descriptor_set_layout;

  VkDescriptorPool descriptor_pool;

  VkSwapchainKHR swapchain;
  u32 swapchain_min_image_count;
  u32 swapchain_image_count;

  static constexpr u32 MAX_DEFAULT_FRAMEBUFFERS = 4;
  VkRenderPass default_renderpass;
  VkImage default_framebuffer_images[MAX_DEFAULT_FRAMEBUFFERS];
  VkDeviceMemory default_framebuffer_image_memories[MAX_DEFAULT_FRAMEBUFFERS];
  VkImageView default_framebuffer_image_views[MAX_DEFAULT_FRAMEBUFFERS];
  VkFramebuffer default_framebuffers[MAX_DEFAULT_FRAMEBUFFERS];
  u32 default_framebuffer_index;

  VkSemaphore image_acquired_semaphore;
  VkSemaphore render_complete_semaphore;

  VkPipelineCache pipeline_cache;
};

/* ----------------------------------------------------------------------------
 */
static inline void debugBeginLabel(
  Renderer& renderer,
  VkCommandBuffer command_buffer,
  vec4f color,
  iro::io::Formattable auto... args)
{
$ if ECS_DEBUG then
  RendererInternal& ri = *(RendererInternal*)renderer.internal;

  if (ri.func_vkCmdBeginDebugUtilsLabelEXT == nullptr)
    return;

  iro::io::StaticBuffer<64> name = {};
  iro::io::formatv(&name, args...);

  VkDebugUtilsLabelEXT label =
  {
    .sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT,
    .pLabelName = (const char*)name.buffer,
    .color =
    {
      color.x,
      color.y,
      color.z,
      color.w,
    },
  };

  ri.func_vkCmdBeginDebugUtilsLabelEXT(command_buffer, &label);
$ end -- if ECS_DEBUG
}

/* ----------------------------------------------------------------------------
 */
static inline void debugEndLabel(
  Renderer& renderer,
  VkCommandBuffer command_buffer)
{
$ if ECS_DEBUG then
  RendererInternal& ri = *(RendererInternal*)renderer.internal;

  if (ri.func_vkCmdEndDebugUtilsLabelEXT == nullptr)
    return;

  ri.func_vkCmdEndDebugUtilsLabelEXT(command_buffer);
$ end -- if ECS_DEBUG
}

/* ----------------------------------------------------------------------------
 */
static inline void debugInsertLabel(
  Renderer& renderer,
  VkCommandBuffer command_buffer,
  vec4f color,
  iro::io::Formattable auto... args)
{
$ if ECS_DEBUG then
  RendererInternal& ri = *(RendererInternal*)renderer.internal;

  if (ri.func_vkCmdInsertDebugUtilsLabelEXT == nullptr)
    return;

  iro::io::StaticBuffer<64> name = {};
  iro::io::formatv(&name, args...);

  VkDebugUtilsLabelEXT label =
  {
    .sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT,
    .pLabelName = (const char*)name.buffer,
    .color =
    {
      color.x,
      color.y,
      color.z,
      color.w,
    },
  };

  ri.func_vkCmdInsertDebugUtilsLabelEXT(command_buffer, &label);
$ end -- if ECS_DEBUG
}

/* ----------------------------------------------------------------------------
 */
static inline void debugSetObjectName(
  Renderer& renderer,
  VkObjectType type,
  void* handle,
  iro::io::Formattable auto... args)
{
$ if ECS_DEBUG then
  RendererInternal& ri = *(RendererInternal*)renderer.internal;

  if (ri.func_vkSetDebugUtilsObjectNameEXT == nullptr)
    return;
  if (handle == nullptr)
    return;

  iro::io::StaticBuffer<64> name = {};
  iro::io::formatv(&name, args...);

  VkDebugUtilsObjectNameInfoEXT name_info =
  {
    .sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT,
    .objectType = type,
    .objectHandle = (u64)handle,
    .pObjectName = (const char*)name.buffer,
  };

  ri.func_vkSetDebugUtilsObjectNameEXT(ri.device, &name_info);
$ end -- if ECS_DEBUG
}

/* ----------------------------------------------------------------------------
 */
b8 beginSingleUseCommandBuffer(
  Renderer& renderer,
  VkCommandBuffer* command_buffer);

/* ----------------------------------------------------------------------------
 */
b8 endSingleUseCommandBuffer(
  Renderer& renderer,
  VkCommandBuffer command_buffer);

}