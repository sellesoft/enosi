/*
 *  For drawing things to the screen.
 */

$ local lpp = require "lpp"
$ local reflect = require "reflection.Reflector"

#ifndef _ecs_renderer_h
#define _ecs_renderer_h

#include "iro/common.h"
#include "iro/unicode.h"
#include "iro/containers/linked_pool.h"

using namespace iro;

#include "math/vec.h"

struct Engine;
struct Window;
struct Texture;

namespace gfx
{

/* ============================================================================
 */
struct Buffer
{
  u32 vbo = 0;
  u32 ibo = 0;
  u32 vao = 0;

  u64 vertex_size = 0;
  u64 index_size = 0;

  u64 num_vertexes = 0;
  u64 num_indexes = 0;

  struct
  {
    void* vp = nullptr;
    void* ip = nullptr;
  } mapped;

  b8   init(u64 vsize, u64 isize);
  void deinit();

  void setF32AttribF32(
      u32 idx, 
      u32 len, 
      b8 normalized, 
      u64 stride, 
      u64 offset);
  void setF32AttribU8(
      u32 idx, 
      u32 len, 
      b8 normalized, 
      u64 stride,
      u64 offset);

  void map();
  void unmap();
};

/* ============================================================================
 */
struct DrawCmd
{
  enum class Kind
  {
    Invalid,
    BindBuffer,
    Draw,
    BindTexture,
    PushUniformVec2,
    PushUniformFloat,
    PushUniformBool,
  };

  Kind kind;

  union
  {
    Buffer* bind_buffer;

    struct 
    {
      u64 index_start;
      u64 index_count;
      u64 vertex_start;
    } draw;

    Texture* bind_texture;
    
    struct
    {
      str name;
      union
      {
        vec2f v;
        f32 f;
        b8 b;
      };
    } push_uniform;
  };

  DrawCmd() : kind(Kind::Invalid), bind_buffer() {}
};

/* ============================================================================
 */
struct Renderer
{
  u64 frame;

  u32 vertex_shader;
  u32 frag_shader;
  u32 shader_program;

  SLinkedPool<Buffer> buffers;
  Array<DrawCmd> drawcmds;

  void pushBindBuffer(Buffer* buffer)
  {
    DrawCmd cmd;
    cmd.kind = DrawCmd::Kind::BindBuffer;
    cmd.bind_buffer = buffer;
    drawcmds.push(cmd);
  }

  void pushDraw(
    u64 index_start, 
    u64 index_count, 
    u64 vertex_start)
  {
    DrawCmd cmd;
    cmd.kind = DrawCmd::Kind::Draw;
    cmd.draw = 
    {
      .index_start = index_start,
      .index_count = index_count,
      .vertex_start = vertex_start,
    };
    drawcmds.push(cmd);
  }

  void pushBindTexture(Texture* texture)
  {
    DrawCmd cmd;
    cmd.kind = DrawCmd::Kind::BindTexture;
    cmd.bind_texture = texture;
    drawcmds.push(cmd);
  }

  void pushUniformVec2(str name, vec2f v)
  {
    DrawCmd cmd;
    cmd.kind = DrawCmd::Kind::PushUniformVec2;
    cmd.push_uniform.name = name;
    cmd.push_uniform.v = v;
    drawcmds.push(cmd);
  }

  void pushUniformFloat(str name, f32 f)
  {
    DrawCmd cmd;
    cmd.kind = DrawCmd::Kind::PushUniformFloat;
    cmd.push_uniform.name = name;
    cmd.push_uniform.f = f;
    drawcmds.push(cmd);
  }

  void pushUniformBool(str name, b8 b)
  {
    DrawCmd cmd;
    cmd.kind = DrawCmd::Kind::PushUniformBool;
    cmd.push_uniform.name = name;
    cmd.push_uniform.b = b;
    drawcmds.push(cmd);
  }

  b8   init(Window* window);
  void deinit();

  b8 update(Engine& engine);

  b8 compileShaders();

  Buffer* createBuffer();
  void    destroyBuffer(Buffer* buffer);

  // Loads a texture into opengl and sets the proper reference to it 
  // on the given texture.
  b8 loadTexture(Texture& texture);
};

}

#endif
