$ local lpp = require "lpp"
$ local reflect = require "reflection.Reflector"
$ local CGen = require "cgen"
$ local List = require "list"

@lpp.import "input/InputEvents.lh"
@lpp.import "Engine.lh"

#include "iro/logger.h"
#include "math/util.h"
#include "input/Keys.h"

@lpp.import "window/Window.lh"
@lpp.import "window/Window_linux.lh"

static Logger logger = 
  Logger::create("ecs.window"_str, Logger::Verbosity::Notice);

X11Stuff x11;

template<typename E>
void Window::raise(const Engine& eng, E& event) 
{
  eng.eventbus.broadcast.raise<E>(event);
}

/* ----------------------------------------------------------------------------
 */
b8 Window::initializeBackend()
{
  Display* display = x11.display = XOpenDisplay(0);
  if (!display)
    return ERROR("failed to open X11 display\n");

  int screen = x11.screen;

  X11Window root = x11.root = XRootWindow(display, screen);

  x11.context = XUniqueContext();
  x11.default_cursor = XCreateFontCursor(display, XC_left_ptr);

  // Create a blank cursor for when we'd like to hide it.
  XcursorImage* native = XcursorImageCreate(16,16);
  native->xhot = native->yhot = 0;
  for (s32 i = 0; i < 16*16; ++i)
    native->pixels[i] = 0;
  x11.hidden_cursor = XcursorImageLoadCursor(display, native);
  XcursorImageDestroy(native);

  // TODO(sushi) custom cursors
  return true;
}

static int window_event_masks = 
    ExposureMask      // caused when an invisible window becomes visible, 
                      // or when a hidden part of a window becomes visible
  | ButtonPressMask   // mouse button pressed
  | ButtonReleaseMask // mouse button released
  | KeyPressMask      
  | KeyReleaseMask
  | EnterWindowMask
  | LeaveWindowMask
  | PointerMotionMask // mouse movement event
  | StructureNotifyMask // window change events
  | FocusChangeMask;

/* ----------------------------------------------------------------------------
 */
b8 Window::init(str title)
{
  Display* display = x11.display;
  int screen = x11.screen;

  X11Window root, child;
  s32 root_x, root_y;
  s32 win_x, win_y;
  u32 mask;

  XQueryPointer(
    display,
    x11.root,
    &root,
    &child,
    &root_x, &root_y,
    &win_x, &win_y,
    &mask);

  // Find the currently focused monitor to put the window on.
  s32 n_monitors;
  XRRMonitorInfo* monitors = 
    XRRGetMonitors(
      display,
      root,
      1,
      &n_monitors);

  XRRMonitorInfo selection;
  for (s32 i = 0; i < n_monitors; ++i)
  {
    XRRMonitorInfo monitor = monitors[i];
    if (math::pointInRect(
          {root_x, root_y}, 
          {monitor.x, monitor.y},
          {monitor.width, monitor.height}))
    {
      selection = monitor;
      break;
    }
  }

  size.x = selection.width / 2;
  size.y = selection.height / 2;
  pos.x = selection.x + size.x / 2;
  pos.y = selection.y + size.y / 2;

  u32 black = XBlackPixel(display, screen);
  u32 white = XWhitePixel(display, screen);

  x11.root = XRootWindow(display, screen);
    
  this->title = title;

  X11Window window = 
    XCreateSimpleWindow(
      display,
      x11.root,
      pos.x, pos.y,
      size.x, size.y,
      0,
      white, black);

  handle = (void*)window;

  XSetStandardProperties(
    display, 
    window, 
    (const char*)title.bytes,
    0,0,0,0,0);

  int res = XSelectInput(display, window, window_event_masks);
  
  if (res == BadWindow)
    return ERROR("XSelectInput failed with BadWindow\n");

  context = XCreateGC(display, window, 0, 0);
  XSetBackground(display, (GC)context, black);
  XSetForeground(display, (GC)context, white);

  XClearWindow(display, window);

  u32 bw, d;
  X11Window groot, gchild;
  XGetGeometry(
    display, 
    window, 
    &groot,
    &pos.x,&pos.y,
    (u32*)&size.x,(u32*)&size.y,
    &bw, &d);

  XMapRaised(display, window);

  return true;
} 

/* ----------------------------------------------------------------------------
 */
b8 Window::update(const Engine& engine)
{
  XEvent event;
  for (;;)
  {
    b8 got_event = 
      XCheckWindowEvent(
        x11.display, 
        (X11Window)handle, 
        window_event_masks,
        &event);

    if (!got_event)
      break;

    switch (event.type)
    {
    case FocusIn:
      focused = true;
      break;
    case FocusOut:
      focused = false;
      break;
    case KeyPress:
      {
        KeySym ks = XLookupKeysym(&event.xkey, 0);
        Key key = keysymToKey(ks);
        raise<KeyPressed>(engine, {key});
      }
      break;
    case KeyRelease:
      {
        KeySym ks = XLookupKeysym(&event.xkey, 0);
        Key key = keysymToKey(ks);
        raise<KeyReleased>(engine, {key});
      } 
      break;
    case ButtonPress:
    case ButtonRelease:
      {
        XButtonEvent bev = event.xbutton;
        switch (bev.button)
        {
#define map(x, y) \
          case x: \
            (event.type == ButtonPress? \
               raise<MousePressed>(engine, {y}) : \
               raise<MouseReleased>(engine, {y})); \
            break;
        map(Button1, MouseButton::Left);
        map(Button2, MouseButton::Middle);
        map(Button3, MouseButton::Right);
#undef map
        case Button4: raise<MouseScroll>(engine, { 1.f}); break;
        case Button5: raise<MouseScroll>(engine, {-1.f}); break;
        default:
            WARN("unhandled button given by XButtonEvent: ", bev.button, 
                 "\n");
          break;
        }
      }
      break;
    case MotionNotify:
      {
        XMotionEvent motion = event.xmotion;
        raise<MouseMoved>(
          engine, 
          {
            .window_pos = vec2f(motion.x, motion.y),
            .screen_pos = vec2f(motion.x_root, motion.y_root)
          });
      }
      break;
    }
  }

  return true;
}

$$$

local cases = function()
  local a = string.byte "a"
  local z = string.byte "z"

  local c = CGen.new()
  c:indent()

  for i=a,z do
    local char = string.char(i)
    c:beginCase("XK_"..char)
    c:append("return Key::",string.upper(char),";")
    c:endCase()
  end

  for i=0,9 do
    local n = tostring(i)
    c:beginCase("XK_"..n)
    c:append("return Key::N",n,";")
    c:endCase()
  end

  for i=1,12 do
    local n = tostring(i)
    c:beginCase("XK_F"..n)
    c:append("return Key::F",n,";")
    c:endCase()
  end

  List{ "Up", "Down", "Left", "Right" }:each(function(dir)
    c:beginCase("XK_"..dir)
    c:append("return Key::",dir,";")
    c:endCase()
  end)

  local odd = function(from)
    c:beginCase("XK_"..from)
    return function(to)
      c:append("return Key::",to,";")
      c:endCase()
    end
  end

  for i=0,9 do
    local n = tostring(i)
    c:beginCase("XK_KP_"..n)
    c:append("return Key::NP",n,";")
    c:endCase()
  end

  odd "Escape" "Escape"
  odd "asciitilde" "Backquote"
  odd "Tab" "Tab"
  odd "Caps_Lock" "CapsLock"
  odd "Shift_L" "LShift"
  odd "Control_L" "LCtrl"
  odd "Alt_L" "LAlt"
  odd "Shift_R" "RShift"
  odd "Control_R" "RCtrl"
  odd "Alt_R" "RAlt"
  odd "BackSpace" "Backspace"
  odd "Return" "Enter"
  odd "minus" "Minus"
  odd "equal" "Equals"
  odd "bracketleft" "LBracket"
  odd "bracketright" "RBracket"
  odd "slash" "ForwardSlash"
  odd "semicolon" "Semicolon"
  odd "apostrophe" "Apostrophe"
  odd "comma" "Comma"
  odd "period" "Period"
  odd "backslash" "BackSlash"
  odd "space" "Space"
  odd "Insert" "Insert"
  odd "Delete" "Delete"
  odd "Home" "Home"
  odd "End" "End"
  odd "Prior" "PageUp"
  odd "Page_Down" "PageDown"
  odd "Pause" "Pause"
  odd "Scroll_Lock" "ScrollLock"
  odd "Meta_L" "LMeta"
  odd "Meta_R" "RMeta"
  odd "Print" "PrintScreen"
  odd "KP_Multiply" "NPMultiply"
  odd "KP_Divide" "NPDivide"
  odd "KP_Add" "NPPlus"
  odd "KP_Subtract" "NPMinus"
  odd "KP_Decimal" "NPPeriod"
  odd "Num_Lock" "NPNumLock"
 
  return c.buffer:get()
end

$$$

Key keysymToKey(KeySym k)
{
  switch(k)
  {
  @cases
  }
  return Key::Invalid;
}
