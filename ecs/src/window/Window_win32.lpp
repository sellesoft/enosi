$ local cmn = require "common"

$ if IRO_WIN32 then

#include "iro/Platform_Win32.h"
#include "iro/Logger.h"

using Win32ErrMsg = iro::platform::Win32ErrMsg;

using namespace iro;

@cmn.defFileLogger(window, Info)

@lpp.import "Window.lh"
@lpp.import "Window_win32.lh"
@@lpp.import "Window.events.lh"
@@lpp.import "../Engine.lh"

Win32Stuff win32;

/* ----------------------------------------------------------------------------
 */
template<typename E>
void Window::raise(const Engine& eng, E& event) 
{
  eng.eventbus.broadcast.raise<E>(event);
}

/* ----------------------------------------------------------------------------
 */
LRESULT CALLBACK win32WindowCallback(
    HWND hwnd, 
    UINT msg, 
    WPARAM wparam, 
    LPARAM lparam)
{
  auto* window = (Window*)GetWindowLongPtr(hwnd, GWLP_USERDATA);

  if (window == nullptr)
    return DefWindowProc(hwnd, msg, wparam, lparam);

  switch (msg)
  {
  case WM_CREATE:
    return 0;
  case WM_CLOSE:
    return 0;
  case WM_DESTROY:
    return 0;

  case WM_SIZE:
    window->size.x = LOWORD(lparam);
    window->size.y = HIWORD(lparam);
    window->raise<WindowResized>(*window->eng, {window->size});
    INFO("window resized to ", window->size, "\n");
    return 0;
  }

  return DefWindowProc(hwnd, msg, wparam, lparam);
}

/* ----------------------------------------------------------------------------
 */
b8 Window::initializeBackend()
{
  win32.h_console_instance = GetModuleHandleW(0);

  WNDCLASSEXA dummy_window_class = {};
  dummy_window_class.cbSize        = sizeof(WNDCLASSEX);
  dummy_window_class.style         = CS_OWNDC;
  dummy_window_class.lpfnWndProc   = win32WindowCallback;
  dummy_window_class.hInstance     = win32.h_console_instance;
  dummy_window_class.lpszClassName = g_win32_dummy_window_classname;

  if (!RegisterClassEx(&dummy_window_class))
    return ERROR_WIN32("failed to register dummy window class");

  WNDCLASSEXA window_class = {};
  window_class.cbSize        = sizeof(WNDCLASSEXW);
  window_class.style         = CS_OWNDC;
  window_class.lpfnWndProc   = win32WindowCallback;
  window_class.hInstance     = win32.h_console_instance;
  window_class.lpszClassName = g_win32_window_classname;

  if (!RegisterClassEx(&window_class))
    return ERROR_WIN32("failed to register window class");

  // Create dummy window.
  win32.dummy_window_handle = 
    CreateWindowExA(
        WS_EX_OVERLAPPEDWINDOW
      | WS_EX_NOACTIVATE,
      g_win32_dummy_window_classname,
      "_ecs_dummy_window_",     // Title
        WS_CLIPSIBLINGS         // Style
      | WS_CLIPCHILDREN, 
      CW_USEDEFAULT,0,          // x,y
      CW_USEDEFAULT,0,          // w,h
      NULL,                     // Parent handle
      NULL,                     // Menu handle
      win32.h_console_instance, // Instance handle
      NULL);                    // User data?

  if (win32.dummy_window_handle == NULL)
    return ERROR_WIN32("failed to dummy create window");

  win32.dummy_window_device_handle = GetDC(win32.dummy_window_handle);

  ShowWindow(win32.dummy_window_handle, SW_HIDE);

  return true;
}

/* ----------------------------------------------------------------------------
 *  TODO(sushi) handle unicode window titles if ever necessary.
 */
b8 Window::init(String name)
{
  handle = 
    CreateWindowEx(
      0,
      g_win32_window_classname,
      (LPCSTR)name.ptr,
        WS_CLIPCHILDREN
      | WS_CLIPSIBLINGS
      | WS_OVERLAPPEDWINDOW,
      CW_USEDEFAULT,CW_USEDEFAULT,
      CW_USEDEFAULT,CW_USEDEFAULT,
      NULL,
      NULL,
      win32.h_console_instance,
      NULL);

  if (handle == nullptr)
    return ERROR_WIN32("failed to spawn window ", title);

  context = GetDC((HWND)handle);

  ShowWindow((HWND)handle, SW_SHOW);

  SetWindowLongPtr((HWND)handle, GWLP_USERDATA, (LONG_PTR)this);

  RECT rect;
  GetClientRect((HWND)handle, &rect);

  size.x = rect.right - rect.left;
  size.y = rect.bottom - rect.top;

  return true;
}

/* ----------------------------------------------------------------------------
 */
b8 Window::update(Engine& eng)
{
  // TODO(sushi) do better later
  this->eng = &eng;

  MSG msg;
  while (PeekMessage(&msg, (HWND)handle, 0, 0, PM_REMOVE))
  {
    TranslateMessage(&msg);
    DispatchMessage(&msg);
  }

  return true;
}

$ end -- if IRO_WIN32
