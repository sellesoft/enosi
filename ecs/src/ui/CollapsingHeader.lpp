$ local lpp = require "lpp"
$ local reflect = require "reflection.Reflector"
$ local ui = require "ui.UI"

@@lpp.import "ui/CollapsingHeader.lh"
@@lpp.import "ui/UI.lh"
@@lpp.import "Engine.lh"

#include "math/util.h"

static Logger logger = 
  Logger::create("ui.colheader"_str, Logger::Verbosity::Info);

namespace ui
{

/* ----------------------------------------------------------------------------
 */
template<>
CollapsingHeader* UI::make(str id, str init)
{
  CollapsingHeader* ch = mem::stl_allocator.construct<CollapsingHeader>();
  if (!initItem(id, ch))
  {
    mem::stl_allocator.free(ch);
    return nullptr;
  }

  auto* background_dc = drawcmds.add();
  background_dc->alloc(this, putFilledRectCounts());
  ch->drawcmds.push(background_dc);

  auto* text_dc = drawcmds.add();
  ch->drawcmds.push(text_dc);

  if (!ch->header_text.init(init))
  {
    mem::stl_allocator.free(ch);
    return nullptr;
  }

  $ local ch = ui.createItemContext("CollapsingHeader", "ch")

  @ch.style.set.update_triggers(MouseReleased);

  return ch;
}

/* ----------------------------------------------------------------------------
 */
void CollapsingHeader::evaluate(UI* ui)
{
  $ local this = ui.createItemContext("CollapsingHeader", "this")
  @@this.style:lookup(font)

  header_text.checkFont(@this.style.font, ui);
}

/* ----------------------------------------------------------------------------
 */
vec2f CollapsingHeader::getMinSize(UI* ui)
{
  $ local this = ui.createItemContext("CollapsingHeader", "this")
  @@this.style:lookup(header_height)

  return { 0.f, @this.style.header_height };
}

/* ----------------------------------------------------------------------------
 */
void CollapsingHeader::update(UI* ui, UpdateReason reason)
{
  $ local this = ui.createItemContext("CollapsingHeader", "this")
  @@this.style:lookup(header_height)

  vec2f mpos = ui->eng->input.mouse.window;
  if (math::pointInRect(
        ui->eng->input.mouse.window,
        pos_screen,
        vec2f(size.x, @this.style.header_height)))
  {
    open = !open;
  }
}

/* ----------------------------------------------------------------------------
 */
void CollapsingHeader::generate(UI* ui)
{
  $ local Text = ui.widgets.Text.schema
  $ local this = ui.createItemContext("CollapsingHeader", "this")
  @@this.style:lookup(
    header_height, 
    header_color, 
    header_text_align,
    font_height,
    text_color)

  DrawCmd* background_dc = drawcmds[0];
  DrawCmd* text_dc = drawcmds[1];

  auto [bgvp, bgip] = background_dc->getPtrs(ui);

  vec2i sum = {};

  sum +=
    putFilledRect(
      bgvp,
      bgip,
      sum,
      pos_screen,
      vec2f(size.x, @this.style.header_height),
      @this.style.header_color);

  background_dc->counts_used = sum;

  vec2f text_size = {};
  TextBreaks breaks;
  if (!breaks.init())
  {
    ERROR("failed to initialize text breaks\n");
    return;
  }

  header_text.findTextBreaks(
    &text_size,
    &breaks,
    @this.style.font_height,
    1.f,
    999.f,
    @Text.wrap.none);

  auto text_pos = vec2f(
    pos_screen.x + @this.style.header_text_align.x * (size.x - text_size.x),
    pos_screen.y + 
      @this.style.header_text_align.y * 
      (@this.style.header_height - text_size.y));
  
  header_text.draw(
    ui,
    text_pos,
    text_dc,
    @this.style.text_color,
    breaks);
}

/* ----------------------------------------------------------------------------
 */
vec2f CollapsingHeader::adjustCursorStart(UI* ui, vec2f norm)
{
  // Start placing children below the header.
  $ local this = ui.createItemContext("CollapsingHeader", "this")

  @@this.style:lookup(header_height)

  return vec2f(0.f, @this.style.header_height);
}

}
