/*
 *  UI system!
 */

$ local cmn = require "common"
$ local ui = require "ui.UI"

@@lpp.import "graphics/Buffer.lh"
@@lpp.import "graphics/CompiledTexture.lh"
@@lpp.import "graphics/Pipeline.lh"
@@lpp.import "graphics/Shader.lh"
@@lpp.import "graphics/Pipeline.defs.lh"

@@lpp.import "input/InputState.lh"

@@lpp.import "ui/Skin.defs.lh"

@@lpp.import "ui/TextEdit.lh"

#include "iro/containers/List.h"
#include "iro/containers/Pool.h"
#include "iro/containers/LinkedPool.h"
#include "iro/containers/Tree.h"
#include "iro/memory/Bump.h"
#include "iro/memory/LinkedHeap.h"
#include "math/Rect.h"
#include "math/mat.h"
#include "Color.h"

namespace gfx
{
  struct Buffer;
  struct Renderer;
}

struct InputMgr;
struct mat3x2;

namespace ui
{

struct UI;
struct TextEdit;

/* ============================================================================
 */
enum class FocusFlag
{
  Hovered, 
  Focused,

  Pressed,
  Released,

  COUNT
};
typedef Flags<FocusFlag> FocusFlags;

/* ============================================================================
 */
struct FocusableId
{
  u64 val = 0;

  bool operator == (const FocusableId& rhs) const
  {
    return val == rhs.val;
  }

  DefineNilTrait(FocusableId, {0}, x.val == 0);
};

/* ============================================================================
 */
struct CombinedFocusableId
{
  u64 val = 0;

  bool operator == (const CombinedFocusableId& rhs) const
  {
    return val == rhs.val;
  }

  DefineNilTrait(CombinedFocusableId, {0}, x.val == 0);
};

/* ============================================================================
 */
struct FocusableBounds
{
  CombinedFocusableId id = {};
  Rect bounds = {};

  FocusableBounds* next = nullptr;
};

/* ============================================================================
 */
struct Cmd
{
  Cmd* next;

  virtual void execute(UI& ui, gfx::Renderer& renderer) = 0;
};

/* ============================================================================
 */
struct TransformCmd : Cmd
{
  mat3x2* transform;

  void execute(UI& ui, gfx::Renderer& renderer) override;
};

/* ============================================================================
 */
struct ScissorCmd : Cmd
{
  Rect bounds = {};

  void execute(UI& ui, gfx::Renderer& renderer) override;
};

/* ============================================================================
 */
struct QuadDrawCmd : Cmd
{
  gfx::Texture texture;
  Color color;
  Rect bounds;
  vec4f uv;

  void execute(UI& ui, gfx::Renderer& renderer) override;
};

/* ============================================================================
 */
struct BorderDrawCmd : Cmd
{
  Rect bounds;
  Color color;

  void execute(UI& ui, gfx::Renderer& renderer) override;
};

/* ============================================================================
 */
enum class GroupScissor
{
  Self,
  Parent,
  None,
};

/* ============================================================================
 */
struct Group
{
  Rect bounds = {};

  mat3x2 transform = {};

  GroupScissor scissoring = GroupScissor::Self;

  FocusableBounds* fbounds = nullptr;

  Group* parent = nullptr;
  Group* next = nullptr;
};

/* ============================================================================
 */
struct Panel
{
  CombinedFocusableId id = {};
  
  Group* groups = nullptr;
  Group* current_group = nullptr;

  Panel* parent = nullptr;
  Panel* next = nullptr;
};

/* ============================================================================
 */
enum class LayerFlag
{
  TopMost,

  COUNT
};
typedef Flags<LayerFlag> LayerFlags;

/* ============================================================================
 */
struct Layer
{
  u32 idx = 0;

  Panel* panels = nullptr;
  Panel* current_panel = nullptr;

  Cmd* first_cmd = nullptr;
  Cmd* last_cmd = nullptr;

  Layer* prev = nullptr;
  Layer* next = nullptr;

  void pushCmd(Cmd* cmd);
};

/* ============================================================================
 *  State intended to be kept persistent by users of TextFields.
 */
struct TextFieldState
{
  // X offset of this field's text. Used to follow the cursor when its moved
  // outside of the visible text.
  f32 x_offset;

  // State tracking a buffer to edit as well as the cursor that moves through
  // the buffer.
  TextEdit edit;
};

/* ============================================================================
 */
struct PersistentState
{
  CombinedFocusableId id;

  void* ptr;
  u64   size;
};

/* ============================================================================
 */
struct PersistentStateMgr
{
  enum
  {
    c_MaxStates = 256,
    c_HeapSize = unit::kilobytes(4)
  };

  void* heap_ptr;
  mem::LinkedHeap heap;

  PersistentState states[c_MaxStates];
  u64 num_states;

  b8 init(mem::Allocator* allocator);
  void deinit(mem::Allocator* allocator);

  struct GetResult
  {
    PersistentState* pstate;
    b8 just_created;
  };

  GetResult registerOrGetState(CombinedFocusableId id, u64 size);
};

/* ============================================================================
 */
struct UI
{
  enum
  {
    c_MaxVertices = 0xffff,
    c_MaxIndices = (c_MaxVertices / 4) * 6,
    c_PushConstantSize = 16 * sizeof(f32),
  };
 
  struct InitParams
  {
    AssetMgr& assetmgr;
    gfx::Renderer& renderer;

    gfx::Texture white_texture;

    Rect viewport;

    AssetLoader loader;
  };

  b8   init(InitParams& params);
  void deinit();

  struct FrameParams
  {
    // The input state to be applied during this frame.
    InputState input;

    // The viewport drawn into this frame.
    Rect viewport;
  };

  void beginFrame(const FrameParams& params);
  void endFrame();

  Rect getBounds() const 
  { 
    return Rect::from({0,0}, getCurrentGroup()->bounds.size());
  }

  f32 getWidth() const { return getCurrentGroup()->bounds.w; }
  f32 getHeight() const { return getCurrentGroup()->bounds.h; }

  void putQuad(Rect bounds, gfx::Texture texture, vec4f uv, Color color);
  void putQuad(Rect bounds, gfx::Texture texture, Color color);
  void putQuad(Rect bounds, Color color);

  FocusFlags putFocusableBounds(FocusableId id, Rect bounds);

  // Pushes a layer and starts a new panel at the given bounds with the 
  // given id.
  void pushLayer(FocusableId id, Rect bounds, LayerFlags flags);
  void popLayer();

  // Begins a new panel.
  void beginPanel(FocusableId id, Rect bounds);
  void beginPanel(FocusableId id, Rect bounds, Panel* prev);
  void endPanel();

  void beginGroup(Rect bounds, GroupScissor scissoring = GroupScissor::Self);
  void endGroup();

  // Places a basic 'item', a decorated rect basically.
  void putItem(Rect bounds, const ItemSkinDef& skin);

  // Places undecorated text.
  // TODO(sushi) basic text functions that don't require a skin
  //             and use a default font (gohu, of course) stored on UI.
  void putText(Rect bounds, String text, const TextSkinDef& skin);

  // Places text with a background and various other decor (eventually).
  void putTextItem(Rect bounds, String text, const TextItemSkinDef& skin);

  // Returns true if clicked.
  b8 putButton(
    FocusableId id, 
    Rect bounds, 
    String text, 
    const ButtonSkinDef& skin);

  // Places a text field that edits some text specified in the state.
  b8 putTextField(
    FocusableId id,
    Rect bounds, 
    TextFieldState* state,
    const TextFieldSkinDef& skin);

  // Variant of the above which just takes a buffer of text to edit. The 
  // state of the text field is managed internally by UI. If the field goes
  // unused for too long its state will be cleared. To avoid this, use the 
  // above function with a TextFieldState stored elsewhere.
  b8 putTextField(
    FocusableId id,
    Rect bounds,
    TextEdit::Buffer buffer,
    const TextFieldSkinDef& skin);

  void pushGroupRenderState(Group* group);

  // Bump allocator for memory allocated throughout a UI frame.
  mem::Bump frame_allocator;

  Rect viewport = {};

  gfx::Renderer* renderer = nullptr;

  // Graphics stuff.
  gfx::Shader vertex_shader;
  gfx::Shader fragment_shader;
  gfx::Pipeline pipeline;
  gfx::PipelineDefRef pipeline_defref;

  gfx::Texture white_texture;

  gfx::Buffer vertex_buffer;
  gfx::Buffer index_buffer;

  // True when a UI frame is in progress.
  b8 in_frame = false;

  // The input state of an update. Inputs may be consumed from this 
  // state by either UI or Items.
  InputState frame_input;

  vec2i draw_counts = {};

  struct FocusState
  {
    CombinedFocusableId focused;
    CombinedFocusableId hovered;
  };

  FocusState prev_focus_state;
  FocusState focus_state;
  FocusState next_focus_state;

  void drawDebugRect(Rect rect, Color color);
  void drawDebugBorder(Rect rect, Color color);

  Cmd* debug_cmds = nullptr;

  // The initial Layer created on frame start.
  Layer* root_layer = nullptr;

  // The current layer being operated on this frame.
  Layer* current_layer = nullptr;

  // Current layer index, used for tracked focused/hovered layers.
  u32 layer_idx = 0;

  PersistentStateMgr persistent_state_mgr;

  template<typename T>
  b8 registerOrGetPersistentState(CombinedFocusableId id, T** out_state)
  {
    PersistentStateMgr::GetResult result = 
      persistent_state_mgr.registerOrGetState(id, sizeof(T));

    if (result.pstate == nullptr)
      return false;

    *out_state = (T*)result.pstate->ptr;
    return result.just_created;
  }

  template<typename T>
  b8 registerOrGetPersistentState(FocusableId id, T** out_state)
  {
    return registerOrGetPersistentState(getCombinedId(id), out_state);
  }

  void pushConstantFromTransform(mat3x2 transform, gfx::Renderer& renderer);

  // Combines the given ids.
  CombinedFocusableId combineIds(FocusableId a, FocusableId b) const;
  CombinedFocusableId combineIds(CombinedFocusableId a, FocusableId b) const;

  // Combines the given id with the id of the current panel.
  CombinedFocusableId getCombinedId(FocusableId id) const;

  Layer* getCurrentLayer() const { return current_layer; }
  Panel* getCurrentPanel() const { return getCurrentLayer()->current_panel; }
  Group* getCurrentGroup() const { return getCurrentPanel()->current_group; }
};

}

consteval ui::FocusableId operator ""_fid(const char* c, size_t s)
{
  return ui::FocusableId{operator ""_hashed(c,s)};
}




