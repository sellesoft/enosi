/*
 *  UI system!
 */

$ local cmn = require "common"
$ local ui = require "ui.UI"

@@lpp.import "graphics/Buffer.lh"
@@lpp.import "graphics/CompiledTexture.lh"
@@lpp.import "graphics/Pipeline.lh"
@@lpp.import "graphics/Shader.lh"
@@lpp.import "graphics/Pipeline.defs.lh"

@@lpp.import "input/InputState.lh"

#include "iro/containers/List.h"
#include "iro/containers/Pool.h"
#include "iro/containers/LinkedPool.h"
#include "iro/containers/Tree.h"
#include "iro/memory/Bump.h"
#include "math/Rect.h"
#include "Color.h"

namespace gfx
{
  struct Buffer;
  struct Renderer;
}

struct InputMgr;

namespace ui
{

struct TextSkinDef;

/* ============================================================================
 */
enum class FocusFlag
{
  // The given focusable is hovered.
  Hovered, 

  // The given focusable gained/lost hover this frame.
  GainedHover,
  LostHover,

  // The given focusable has focus.
  Focused,

  // The given focusable gained/lost focus this frame.
  GainedFocus,
  LostFocus,

  COUNT
};
typedef Flags<FocusFlag> FocusFlags;

/* ============================================================================
 */
struct FocusableId
{
  u64 val = 0;

  bool operator == (const FocusableId& rhs) const
  {
    return val == rhs.val;
  }

  DefineNilTrait(FocusableId, {0}, x.val == 0);
};

/* ============================================================================
 */
struct FocusableBounds
{
  FocusableId id = {};
  Rect bounds = {};

  FocusableBounds* next = nullptr;
};

/* ============================================================================
 */
struct DrawCmd
{
  // The next command in a group's drawcmd list.
  DrawCmd* next;

  virtual void draw(gfx::Renderer& renderer);
};

/* ============================================================================
 */
struct QuadDrawCmd : DrawCmd
{
  gfx::Texture texture;
  Rect uv;
  Color color;
  Rect bounds;

  void draw(gfx::Renderer& renderer) override;
};

/* ============================================================================
 */
struct Group
{
  Group* prev = nullptr;

  Rect bounds = {};
  
  FocusableBounds* fbounds = nullptr;

  DrawCmd* drawcmds = nullptr;
};

/* ============================================================================
 */
enum class LayerFlag
{
  TopMost,

  COUNT
};
typedef Flags<LayerFlag> LayerFlags;

/* ============================================================================
 */
struct Layer
{
  FocusableId id = nil;
  Group* groups = nullptr;

  Layer* prev = nullptr;
  Layer* next = nullptr;

  b8 minor = false;
};

/* ============================================================================
 */
struct UI
{
  enum
  {
    c_MaxVertices = 0xffff,
    c_MaxIndices = (c_MaxVertices / 4) * 6,
    c_PushConstantSize = 16 * sizeof(f32),
  };

  mem::Bump frame_allocator;

  Rect viewport;

  gfx::Renderer* renderer;

  gfx::Shader vertex_shader;
  gfx::Shader fragment_shader;
  gfx::Pipeline pipeline;
  gfx::PipelineDefRef pipeline_defref;

  gfx::Texture white_texture;

  gfx::Buffer vertex_buffer;
  gfx::Buffer index_buffer;

  struct InitParams
  {
    AssetMgr& assetmgr;
    gfx::Renderer& renderer;

    gfx::Texture white_texture;

    Rect viewport;

    AssetLoader loader;
  };

  b8   init(InitParams& params);
  void deinit();

  struct FrameParams
  {
    // The input state to be applied during this frame.
    InputState input;

    // The viewport drawn into this frame.
    Rect viewport;
  };

  void beginFrame(const FrameParams& params);
  void endFrame();

  void putQuad(Rect bounds, gfx::Texture texture, Rect uv, Color color);
  void putQuad(Rect bounds, gfx::Texture texture, Color color);
  void putQuad(Rect bounds, Color color);

  void putText(Rect bounds, String text, const TextSkinDef& skin);

  void beginLayer(FocusableId id, Rect bounds, LayerFlags flags);
  void endLayer();

  Rect getBounds() const;

private:

  // True when a UI frame is in progress.
  b8 in_frame = false;

  // The input state of an update. Inputs may be consumed from this 
  // state by either UI or Items.
  InputState frame_input;

  // Counts of vertices and indices drawn this frame.
  u64 vertex_count;
  u64 index_count;

  u64 next_focusable_id;

  struct FocusState
  {
    FocusableId focused;
    FocusableId focused_layer;
    FocusableId hovered;
    FocusableId hovered_layer;
  };

  FocusState prev_focus_state;
  FocusState focus_state;
  FocusState next_focus_state;

  void drawDebugRect(Rect rect, Color color);
  void drawDebugBorder(Rect rect, Color color);

  // The current layer being operated on this frame.
  Layer* current_layer;

  // The current group of the current Layer.
  Group* current_group;

  // The layer we will start drawing from when the frame has ended. 
  Layer* top_layer;
};

}




