/*
 *  UI system!
 */

$ local cmn = require "common"
$ local ui = require "ui.UI"

@@lpp.import "graphics/Buffer.lh"
@@lpp.import "graphics/CompiledTexture.lh"
@@lpp.import "graphics/Pipeline.lh"
@@lpp.import "graphics/Shader.lh"
@@lpp.import "graphics/Pipeline.defs.lh"

@@lpp.import "input/InputState.lh"

@@lpp.import "ui/Skin.defs.lh"

#include "iro/containers/List.h"
#include "iro/containers/Pool.h"
#include "iro/containers/LinkedPool.h"
#include "iro/containers/Tree.h"
#include "iro/memory/Bump.h"
#include "math/Rect.h"
#include "math/mat.h"
#include "Color.h"

namespace gfx
{
  struct Buffer;
  struct Renderer;
}

struct InputMgr;

struct mat3x2;

namespace ui
{

struct UI;

struct TextSkinDef;

/* ============================================================================
 */
enum class FocusFlag
{
  // The given focusable is hovered.
  Hovered, 

  // The given focusable gained/lost hover this frame.
  GainedHover,
  LostHover,

  // The given focusable has focus.
  Focused,

  // The given focusable gained/lost focus this frame.
  GainedFocus,
  LostFocus,

  COUNT
};
typedef Flags<FocusFlag> FocusFlags;

/* ============================================================================
 */
struct FocusableId
{
  u64 val = 0;

  bool operator == (const FocusableId& rhs) const
  {
    return val == rhs.val;
  }

  DefineNilTrait(FocusableId, {0}, x.val == 0);
};

/* ============================================================================
 */
struct FocusableBounds
{
  FocusableId id = {};
  Rect bounds = {};

  FocusableBounds* next = nullptr;
};

/* ============================================================================
 */
struct Cmd
{
  Cmd* next;

  virtual void execute(UI& ui, gfx::Renderer& renderer) = 0;
};

/* ============================================================================
 */
struct TransformCmd : Cmd
{
  mat3x2* transform;

  void execute(UI& ui, gfx::Renderer& renderer) override;
};

/* ============================================================================
 */
struct ScissorCmd : Cmd
{
  Rect bounds = {};

  void execute(UI& ui, gfx::Renderer& renderer) override;
};

/* ============================================================================
 */
struct QuadDrawCmd : Cmd
{
  gfx::Texture texture;
  Rect uv;
  Color color;
  Rect bounds;

  void execute(UI& ui, gfx::Renderer& renderer) override;
};

/* ============================================================================
 */
struct BorderDrawCmd : Cmd
{
  Rect bounds;
  Color color;

  void execute(UI& ui, gfx::Renderer& renderer) override;
};

/* ============================================================================
 */
struct Panel
{
  FocusableId id;

  Rect bounds = {};

  mat3x2 transform = {};

  Panel* prev = nullptr;

  FocusableBounds* fbounds = nullptr;
};

/* ============================================================================
 */
enum class LayerFlag
{
  TopMost,

  COUNT
};
typedef Flags<LayerFlag> LayerFlags;

/* ============================================================================
 */
struct Layer
{
  u32 idx = 0;

  Panel* panels = nullptr;

  Cmd* first_cmd = nullptr;
  Cmd* last_cmd = nullptr;

  Panel* current_panel = nullptr;

  Layer* prev = nullptr;
  Layer* next = nullptr;

  void pushCmd(Cmd* cmd);
};

/* ============================================================================
 */
struct UI
{
  enum
  {
    c_MaxVertices = 0xffff,
    c_MaxIndices = (c_MaxVertices / 4) * 6,
    c_PushConstantSize = 16 * sizeof(f32),
  };
 
  struct InitParams
  {
    AssetMgr& assetmgr;
    gfx::Renderer& renderer;

    gfx::Texture white_texture;

    Rect viewport;

    AssetLoader loader;
  };

  b8   init(InitParams& params);
  void deinit();

  struct FrameParams
  {
    // The input state to be applied during this frame.
    InputState input;

    // The viewport drawn into this frame.
    Rect viewport;
  };

  void beginFrame(const FrameParams& params);
  void endFrame();

  void putQuad(Rect bounds, gfx::Texture texture, Rect uv, Color color);
  void putQuad(Rect bounds, gfx::Texture texture, Color color);
  void putQuad(Rect bounds, Color color);

  FocusFlags putFocusableBounds(FocusableId id, Rect bounds);

  // Pushes a layer and starts a new panel at the given bounds with the 
  // given id.
  void pushLayer(FocusableId id, Rect bounds, LayerFlags flags);
  void popLayer();

  // Begins a new panel.
  void beginPanel(FocusableId id, Rect bounds);
  void beginPanel(FocusableId id, Rect bounds, Panel* prev);

  void endPanel();

  void putText(Rect bounds, String text, const TextSkinDef& skin);

  FocusFlags putButton(FocusableId id, Rect bounds, const ButtonSkinDef& skin);

  // Pushes Cmds to the active Layer to transform and scissor successive Cmds
  // according to the given Panel.
  void pushPanelRenderState(Panel* panel);

  Rect getBounds() const;

  // Bump allocator for memory allocated throughout a UI frame.
  mem::Bump frame_allocator;

  // The current viewport (is this needed?)
  Rect viewport = {};

  gfx::Renderer* renderer = nullptr;

  // Graphics stuff.
  gfx::Shader vertex_shader;
  gfx::Shader fragment_shader;
  gfx::Pipeline pipeline;
  gfx::PipelineDefRef pipeline_defref;

  gfx::Texture white_texture;

  gfx::Buffer vertex_buffer;
  gfx::Buffer index_buffer;

  // True when a UI frame is in progress.
  b8 in_frame = false;

  // The input state of an update. Inputs may be consumed from this 
  // state by either UI or Items.
  InputState frame_input;

  vec2i draw_counts = {};

  u64 next_focusable_id;

  struct FocusState
  {
    FocusableId focused;
    FocusableId hovered;
    FocusableId focused_panel;
    FocusableId hovered_panel;
    u32 hovered_layer_idx;
    u32 focused_layer_idx;
  };

  FocusState prev_focus_state;
  FocusState focus_state;
  FocusState next_focus_state;

  void drawDebugRect(Rect rect, Color color);
  void drawDebugBorder(Rect rect, Color color);

  Cmd* debug_cmds;

  // The initial Layer created on frame start.
  Layer* root_layer;

  // The current layer being operated on this frame.
  Layer* current_layer;

  // Current layer index, used for tracked focused/hovered layers.
  u32 layer_idx;

  void pushConstantFromTransform(mat3x2 transform, gfx::Renderer& renderer);
};

}

consteval ui::FocusableId operator ""_fid(const char* c, size_t s)
{
  return ui::FocusableId{operator ""_hashed(c,s)};
}




