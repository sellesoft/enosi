$ if false then

/*
 *  Widget for creating a text box that supports typing.
 */

$ require "common"
$ local ui = require "ui.UI"

@@lpp.import "ui/Item.lh"
@@lpp.import "ui/TextEdit.lh"
@@lpp.import "ui/widgets/Text.lh"

@@lpp.import "graphics/Font.lh"

namespace ui
{

struct InputTextSkinDef;

/* ============================================================================
 *  The actual state and functionality of an InputText to help reusability.
 */
struct InputText
{
  FocusableId fid;

  TextEdit text_edit;
  Text text;

  String preview; // Owned.

  f32 text_x_offset = 0.f;

  DrawCmd* decor;
  DrawCmd* cursor;

  b8 init(UI& ui, String init = nil, String preview = nil);
  void deinit(UI& ui);

  enum class EditResult
  {
    // Nothing changed.
    Idle,

    // The cursor was moved.
    CursorMoved,

    // The text was changed.
    TextChanged,

    // An attempt was made to edit the text, but the provided buffer is too
    // small.
    OutOfSpace,

    // The commit key (Enter) was pressed.
    Commit,
  };

  struct UpdateResult
  {
    EditResult edit;
    FocusFlags focus;
  };

  UpdateResult update(
    ItemUpdateContext& ctx, 
    Rect bounds,
    TextEdit::Buffer buffer,
    const InputTextSkinDef& skin);

  // Variant in which the provided text is a view over some non-editable
  // text. This is used when we want to display some text as if it were in 
  // an InputText box, but when the text we are displaying is not in memory 
  // we can change. It should be common that when multiple InputTexts are 
  // used, they all edit the same buffer when active to reduce the amount of 
  // buffers we store for editing.
  // A concrete example of this is the SourceDataEditor. There are tons
  // of text boxes in it, but it only stores one buffer for editing text. 
  // So when an InputText is not focused, the DatumStates simply point 
  // InputText to the SourceData's actual string, then when an InputText is 
  // focused, it passes the editor's central editable buffer.
  // This will still report the gained/lost focus results, but will never 
  // consume inputs or return any result that indicates the buffer was edited.
  // If this InputText is focused and this update is used, it will simply 
  // do nothing and will not show the cursor!
  UpdateResult update(
    ItemUpdateContext& ctx, 
    Rect bounds,
    String text,
    const InputTextSkinDef& skin);

  void reportDrawCmds(UI& ui, DrawCmdLists& lists);

  void set(String s)
  {
    text_edit.clear();
    text_edit.insertString(s);
  }

  String asStr() const
  {
    return text_edit.asStr();
  }

  b8 isFocused(UI& ui) const;
};


$ if false then

/* ============================================================================
 */
struct InputText : Item
{
  TextEdit text;

  gfx::Font* font;

  struct
  {
    DrawCmd* text;
    DrawCmd* cursor;
    DrawCmd* selection;
  } drawcmds;

  String preview; // Owned.

  static InputText* make(
      UI& ui, 
      String init = nil, 
      String preview = nil,
      String id = nil);

  b8 init(UI& ui, String init = nil, String preview = nil);

  void evaluate(UI* ui) override;
  void generate(UI* ui) override;
  void update(UI* ui, UpdateReason reason) override;
  void cleanup() override;

  void reportDrawCmds(UI* ui, DrawCmdLists& lists) override
  {
    lists.pre_children.push(drawcmds.text);
    lists.pre_children.push(drawcmds.cursor);
  }

  AdjustedSize adjustItemSize(UI* ui, b8 auto_x, b8 auto_y) override;

  // Callbacks to support custom functionality when certain things happen.
  // This is experimental as I'm not sure if its a good idea yet (I don't
  // like to overuse virtual stuff) but it seems like a better alternative to
  // traditional C function pointers and void* context and polling the 
  // InputText constantly for buffer changes.

  virtual void onTextChanged() {}
  virtual void onFocusLost() {}
};

$ end

}

$ end
