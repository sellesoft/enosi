$ require "common"
$ local ui = require "ui.UI"

@@lpp.import "ui/widgets/InputText.lh"

@@lpp.import "Engine.lh"

@@lpp.import "ui/UI.lh"
@@lpp.import "ui/widgets/InputTextSkin.defs.lh"

#include "iro/Logger.h"

#include "ctype.h"

namespace ui
{

@defFileLogger(inputtext, Info)

/* ----------------------------------------------------------------------------
 */
b8 InputText::init(UI& ui, String init, String preview)
{
  ui.registerFocusableId(&fid);

  String text_init = 
    notnil(init)
    ? init
    : notnil(preview)
      ? preview
      : nil;

  if (notnil(preview))
    this->preview = preview.allocateCopy();

  if (!text.init(ui))
  {
    if (notnil(preview))
      mem::stl_allocator.free(this->preview.ptr);

    return false;
  }
  
  decor = ui.drawcmds.add();
  decor->alloc(&ui, gfx::putFilledRectCounts());

  cursor = ui.drawcmds.add();
  cursor->alloc(&ui, gfx::putFilledRectCounts());

  return true;
}

/* ----------------------------------------------------------------------------
 */
void InputText::deinit(UI& ui)
{
  if (notnil(preview))
    mem::stl_allocator.free(preview.ptr);

  decor->remove(&ui);

  text.deinit(ui);
}
static InputText::EditResult updateEditBuffer(
    ItemUpdateContext& ctx,
    TextEdit& text_edit,
    TextEdit::Buffer buffer)
{
  text_edit.setBuffer(buffer);

  b8 cursor_moved = false;
  b8 text_changed = false;
  b8 buffer_too_small = false;

  b8 ctrl_down = 
    ctx.input.isKeyDown(Key::LCtrl) || ctx.input.isKeyDown(Key::RCtrl);
  b8 alt_down = 
    ctx.input.isKeyDown(Key::LAlt) || ctx.input.isKeyDown(Key::RAlt);

$ local function actions(len)
  if (ctx.input.tryConsumePressedKey(Key::Right))
  {
    if (0 != text_edit.cursorMoveRight$(len or "")())
      cursor_moved = true;
  }
  if (ctx.input.tryConsumePressedKey(Key::Left))
  {
    if (0 != text_edit.cursorMoveLeft$(len or "")())
      cursor_moved = true;
  }
  if (ctx.input.tryConsumePressedKey(Key::Backspace))
  {
    if (0 != text_edit.deleteLeft$(len or "")())
      cursor_moved = true;
  }
  if (ctx.input.tryConsumePressedKey(Key::Delete))
  {
    if (0 != text_edit.deleteRight$(len or "")())
      cursor_moved = true;
  }
$ end

  if (ctrl_down)
  {
    @actions "Word"
  }
  else if (alt_down)
  {
    @actions "WordPart"
  }
  else
  {
    @actions
  }

  String instr = ctx.tryConsumeCharInput();
  if (notnil(instr) && !iscntrl(instr.ptr[0]))
  {
    u32 insert_len = text_edit.insertString(instr);

    if (insert_len == 0)
      buffer_too_small = true;
    else
      text_changed = true;
  }

  if (buffer_too_small)
    return InputText::EditResult::OutOfSpace;
  else if (text_changed)
    return InputText::EditResult::TextChanged;
  else if (cursor_moved)
    return InputText::EditResult::Idle;

  return InputText::EditResult::Idle;
}

/* ----------------------------------------------------------------------------
 */
static void computeCursorAndTextOffsets(
    String display,
    const f32 text_width,
    s32 cursor_pos,
    f32* out_text_x_offset,
    f32* out_cursor_offset,
    const InputTextSkinDef& skin)
{
  f32 cursor_offset = 0.f;
  f32 cur_text_x_offset = *out_text_x_offset;
  
  String scan = display;
  for (;;)
  {
    if (cursor_pos == display.len - scan.len ||
        scan.isEmpty())
    {
      if (cursor_offset < cur_text_x_offset)
        *out_text_x_offset = cursor_offset;
      else if (cursor_offset > cur_text_x_offset + text_width)
        *out_text_x_offset = cursor_offset - text_width;
      break;
    }

    gfx::PackedChar pc;
    skin.text.font->getPackedChar(&pc, scan.advance().codepoint);

    cursor_offset += pc.xadvance;
  }

  *out_cursor_offset = cursor_offset;
}

/* ----------------------------------------------------------------------------
 */
static Rect displayText(
    ItemUpdateContext& ctx,
    Text& text, 
    Rect bounds,
    String display, 
    f32 text_x_offset,
    const InputTextSkinDef& skin)
{
  // Scissor text to inside of text box with padding.
  text.setScissor(bounds.contractedX(skin.horizontal_padding));

  // Compute where the text will be placed.
  Rect text_bounds = bounds;
  text_bounds.x -= text_x_offset;
  text_bounds.x += skin.horizontal_padding;
  text_bounds.y += 0.5f * (bounds.h - skin.text.font_height);

  // Ensure the text is aligned to pixels to avoid weird artifacts.
  text_bounds.floorPos();

  text.clear();
  text.draw(ctx.ui, display, text_bounds, skin.text);

  return text_bounds;
}

/* ----------------------------------------------------------------------------
 */
InputText::UpdateResult InputText::update(
    ItemUpdateContext& ctx,
    Rect bounds,
    TextEdit::Buffer buffer,
    const InputTextSkinDef& skin)
{
  UpdateResult result = {};

  result.focus = 
    ctx.testFocus(&fid, bounds, MouseButton::Left, KeyState::Released);

  result.edit = updateEditBuffer(ctx, text_edit, buffer);

  b8 focused = result.focus.test(FocusFlag::Focused);

  String display = text_edit.asStr();
  if (display.isEmpty())
    display = preview;

  f32 cursor_offset = 0.f;
  if (focused)
  {
    computeCursorAndTextOffsets(
      display,
      bounds.contractedX(skin.horizontal_padding).w,
      text_edit.cursor.pos,
      &text_x_offset,
      &cursor_offset,
      skin);
  }

  Rect text_bounds = 
    displayText(
      ctx,
      text,
      bounds,
      display,
      text_x_offset,
      skin);

  if (focused)
  {
    auto [vp, ip] = cursor->getPtrs(&ctx.ui);
    cursor->counts_used = {};

    gfx::putFilledRect(
      vp, ip,
      &cursor->counts_used,
      vec2f(text_bounds.x + cursor_offset, text_bounds.y),
      vec2f(1.f, skin.text.font_height),
      skin.cursor_color);
  }

  Item::drawBackground(ctx.ui, bounds, decor, skin.item);

  return result;
}

/* ----------------------------------------------------------------------------
 */
InputText::UpdateResult InputText::update(
    ItemUpdateContext& ctx, 
    Rect bounds,
    String display,
    const InputTextSkinDef& skin)
{
  UpdateResult result = {};
  
  result.focus = 
    ctx.testFocus(&fid, bounds, MouseButton::Left, KeyState::Released);

  result.edit = EditResult::Idle;

  if (isnil(display))
    display = preview;

  displayText(
    ctx,
    text,
    bounds,
    display,
    text_x_offset,
    skin);

  Item::drawBackground(ctx.ui, bounds, decor, skin.item);

  return result;
}

/* ----------------------------------------------------------------------------
 */
void InputText::reportDrawCmds(UI& ui, DrawCmdLists& lists)
{
  lists.pre_children.push(decor);
  lists.pre_children.push(text.dc);
  if (isFocused(ui))
    lists.pre_children.push(cursor);

}

/* ----------------------------------------------------------------------------
 */
b8 InputText::isFocused(UI& ui) const
{
  return ui.isFocusedId(fid);
}

}
