/*
 *  Widget for drawing text.
 */

$ local cmn = require "common"
$ local ui = require "ui.UI"

@@lpp.import "ui/Item.lh"
@@lpp.import "graphics/Font.lh"

#include "iro/containers/SmallArray.h"
#include "iro/Pair.h"

using namespace iro;

namespace ui
{

struct TextSkinDef;

/* ============================================================================
 */
struct TextBreak
{
  // Offset into the text buffer where this break happens.
  s64 offset;
  // Where to visually place the text.
  vec2f placement;
};

typedef SmallArray<TextBreak, 64> TextBreaks;

/* ============================================================================
 */
struct Text
{
  DrawCmd* dc;

  b8 init(UI& ui);
  void deinit(UI& ui);

  // Draws text *incrementally*, as this widget is meant to be used to 
  // batch several strings that may be separated. clear() may be used to 
  // clear the currently cached text.
  vec2f draw(UI& ui, String text, Rect bounds, const TextSkinDef& skin);

  void setScissor(Rect bounds);

  // Clears any currently drawn text.
  void clear();

  static void put(
    ItemUpdateContext& ctx, 
    Rect bounds, 
    String text, 
    const TextSkinDef& skin);
};

$ if false then

/* ============================================================================
 */
@ui.widget(TextItem,
schema
{
  terminal;

  make { return '"'..parser:expectString()..'"_str' }

  font = inherit;
  font_height = inherit;
  text_color = inherit;

  wrap: enum
  {
    none,
    char,
    word,
  } = none;

  tab_spaces: f32 = 2;
},
struct
{
  TextState state = {};

  void set(String s)
  {
    state.set(s);
  }

  static Text* make(UI& ui, String init = nil, String id = nil);

  virtual void evaluate(UI* ui) override;

  virtual void generate(UI* ui) override;

  virtual void update(UI* ui, UpdateReason reason) override;

  virtual void cleanup() override;

  void reportDrawCmds(UI* ui, DrawCmdLists& lists) override 
  { 
    if (state.dc)
      lists.pre_children.push(state.dc); 
  }
})

$ end

}

