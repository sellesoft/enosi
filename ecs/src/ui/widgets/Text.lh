/*
 *  Widget for drawing text.
 */

$ local lpp = require "lpp"
$ local reflect = require "reflection.Reflector"
$ local ui = require "ui.UI"

@@lpp.import "ui/Item.lh"

#include "iro/containers/SmallArray.h"
#include "iro/Pair.h"

using namespace iro;

struct Font;

namespace ui
{

/* ============================================================================
 */
struct TextBreak
{
  // Offset into the text buffer where this break happens.
  s64 offset;
  // Where to visually place the text.
  vec2f placement;
};

typedef SmallArray<TextBreak, 64> TextBreaks;

/* ============================================================================
 *  Helper for rendering text.
 */
struct TextRenderer
{
  String text;

  vec2f size;
  TextBreaks breaks;

  Font* font;
  f32 font_height;
  f32 tab_spaces;
  f32 max_width;
  u32 wrap;
  Color color;

  void init(
      String text,
      Font* font,
      f32 font_height,
      f32 tab_spaces,
      f32 max_width,
      u32 wrap,
      Color color)
  {
    this->text = text;
    this->font = font;
    this->font_height = font_height;
    this->tab_spaces = tab_spaces;
    this->max_width = max_width;
    this->wrap = wrap;
    this->color = color;
  }

  void deinit()
  {
    text = nil;
    breaks.deinit();
  }

  void findTextBreaks();

  // Draws text at the given position. This overload will call findTextBreaks
  // internally with the provided information. If it has already been called,
  // eg. in the case where the text size needed to be known before hand, you
  // may use the following overload instead.
  void draw(UI* ui, vec2f pos, DrawCmd* dc);
};

/* ============================================================================
 *  General text state for use by widgets that need to display text.
 */
struct TextState
{
  // The loaded font for this text.
  Font* font;

  // The name of the loaded font so we may reload it if the user changes
  // it.
  String font_name;

  // TODO(sushi) replace with text manipulation helper like 
  //             we have in deshi.
  io::Memory buffer;

  DrawCmd* dc;

  TextRenderer* renderer;

  void cacheRenderer();

  void initRenderer(
    f32 font_height,
    f32 tab_spaces,
    f32 max_width,
    u32 wrap,
    Color color);

  void freeRenderer();

  void draw(UI* ui, vec2f pos);

  b8   init(UI* ui, String init);
  void deinit();

  void checkFont(String name, UI* ui);

  operator io::IO*() { return &buffer; }

  void clear()
  {
    buffer.clear();
  }

  void set(String s)
  {
    clear();
    buffer.write(s);
  }
};


/* ============================================================================
 */
@ui.widget(Text,
schema
{
  terminal;

  make { return '"'..parser:expectString()..'"_str' }

  font = inherit;
  font_height = inherit;
  text_color = inherit;

  wrap: enum
  {
    none,
    char,
    word,
  } = none;

  tab_spaces: f32 = 2;
},
struct
{
  TextState state;

  virtual void evaluate(UI* ui) override;

  virtual void generate(UI* ui) override;

  virtual void update(UI* ui, UpdateReason reason) override;

  virtual void cleanup() override;

  virtual void reportDrawCmds(
      UI* ui, 
      DrawCmdList& pre, 
      DrawCmdList& post) override 
  { 
    if (state.dc)
      pre.push(state.dc); 
  }
})

}

