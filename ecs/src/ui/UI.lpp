$ local lpp = require "lpp"
$ local reflect = require "reflect.Reflector"
$ local ui = require "ui.UI"

@@lpp.import "ui/UI.lh"
@@lpp.import "Engine.lh"
@@lpp.import "Engine.events.lh"
@@lpp.import "graphics/Renderer.lh"
@@lpp.import "window/Window.lh"
@@lpp.import "window/Window.events.lh"
@@lpp.import "math/util.h"

#include "iro/logger.h"
#include "iro/containers/SmallArray.h"

using namespace iro;

namespace ui
{

static Logger logger = 
  Logger::create("ui"_str, Logger::Verbosity::Info);

/* ----------------------------------------------------------------------------
 */
b8 UI::initItem(String id, Item* item)
{
  item->name = id;
  item->node = &item_tree.addLast(item_stack.head->data->node, item);
  if (!item->style.init())
    return false;
  item->dirty = true;
  return true;
}

/* ----------------------------------------------------------------------------
 */
template<>
Item* UI::make<Item>(String id)
{
  Item* item = mem::stl_allocator.construct<Item>();
  if (!initItem(id, item))
  {
    mem::stl_allocator.free(item);
    return nullptr;
  }
    
  return item;
}

/* ----------------------------------------------------------------------------
 */
void UI::endItem()
{
  item_stack.pop();
}

/* ----------------------------------------------------------------------------
 */
b8 UI::init(Engine& engine)
{
  gfx::Renderer& renderer = engine.renderer;
  Window& window = engine.window;

  if (!item_stack.init())
    return ERROR("failed to init item stack\n");
  if (!item_tree.init())
    return ERROR("failed to init item tree\n");
  if (!drawcmds.init())
    return ERROR("failed to init drawcmd pool\n");
  if (!free_drawcmds.init())
    return ERROR("failed to init free drawcmds list\n");
  if (!free_drawcmds_vertex_sorted.init())
    return ERROR("failed to init vertex sorted free drawcmds array\n");
  if (!free_drawcmds_index_sorted.init())
    return ERROR("failed to init index sorted free drawcmds array\n");
  if (!fontlib.init())
    return ERROR("failed to init font library\n");
  
  buffer = renderer.createBuffer();
  if (!buffer)
    return ERROR("failed to create gfx::Buffer\n");
  if (!buffer->init(
        sizeof(gfx::Vertex) * 0xffffff, 
        sizeof(gfx::Index) * 0xffffff))
    return ERROR("failed to init gfx::Buffer\n");

  buffer->setGfxAttributes();

  // NOTE(sushi) I do not like making root manually here but in order
  //             to not have to put a branch in make just to handle this
  //             case we have to.
  root = mem::stl_allocator.construct<Item>();
  root->node = &item_tree.add(root);
  if (!root->style.init())
    return ERROR("failed to initialize root style\n");
  root->dirty = true;
  root->visible_start = {0,0};
  root->visible_size = root->size;
  root->name = "root"_str;

  $ local root = ui.createItemContext("Item", "root")

  @root.style.set.pos({0,0});
  @root.style.set.size(vec2f(window.size));

  item_stack.push(root);

  vertex_next = index_next = 0;

  engine.subscribeToBroadcast<WindowResized>(this, &UI::onWindowResized);
  engine.subscribeToBroadcast<PostReload>(this, &UI::onPostReload);

  // Store a reference to the engine incase widgets need to access 
  // information from it.
  eng = &engine;

  return true;
}

/* ----------------------------------------------------------------------------
 */
b8 UI::update(Engine& engine)
{
  TRACE("ui update\n");

  Window& window = eng->window;
  gfx::Renderer& renderer = eng->renderer;
  InputMgr& input = eng->input;

  if (item_stack.head->data != root)
    return ERROR("items left on stack!\n");

  // TODO(sushi) only do this if the mouse moves by subscribing to the 
  //             MouseMoved event, maybe. A lot of other stuff will
  //             also make this need to be retriggered as well.
  findHoveredItem(item_tree.root);

  TRACE("  binding buffer ", buffer, "\n");
  renderer.pushBindBuffer(buffer);

  // renderer.pushUniformVec2(
  //   "scale"_str,
  //   { 2.f / engine.window.size.x, -2.f / engine.window.size.y });

  // renderer.pushUniformVec2(
  //   "translation"_str,
  //   { -1.f, 1.f });

  mat3x2 proj, view;
  mat3x2::calcScreenMatrices(engine.window.size, &proj, &view);

  mat3x2 model = 
    mat3x2::createTransform(
      vec2f(0.f, 0.f),
      0.f);

  renderer.pushUniformMat3x2("proj"_str, proj);
  renderer.pushUniformMat3x2("view"_str, view);
  renderer.pushUniformMat3x2("model"_str, model);

  renderer.pushSetScissor(vec2i(0,0), vec2i(window.size.x, window.size.y));

  TRACE("  mapping buffer\n");
  buffer->map();

  temp_alloc.init();

  updateTree(root->node);

  temp_alloc.deinit();
  
  TRACE("  unmapping buffer\n");
  buffer->unmap();

  // idk
  buffer->num_indexes = buffer->index_size / sizeof(gfx::Index);
  
  if (scrolling_item)
  {
    INFO(scrolling_item->scroll, "\n");
    if (input.wasMouseButtonReleased(MouseButton::Left))
    {
      scrolling_item = nullptr;
    }
    else if (horizontal_scroll)
    {
      vec2f bar_pos, bar_size;
      vec2f handle_pos, handle_size;
      scrolling_item->calcHorizontalScrollBar(
        this,
        &bar_pos,
        &bar_size,
        &handle_pos,
        &handle_size);

      f32 mlx = 
        input.mouse.window.x - scrolling_item->pos_screen.x;

      f32 mte = 
        max(0.f, min(mlx - scrollbar_offset.x, bar_size.x - handle_size.x));

      f32 new_scroll = 
        scrolling_item->max_scroll.x * mte / (bar_size.x - handle_size.x);

      if (new_scroll != scrolling_item->scroll.x)
      {
        scrolling_item->dirty = true;
        scrolling_item->scroll.x = new_scroll;
      }

    }
    else
    {
      vec2f bar_pos, bar_size;
      vec2f handle_pos, handle_size;
      scrolling_item->calcVerticalScrollBar(
        this,
        &bar_pos,
        &bar_size,
        &handle_pos,
        &handle_size);

      vec2f content_start = 
        scrolling_item->adjustCursorStart(this, vec2f(0,0));

      // Find where the cursor is vertically relative to the top edge of the 
      // scroll bar.
      f32 mly = 
        input.mouse.window.y - 
        (scrolling_item->pos_screen.y + content_start.y);

      // Find where the top edge of the handle should be based on the position
      // of the mouse, clamped to the top and bottom edges of the bar.
      f32 mte = 
        max(0.f, min(mly - scrollbar_offset.y, bar_size.y - handle_size.y));

      f32 new_scroll = 
        scrolling_item->max_scroll.y * mte / (bar_size.y - handle_size.y);

      if (new_scroll != scrolling_item->scroll.y)
      {
        scrolling_item->dirty = true;
        scrolling_item->scroll.y = new_scroll;
      }

      scrolling_item->scroll.y = 
        min(0.f, 
            max(scrolling_item->scroll.y, scrolling_item->max_scroll.y));
    }
  }

  return true;
}

/* ----------------------------------------------------------------------------
 */
static ItemNode* findStaticSizedParent(
    UI* ui, 
    ItemNode* node, 
    ItemNode* child)
{
  if (node == ui->root->node)
    return node;

  Item* item = node->data;

  $ local item = ui.createItemContext("Item", "item")
  @@item.style:lookup(sizing)

  if (child == nullptr)
    return findStaticSizedParent(ui, node->parent, node);
  if (!@item.style.sizing.testAny(auto_x, auto_y, flex))
    return node;
  else
    return findStaticSizedParent(ui, node->parent, node);
}

/* ----------------------------------------------------------------------------
 */
void UI::updateTree(ItemNode* node)
{
  gfx::Renderer& renderer = eng->renderer;
  Window& window = eng->window;
  InputMgr& input = eng->input;

  Item* item = node->data;
  Item* parent = (node->parent? node->parent->data : nullptr);

  vec2f init_scroll = item->scroll;
  item->scroll = min(vec2f(0.f,0.f), max(item->scroll, item->max_scroll));
  if (init_scroll != item->scroll)
    item->dirty = true;

  $ local Item = ui.widgets.Item.schema

  $ local item = ui.createItemContext("Item", "item")
  $ local style = item.style

  @@item.style:lookup(overflow)

  $ local parent = ui.createItemContext("Item", "parent", true)

  @@parent.style:lookup(overflow, margin, border)

  // TODO(sushi) doing these look ups every frame for every item kinda
  //             sucks. Maybe try storing a map from item to cached 
  //             information about it that we need here? Sorta defeats the 
  //             purpose of the style map stuff though.
  @@style:lookup(margin, border)
  
$ local tryUpdate = function(reason, cond)
  if (item->update_triggers.test(UpdateReason::$(reason)) && 
      ($(cond or "true")))
    item->update(this, UpdateReason::$(reason));
$ end

  @tryUpdate(Start)

  if (item->isHovered(this, Item::HoverKind::Topmost))
  {
    // Only allow hover and pressed when item is topmost.
    @tryUpdate(MouseHover)
    @tryUpdate(MousePressed, input.anyMouseButtonPressed())
  }
  
  if (item->isHovered(this, Item::HoverKind::Area))
  {
    // Allow other mouse inputs if the item is hovered at all.
    @tryUpdate(MouseReleased, input.anyMouseButtonReleased())
    @tryUpdate(MouseDown, input.anyMouseButtonDown())
    @tryUpdate(MouseScroll, input.scroll != 0.f)
  }

  @tryUpdate(MouseHoverChild, item->isHovered(this, Item::HoverKind::Child))

  if (item->dirty)
  {
    item->dirty = false;
    ItemNode* sspar = findStaticSizedParent(this, node, nullptr);
    
    // TODO(sushi) store a temp allocator here and pass it along with a 
    //             void* to eval and gen functions to allow items 
    //             caching information calculated in evaluate to be 
    //             reused in generate.
    //             Also try to apply this idea to base item evaluation in 
    //             general.. surely there's some data cached on Item that
    //             doesn't need to be and could instead be put in temp 
    //             memory to be read here and in generate.
    // TODO(sushi) try working out a way to tell widgets what exactly 
    //             changed when they are marked dirty so that they can
    //             decide if they actually need to do work.
    // TODO(sushi) don't reevalute an item's branch when it is statically 
    //             sized and all that happened to it is it moved.

    evalItemBranch(sspar, nullptr);
    genItemBranch(sspar);
  }

  @tryUpdate(Fin)

  vec2f scoff;
  vec2f scext;

  if (parent && @parent.style.overflow != @Item.overflow.visible)
  {
    vec2f cpos = 
      item->pos_screen + 
      @style.margin.top_left;
    vec2f csiz = @item.getMarginedArea;

    vec2f ppos = 
      parent->pos_screen + 
      parent->calcContentStart(
        @parent.style.margin,
        @parent.style.border);

    ppos = max(ppos, parent->visible_start);

    vec2f psiz = 
      parent->calcContentArea(
        @parent.style.margin,
        @parent.style.border,
        parent->visible_size);
  
    vec2f pext = ppos + psiz;

    scoff = 
      max(
        vec2f(0,0), 
        max(
          ppos,
          min(
            cpos,
            pext)));
    vec2f br = 
      max(
        ppos,
        min(
          cpos + csiz,
          pext));
    scext = max(vec2f(0,0), br - scoff);
    item->visible_start = 
      max(
        vec2f(0,0),
        max(
          ppos,
          min(
            cpos, 
            pext)));
    br = 
      max(
        ppos,
        min(
          cpos + csiz,
          pext));

    item->visible_size = br - item->visible_start;
  }
  else
  {
    scoff = max(vec2f(0,0), item->pos_screen);
    scext = 
      max(
        vec2f(0,0), 
        min(
          item->pos_screen + item->size, 
          vec2f(window.size)));
    item->visible_start = item->pos_screen;
    item->visible_size = item->size;
  }

  TRACE("item ", item->name, ":",
    "\n     ps: ", item->pos_screen,
    "\n  scoff: ", scoff,
    "\n  scext: ", scext,
    "\n    adj: ", vec2i(scoff.x, window.size.y - (scoff.y+scext.y)),
    "\n");

  // TODO(sushi) we can maybe pull some of these conditions into the 
  //             calculations above to stop doing work much earlier.
  b8 item_in_view = 
    scoff.x < window.size.x && scoff.y < window.size.y &&
    scext.x != 0.f          && scext.y != 0.f          && 
    scoff.x + scext.x > 0.f && scoff.y + scext.y > 0.f;

  auto emitDrawCmd = [&](DrawCmd* drawcmd)
  {
    if (drawcmd->tex)
    {
      TRACE("  drawcmd has tex ", drawcmd->tex, "\n");
      renderer.pushUniformBool("has_texture"_str, true);
      renderer.pushBindTexture(drawcmd->tex);
    }
    else
    {
      TRACE("  drawcmd has no tex\n");
      renderer.pushUniformBool("has_texture"_str, false);
    }

    if (drawcmd->counts_used.y == 0)
      return;

    TRACE("  pushing draw \n",
        "    io: ", drawcmd->index_offset,
        "\n    ic: ", drawcmd->counts_used.y,
        "\n    vo: ", drawcmd->vertex_offset, "\n");

    renderer.pushDraw(
        drawcmd->index_offset,
        drawcmd->counts_used.y,
        drawcmd->vertex_offset);
  };

  auto emitDrawCmds = [&](DrawCmdList& drawcmds)
  {

    TRACE("pushing draw cmds \n");

    for (DrawCmd* drawcmd : drawcmds)
      emitDrawCmd(drawcmd);
  };

  if (item_in_view)
  {
     renderer.pushSetScissor(
      vec2i(scoff.x, window.size.y - (scoff.y+scext.y)), scext);

    // Emit background if we have one.
    if (item->builtin.background)
      emitDrawCmd(item->builtin.background);

    // Ask the Item if it has any drawcmds.
    DrawCmdList precmds;
    precmds.init();
    DrawCmdList postcmds;
    postcmds.init();
    item->reportDrawCmds(this, precmds, postcmds);

    // Emit pre-children commands.
    if (precmds.len != 0)
      emitDrawCmds(precmds);

    // Update child branches if the Item wants us to.
    if (item->shouldPlaceChildren())
    {
      for (ItemNode* child = node->first_child; child; child = child->next)
        updateTree(child);
    }

    // Children likely changed scissor, so we have to set it back.
    renderer.pushSetScissor(
      vec2i(scoff.x, window.size.y - (scoff.y+scext.y)), scext);

    // Emit post-children commands.
    if (postcmds.len != 0)
      emitDrawCmds(postcmds);

    // Draw scrollbars and border when appropriate.
    if (item->builtin.scrollbars && item->max_scroll != vec2f(0.f,0.f))
      emitDrawCmd(item->builtin.scrollbars);
  
    if (item->builtin.borders)
      emitDrawCmd(item->builtin.borders);
  }

  // Handle scrollbar input for this Item if necessary.
  if (scrolling_item == nullptr &&
      input.wasMouseButtonPressed(MouseButton::Left) &&
      item->isHovered(this, Item::HoverKind::Child))
  {
    vec2f bar_pos, bar_size;
    vec2f handle_pos, handle_size;
    
    if (item->max_scroll.y != 0.f)
    {
      item->calcVerticalScrollBar(
        this,
        &bar_pos, &bar_size,
        &handle_pos, &handle_size);

      if (math::pointInRect(
            input.mouse.window,
            handle_pos,
            handle_size))
      {
        scrolling_item = item;
        horizontal_scroll = false;
        scrollbar_offset = input.mouse.window - handle_pos;
      }
    }

    if (scrolling_item == nullptr && item->max_scroll.x != 0.f)
    {
      item->calcHorizontalScrollBar(
        this,
        &bar_pos, &bar_size,
        &handle_pos, &handle_size);

      if (math::pointInRect(
            input.mouse.window,
            handle_pos,
            handle_size))
      {
        scrolling_item = item;
        horizontal_scroll = true;
        scrollbar_offset = input.mouse.window - handle_pos;
      }
    }
  }
}

/* ----------------------------------------------------------------------------
 */
void UI::evalItemBranch(ItemNode* node, FlexContext* parent_flex)
{
  FlexContext flex = {};

  SmallArray<Item*, 16> already_evaluated;
  if (!already_evaluated.init())
  {
    ERROR("failed to initialize already evaluated array\n");
    return;
  }
  defer { already_evaluated.deinit(); };

  Item* item = node->data;
  Item* parent = (node->parent? node->parent->data : nullptr);

  item->dirty = false;

  $ local schema = ui.widgets.Item.schema
  $ local item = ui.createItemContext("Item", "item")
  $ local style = item.style
  $ local parent = ui.createItemContext("Item", "parent", true)

  @@style:lookup(
    margin,
    sizing,
    size,
    padding,
    border,
    display,
    alignment)

  // TODO(sushi) someway to reuse this information as the parent 
  //             will have already been passed at this point so 
  //             we're doing double lookups here.
  @@parent.style:lookup(
    sizing,
    size,
    padding,
    margin,
    border,
    display)

  vec2f area = @item.getMarginedArea;

  b8 hauto = @style.sizing.test(auto_y);
  b8 wauto = @style.sizing.test(auto_x);

  if (!hauto)
  {
    if (@style.sizing.test(flex) && 
        parent_flex && 
        parent_flex->is_container && 
        !parent_flex->disp_horizontal)
    {
      item->size.y = 
        @style.size.y / parent_flex->ratio_sum * parent_flex->effective_size;

      if (parent_flex->n_ceils)
      {
        item->size.y = ceil(item->size.y);
        parent_flex->n_ceils -= 1;
      }
      else
      {
        item->size.y = floor(item->size.y);
      }
    }
    else if (@style.sizing.test(percent_y))
    {
      if (@style.size.height < 0.f)
        ERROR("percent_y is set but height (", @style.size.height, ") is "
              "negative\n");
      else if (@parent.style.sizing.test(percent_y))
        item->size.y = @style.size.height/100.f * 
                       @parent.getPaddedHeight;
      else if (@parent.style.size.height >= 0.f)
        item->size.y = @style.size.height/100.f * 
                       @parent.getPaddedStyleHeight;
      else
      {
        ERROR("precent_y set is set but this item's parent's height is not "
              "explicitly sized\n");
        hauto = true;
      }
    }
    else
      item->size.y = 
        @style.size.y + 
        @style.margin.top + 
        @style.margin.bottom + 
        @style.border.top +
        @style.border.bottom;
  }
  else
    item->size.y = 0.f;

  if (!wauto)
  {
    if (@style.sizing.test(flex) &&
        parent_flex &&
        parent_flex->is_container &&
        parent_flex->disp_horizontal)
    {
      item->size.x = 
        @style.size.x / parent_flex->ratio_sum * parent_flex->effective_size;

      if (parent_flex->n_ceils)
      {
        item->size.x = ceil(item->size.x);
        parent_flex->n_ceils -= 1;
      }
      else
      {
        item->size.x = floor(item->size.x);
      }
    }
    else if (@style.sizing.test(percent_x))
    {
      if (@style.size.width < 0.f)
        ERROR("percent_x set but width set (", @style.size.width, ") is "
        "negative\n");
      else if (@parent.style.sizing.test(percent_x))
        item->size.x = @style.size.width/100.f * @parent.getPaddedWidth;
      else if (@parent.style.size.width >= 0.f)
        item->size.x = @style.size.width/100.f * @parent.getPaddedStyleWidth;
      else
      {
        ERROR("percent_x is set but this item's parent's width is not "
              "explicitly sized\n");
        wauto = true;
      }
    }
    else
      item->size.x = 
        @style.size.x +
        @style.margin.left +
        @style.margin.right +
        @style.border.left +
        @style.border.right;
  }
  else
    item->size.x = 0.f;

  // Determine info needed to flex children if this is a flex container.
  if (@style.display.test(flex))
  {
    b8 is_horizontal = @style.display.test(horizontal);

    flex.is_container = true;
    flex.effective_size = 
      (is_horizontal? 
        @item.getPaddedWidth :
        @item.getPaddedHeight);
    flex.ratio_sum = 0.f;
    flex.disp_horizontal = is_horizontal;

    if (is_horizontal && wauto)
    {
      ERROR("display set to flex and horizontal, but sizing is set to auto "
            "width\n");
      return;
    }
    else if (hauto)
    {
      ERROR("display set to flex and vertical, but sizing is set to auto "
            "height\n");
      return;
    }

    // Perform a first past to figure out the ratio sum.
    for (ItemNode* cnode = node->first_child; cnode; cnode = cnode->next)
    {
      Item* child = cnode->data;

      $ local child = ui.createItemContext("Item", "child")

      @@child.style:lookup(size, sizing, margin)

      if (@child.style.sizing.test(flex))
      {
        flex.ratio_sum += 
          (is_horizontal? @child.style.size.width : @child.style.size.height);
      }
      else
      {
        if ((is_horizontal && @child.style.sizing.test(auto_x)) ||
            @child.style.sizing.test(auto_y))
        {
          // If a child has automatic sizing we can still support using it in
          // flex containers by evaluating it early. When we do this we need
          // to tell the main child eval loop later that it has already been
          // evaluated and we do so by storing the child in already_evaluated.
          evalItemBranch(cnode, &flex);
          flex.effective_size -= 
            (is_horizontal? child->size.x : child->size.y);
          already_evaluated.push(child);
        }
        else if (is_horizontal)
        {
          if (@child.style.sizing.test(percent_x))
          {
            flex.effective_size -= 
              @child.style.size.width / 100.f * item->size.x;
          }
          else
          {
            flex.effective_size -= 
              @child.style.size.x +
              @child.style.margin.left +
              @child.style.margin.right;
          }
        }
        else
        {
          if (@child.style.sizing.test(percent_y))
          {
            flex.effective_size -= 
              @child.style.size.height / 100.f * item->size.y;
          }
          else
          {
            flex.effective_size -= 
              @child.style.size.y + 
              @child.style.margin.top +
              @child.style.margin.bottom;
          }
        }
      }
    }
  }

  Item::AdjustedSize adjusted_size = 
    item->adjustItemSize(
      this,
      wauto,
      hauto);
  if (adjusted_size.disable_auto_x)
    wauto = false;
  if (adjusted_size.disable_auto_y)
    hauto = false;

  // Call item's evaluate callback.
  item->evaluate(this);

  // Evaluate children if the item tells us we should.

  vec2f max_extent = {};
  if (item->shouldPlaceChildren())
  {
    vec2f cursor = 
      @style.margin.top_left + 
      @style.padding.top_left + 
      @style.border.top_left;

    // Allow widgets to adjust where child placement should begin, eg. in the
    // case of a collapsing header. By default this doesn't move the cursor.
    cursor = item->adjustCursorStart(this, cursor);

    // Adjust cursor by this item's scroll.
    cursor += item->scroll;

    cursor = floor(cursor);

    ItemNode* it = 
      (@style.display.test(reverse)? 
        node->last_child :
        node->first_child);

    u32 aeidx = 0;
    while (it) 
    {
      Item* child = it->data;

      $ local child = ui.createItemContext("Item", "child", true)

      @@child.style:lookup(
        display,
        positioning,
        pos,
        anchor,
        sizing,
        margin,
        alignment)

      if (@child.style.display.test(hidden))
      {
        assert(it != it->next);
        it = 
          (@style.display.test(reverse)? 
            it->prev :
            it->next);
        continue;
      }

      if (already_evaluated.len < aeidx && already_evaluated[aeidx] == child)
      {
        aeidx += 1;
      }
      else
      {
        evalItemBranch(child->node, &flex);
      }

$ local placeAnchorSwitch = function(var)
$   local style = child.style
    switch (@style.anchor)
    {
    case @schema.anchor.top_left:
      child->pos_local.x += @style.pos.x;
      child->pos_local.y += @style.pos.y;
      break;

    case @schema.anchor.top_right:
      if (!wauto)
        child->pos_local.x = 
          @item.getPaddedWidth - child->size.x - @style.pos.x;
      else
        ERROR("item's anchor was specified as top_right but the item's width "
              "is set to auto\n");
      child->pos_local.y += @style.pos.y;
      break;

    case @schema.anchor.bottom_right:
      if (!wauto)
        child->pos_local.x = 
          @item.getPaddedWidth - child->size.x - @style.pos.x;
      else
        ERROR("item's anchor was specified as bottom_right but the item's "
              "width is set to auto\n");
      if (!hauto)
        child->pos_local.y = 
          @item.getPaddedHeight - child->size.y - @style.pos.y;
      else
        ERROR("item's anchor was specified as bottom_right but the item's "
              "height is set to auto\n");
      break;

    case @schema.anchor.bottom_left:
      child->pos_local.x += @style.pos.x;
      if (!hauto)
        child->pos_local.y =
          @item.getPaddedHeight - child->size.y - @style.pos.y;
      else
        ERROR("item's anchor was specified as bottom_left but the item's "
              "height is set to auto\n");
      break;
    }
$ end

      switch (@child.style.positioning)
      {
      case @schema.positioning.static:
        if (@style.display.test(horizontal))
        {
          if (!hauto)
          {
            child->pos_local.y = cursor.y +
              @child.style.alignment.y * 
              (@item.getPaddedHeight - child->size.y);
          }
          else
          {
            child->pos_local.y = cursor.y;
          }
          child->pos_local.x = cursor.x;
        }
        else
        {
          if (!wauto)
          {
            child->pos_local.x = cursor.x +
              @child.style.alignment.x * 
              (@item.getPaddedWidth - child->size.x);
          }
          else
          {
            child->pos_local.x = cursor.x;
          }
          child->pos_local.y = cursor.y;
        }

        if (@style.display.test(horizontal))
          cursor.x = child->pos_local.x + child->size.x;
        else
          cursor.y = child->pos_local.y + child->size.y;

        @placeAnchorSwitch

        break;

      case @schema.positioning.relative:
        child->pos_local = 
          @child.style.margin.top_left +
          @style.border.top_left;

        if (@style.display.test(horizontal))
          cursor.x += child->pos_local.x + child->size.x;
        else
          cursor.y += child->pos_local.y + child->size.y;

        @placeAnchorSwitch

        break;

      case @schema.positioning.absolute:
        @placeAnchorSwitch
        break;

      // NOTE(sushi) fixed positioning is handled in gen item branch
      }

      child->pos_local = floor(child->pos_local);

      if (wauto)
        item->size.x = max(item->size.x, child->pos_local.x + child->size.x);
      if (hauto)
        item->size.y = max(item->size.y, child->pos_local.y + child->size.y);

      max_extent = 
        max(
          max_extent, 
          child->pos_local + child->size - item->scroll);

      assert(it != it->next);
      it = 
        (@style.display.test(reverse)? 
          it->prev :
          it->next);
    }
  }

  if (wauto)
  {
    item->size.x += 
      @style.padding.right +
      @style.margin.right +
      @style.border.right;
  }

  if (hauto)
  {
    item->size.y +=
      @style.padding.bottom +
      @style.margin.bottom +
      @style.border.bottom;
  }
  
  item->max_scroll = 
    min(vec2f(0,0),
      item->size - max_extent - 
      @item.style.padding.bottom_right -
      @item.style.border.bottom_right -
      @item.style.margin.bottom_right);

  // item->max_scroll.x = 
  //   min(0.f, item->size.x - max_extent.x - @item.style.padding.right);
  // item->max_scroll.y = 
  //   min(0.f, item->size.y - max_extent.y - @item.style.padding.bottom);

  item->size = max(item->size, item->getMinSize(this));

  item->pos_local = floor(item->pos_local);
}

/* ----------------------------------------------------------------------------
 */
void UI::genItemBranch(ItemNode* node)
{
  InputMgr& input = eng->input;

  Item* item = node->data;

  $ local item = ui.createItemContext("Item", "item")

  @@item.style:lookup(
    display, 
    overflow,
    margin,
    padding,
    border,
    border_color,
    background_color,
    horizontal_scrollbar_height)

  if (@item.style.display.test(hidden))
    return;

  if (item != root)
    item->pos_screen = node->parent->data->pos_screen + item->pos_local;

  item->generate(this);

  if (item->shouldPlaceChildren())
  {
    for (ItemNode* child = node->first_child; child; child = child->next)
      genItemBranch(child);
  }

  // NOTE(sushi) the below logic is forced upon all Items because the base
  //             Item schema provides properties for them. I intend for these 
  //             things to be usable on all items regardless of what widget 
  //             they are. However this sorta sucks cause it means that all
  //             Items must have the builtin drawcmds stored on them regardless
  //             if they use them or not. I have an idea for rewriting UI to
  //             be 'component' based rather than inheritance in which these
  //             things would only exist for the Item when actually used,
  //             but that introduces a lot of complications and I'm hesitant
  //             to experiment with a whole new setup for UI so soon after 
  //             getting it working properly again. For now I'm going to 
  //             continue designing UI to be completely callback based and 
  //             while keeping in mind what problems making it component based
  //             could solve while also trying to determine what new 
  //             problems it could introduce.

  // TODO(sushi) move the following logic into Item::generate and just call it
  //             explicitly here.

  if (@item.style.background_color.a != 0 )
  {
    if (item->builtin.background == nullptr)
    {
      item->builtin.background = drawcmds.add();
      item->builtin.background->alloc(this, gfx::putFilledRectCounts());
    }

    auto [vp, ip] = item->builtin.background->getPtrs(this);

    vec2i sum = {};

    sum += 
      gfx::putFilledRect(
        vp,
        ip,
        sum,
        item->pos_screen + 
        @item.style.margin.top_left + 
        @item.style.padding.top_left,
        @item.getBorderedArea,
        @item.style.background_color);

    item->builtin.background->counts_used = sum;
  }

  // If the item specifies a border draw it.
  if (@item.hasBorder)
  {
    if (item->builtin.borders == nullptr)
    {
      item->builtin.borders = drawcmds.add();
      item->builtin.borders->alloc(this, gfx::putBordersCounts());
    }

    vec2i sum = {};
    auto [vp, ip] = item->builtin.borders->getPtrs(this);

    sum +=
      gfx::putBorders(
        vp,
        ip,
        sum,
        @item.style.border,
        item->pos_screen + 
        @item.style.margin.top_left +
        @item.style.border.top_left,
        @item.getBorderedArea,
        @item.style.border_color);
    
    item->builtin.borders->counts_used = sum;
  }

  // If overflow is set to scroll and this item contains children that 
  // overflow, draw the scroll bars.
  if (@item.style.overflow == @Item.overflow.scroll && 
      (item->max_scroll.x != 0.f || item->max_scroll.y != 0.f))
  {
    if (item->builtin.scrollbars == nullptr)
    {
      // Allocate draw information for this item's scrollbars.
      item->builtin.scrollbars = drawcmds.add();
      item->builtin.scrollbars->alloc(this, gfx::putFilledRectCounts() * 4);
    }

    @@item.style:lookup(
      scrollbar_color,
      scrollbar_handle_color)

    vec2i sum = {};
    auto [vp, ip] = item->builtin.scrollbars->getPtrs(this);

    vec2f bar_pos, bar_size;
    vec2f handle_pos, handle_size;

    Color scrollbar_color = @item.style.scrollbar_color;
    Color scrollbar_handle_color = @item.style.scrollbar_handle_color;

    if (item->max_scroll.y != 0.f)
    {
      item->calcVerticalScrollBar(
        this,
        &bar_pos, &bar_size,
        &handle_pos, &handle_size);

      sum += 
        gfx::putFilledRect(
          vp,
          ip,
          sum,
          bar_pos,
          bar_size,
          @item.style.scrollbar_color);

      sum += 
        gfx::putFilledRect(
          vp,
          ip,
          sum,
          handle_pos,
          handle_size,
          @item.style.scrollbar_handle_color);
    }

    if (item->max_scroll.x != 0.f)
    {
      item->calcHorizontalScrollBar(
        this,
        &bar_pos, &bar_size,
        &handle_pos, &handle_size);

      sum += 
        gfx::putFilledRect(
          vp,
          ip,
          sum,
          bar_pos,
          bar_size,
          @item.style.scrollbar_color);

      sum += 
        gfx::putFilledRect(
          vp,
          ip,
          sum,
          handle_pos,
          handle_size,
          @item.style.scrollbar_handle_color);
    }

    item->builtin.scrollbars->counts_used = sum;
  }
}

/* ----------------------------------------------------------------------------
 */
b8 UI::findHoveredItem(ItemTree::Node* node)
{
  Item* item = node->data;

  $ local item = ui.createItemContext("Item", "item")
  @@item.style:lookup(display)

  if (!@item.style.display.test(hidden) && item->shouldPlaceChildren())
  {
    for (ItemTree::Node* child = node->last_child; child; child = child->prev)
    {
      if (findHoveredItem(child))
        return true;
    }
  }

  if (item->containsPoint(eng->input.mouse.window))
  {
    hovered = item;
    return true;
  }

  return false;
}

/* ----------------------------------------------------------------------------
 */
void UI::onWindowResized(WindowResized& event)
{
  $ local root = ui.createItemContext("Item", "root")
  @root.style.set.size(event.size);
}

/* ----------------------------------------------------------------------------
 */
void UI::onPostReload(PostReload& _)
{
  root->dirty = true;
}

}
