$ local lpp = require "lpp"
$ local reflect = require "reflection.Reflector"
$ local ui = require "ui.UI"

@@lpp.import "ui/UI.lh"
@@lpp.import "ui/Geo.lh"
@@lpp.import "Engine.lh"
@@lpp.import "graphics/Renderer.lh"
@@lpp.import "window/Window.lh"
@@lpp.import "window/WindowEvents.lh"
@@lpp.import "math/util.h"

#include "iro/logger.h"

using namespace iro;

namespace ui
{

static Logger logger = 
  Logger::create("ui"_str, Logger::Verbosity::Info);

/* ----------------------------------------------------------------------------
 */
b8 Context::initItem(str id, Item* item)
{
  item->name = id;
  item->node = &item_tree.addLast(item_stack.head->data->node, item);
  if (!item->style.init())
    return false;
  if (!item->drawcmds.init(1))
  {
    item->style.deinit();
    return false;
  }
  auto* dc = drawcmds.add();
  dc->alloc(this, putFilledRectCounts());
  item->drawcmds.push(dc);
  item->dirty = true;
  return true;
}

/* ----------------------------------------------------------------------------
 */
template<>
Item* Context::make<Item>(str id)
{
  Item* item = mem::stl_allocator.construct<Item>();
  if (!initItem(id, item))
  {
    mem::stl_allocator.free(item);
    return nullptr;
  }
  return item;
}

/* ----------------------------------------------------------------------------
 */
void Context::endItem()
{
  item_stack.pop();
}

/* ----------------------------------------------------------------------------
 */
b8 Context::init(Engine& engine)
{
  gfx::Renderer& renderer = engine.renderer;
  Window& window = engine.window;

  if (!item_stack.init())
    return ERROR("failed to init item stack\n");
  if (!item_tree.init())
    return ERROR("failed to init item tree\n");
  if (!drawcmds.init())
    return ERROR("failed to init drawcmd pool\n");
  if (!free_drawcmds.init())
    return ERROR("failed to init free drawcmds list\n");
  if (!free_drawcmds_vertex_sorted.init())
    return ERROR("failed to init vertex sorted free drawcmds array\n");
  if (!free_drawcmds_index_sorted.init())
    return ERROR("failed to init index sorted free drawcmds array\n");
  if (!fontlib.init())
    return ERROR("failed to init font library\n");
  
  buffer = renderer.createBuffer();
  if (!buffer)
    return ERROR("failed to create gfx::Buffer\n");
  if (!buffer->init(sizeof(ui::Vertex) * 1028, sizeof(ui::Index) * 512))
    return ERROR("failed to init gfx::Buffer\n");

  buffer->setF32AttribF32(
      0, 2, false, sizeof(ui::Vertex), offsetof(ui::Vertex, pos));
  buffer->setF32AttribF32(
      1, 2, false, sizeof(ui::Vertex), offsetof(ui::Vertex, uv));
  buffer->setF32AttribU8(
      2, 4, true,  sizeof(ui::Vertex), offsetof(ui::Vertex, color));

  // NOTE(sushi) I do not like making root manually here but in order
  //             to not have to put a branch in make just to handle this
  //             case we have to.
  root = mem::stl_allocator.construct<Item>();
  root->node = &item_tree.add(root);
  if (!root->style.init())
    return ERROR("failed to initialize root style\n");
  if (!root->drawcmds.init())
    return ERROR("failed to initialize root drawcmds\n");
  root->dirty = true;
  root->visible_start = {0,0};
  root->visible_size = root->size;
  root->name = "root"_str;

  $ local root = ui.createItemContext("Item", "root")

  @root.style.set.pos({0,0});
  @root.style.set.size(vec2f(window.size));

  item_stack.push(root);

  vertex_next = index_next = 0;

  engine.subscribeToBroadcast<WindowResized>(this, &Context::onWindowResized);

  // Store a reference to the engine incase widgets need to access 
  // information from it.
  eng = &engine;

  return true;
}

/* ----------------------------------------------------------------------------
 */
b8 Context::update(Engine& engine)
{
  if (item_stack.head->data != root)
    return ERROR("items left on stack!\n");

  // TODO(sushi) only do this if the mouse moves by subscribing to the 
  //             MouseMoved event, maybe. A lot of other stuff will
  //             also make this need to be retriggered as well.
  findHoveredItem(item_tree.root);

  engine.renderer.pushBindBuffer(buffer);

  engine.renderer.pushUniformVec2(
    "scale"_str,
    { 2.f / engine.window.size.x, -2.f / engine.window.size.y });

  engine.renderer.pushUniformVec2(
    "translation"_str,
    { -1.f, 1.f });

  buffer->map();

  updateTree(root->node, engine);
  
  buffer->unmap();

  // idk
  buffer->num_indexes = buffer->index_size / sizeof(Index);
  
  return true;
}

/* ----------------------------------------------------------------------------
 */
static ItemNode* findStaticSizedParent(
    Context* ctx, 
    ItemNode* node, 
    ItemNode* child)
{
  if (node == ctx->root->node)
    return node;

  Item* item = node->data;

  $ local item = ui.createItemContext("Item", "item")
  @@item.style:lookup(sizing)

  if (child == nullptr)
    return findStaticSizedParent(ctx, node->parent, node);
  if (@item.style.sizing.testAny(auto_x, auto_y, flex))
    return node;
  else
    return findStaticSizedParent(ctx, node->parent, node);
}

/* ----------------------------------------------------------------------------
 */
void Context::updateTree(ItemNode* node, Engine& engine)
{
  gfx::Renderer renderer = engine.renderer;
  Window& window = engine.window;
  InputMgr& input = engine.input;

  Item* item = node->data;
  Item* parent = (node->parent? node->parent->data : nullptr);

  $ local item = ui.createItemContext("Item", "item")
  $ local style = item.style

  // TODO(sushi) doing these look ups every frame for every item kinda
  //             sucks. Maybe try storing a map from item to cached 
  //             information about it that we need here? Sorta defeats the 
  //             purpose of the style map stuff though.
  @@style:lookup(margin, border, update_triggers)
  
$ local tryUpdate = function(reason, cond)
  if ($(style.update_triggers.test(reason)) && ($(cond or "true")))
    item->update(this, UpdateReason::$(reason));
$ end

  @tryUpdate(DirtyBeforeEval, item->dirty)

  if (item->isHovered(this, Item::HoverKind::Topmost))
  {
    // Only allow hover and pressed when item is topmost.
    @tryUpdate(MouseHover)
    @tryUpdate(MousePressed, input.anyMouseButtonPressed())
  }
  
  if (item->isHovered(this, Item::HoverKind::Area))
  {
    // Allow other mouse inputs if the item is hovered at all.
    @tryUpdate(MouseReleased, input.anyMouseButtonReleased())
    @tryUpdate(MouseDown, input.anyMouseButtonDown())
    @tryUpdate(MouseScroll, input.scroll != 0.f)
  }

  @tryUpdate(MouseHoverChild, item->isHovered(this, Item::HoverKind::Child))

  if (item->dirty)
  {
    item->dirty = false;
    ItemNode* sspar = findStaticSizedParent(this, node, nullptr);
    
    // TODO(sushi) store a temp allocator here and pass it along with a 
    //             void* to eval and gen functions to allow items 
    //             caching information calculated in evaluate to be 
    //             reused in generate.
    //             Also try to apply this idea to base item evaluation in 
    //             general.. surely there's some data cached on Item that
    //             doesn't need to be and could instead be put in temp 
    //             memory to be read here and in generate.
    // TODO(sushi) try working out a way to tell widgets what exactly 
    //             changed when they are marked dirty so that they can
    //             decide if they actually need to do work.
    // TODO(sushi) don't reevalute an item's branch when it is statically 
    //             sized and all that happened to it is it moved.

    evalItemBranch(sspar);
    genItemBranch(sspar);
  }

  @tryUpdate(DirtyAfterEval)

  vec2f scoff;
  vec2f scext;

  if (parent)
  {
    vec2f cpos = 
      item->pos_screen + 
      @style.margin.top_left + 
      @style.border.top_left;
    vec2f csiz = @item.getBorderedArea;

    scoff = 
      max(
        vec2f(0,0), 
        max(
          parent->visible_start, 
          min(
            item->pos_screen,
            parent->visible_start + parent->visible_size)));
    vec2f br = 
      max(
        parent->visible_start,
        min(
          item->pos_screen + item->size,
          parent->visible_start + parent->visible_size));
    scext = max(vec2f(0,0), br - scoff);
    item->visible_start = 
      max(
        vec2f(0,0),
        max(
          parent->visible_start,
          min(
            cpos, 
            parent->visible_start + parent->visible_size)));
    br = 
      max(
        parent->visible_start, 
        min(
          cpos + csiz,
          parent->visible_start + parent->visible_size));

    item->visible_size = br - item->visible_start;
  }
  else
  {
    scoff = max(vec2f(0,0), item->pos_screen);
    scext = 
      max(
        vec2f(0,0), 
        min(
          item->pos_screen + item->size, 
          vec2f(window.size)));
    item->visible_start = item->pos_screen;
    item->visible_size = item->size;
  }

  // TODO(sushi) we can maybe pull some of these conditions into the 
  //             calculations above to stop doing work much earlier.
  if (scoff.x < window.size.x && scoff.y < window.size.y &&
      scext.x != 0.f          && scext.y != 0.f          && 
      scoff.x + scext.x > 0.f && scoff.y + scext.y > 0.f)
  {
    for (DrawCmd* drawcmd : item->drawcmds)
    {
      if (drawcmd->tex)
      {
        renderer.pushUniformBool("has_texture"_str, true);
        renderer.pushBindTexture(drawcmd->tex);
      }
      else
      {
        renderer.pushUniformBool("has_texture"_str, false);
      }

      renderer.pushDraw(
        drawcmd->index_offset,
        drawcmd->counts_used.y,
        drawcmd->vertex_offset);
    }
  }

  for (ItemNode* child = node->first_child; child; child = child->next)
  {
    updateTree(child, engine);
  }
}

/* ----------------------------------------------------------------------------
 */
void Context::evalItemBranch(ItemNode* node)
{
  Item* item = node->data;
  Item* parent = (node->parent? node->parent->data : nullptr);

  $ local schema = ui.schemas.Item
  $ local item = ui.createItemContext("Item", "item")
  $ local style = item.style
  $ local parent = ui.createItemContext("Item", "parent", true)

  @@style:lookup(
    margin,
    sizing,
    size,
    padding,
    border,
    display)

  // TODO(sushi) someway to reuse this information as the parent 
  //             will have already been passed at this point so 
  //             we're doing double lookups here.
  @@parent.style:lookup(
    sizing,
    size,
    padding,
    margin,
    border)

  vec2f area = @item.getMarginedArea;

  b8 hauto = @style.sizing.test(auto_y);
  b8 wauto = @style.sizing.test(auto_x);

  if (!hauto)
  {
    if (@style.sizing.test(percent_y))
    {
      if (@style.size.height < 0.f)
        ERROR("percent_y is set but height (", @style.size.height, ") is "
              "negative\n");
      else if (@parent.style.sizing.test(percent_y))
        item->size.y = @style.size.height/100.f * 
                       @parent.getPaddedHeight;
      else if (@parent.style.size.height >= 0.f)
        item->size.y = @style.size.height/100.f * 
                       @parent.getPaddedStyleHeight;
      else
      {
        ERROR("precent_y set is set but this item's parent's height is not "
              "explicitly sized\n");
        hauto = true;
      }
    }
    else
      item->size.y = 
        @style.size.y + 
        @style.margin.top + 
        @style.margin.bottom + 
        @style.border.top +
        @style.border.bottom;
  }
  else
    item->size.y = 0.f;

  if (!wauto)
  {
    if (@style.sizing.test(percent_x))
    {
      if (@style.size.width < 0.f)
        ERROR("percent_x set but width set (", @style.size.width, ") is "
        "negative\n");
      else if (@parent.style.sizing.test(percent_x))
        item->size.x = @style.size.width/100.f * @parent.getPaddedWidth;
      else if (@parent.style.size.width >= 0.f)
        item->size.x = @style.size.width/100.f * @parent.getPaddedStyleWidth;
      else
      {
        ERROR("percent_x is set but this item's parent's width is not "
              "explicitly sized\n");
        wauto = true;
      }
    }
    else
      item->size.x = 
        @style.size.x +
        @style.margin.left +
        @style.margin.right +
        @style.border.left +
        @style.border.right;
  }
  else
    item->size.x = 0.f;

  // Call item's evaluate callback.
  item->evaluate(this);

  // Evaluate children.
  
  vec2f cursor = 
    @style.margin.top_left + 
    @style.padding.top_left + 
    @style.border.top_left;

  ItemNode* it = 
    (@style.display.test(reverse)? 
      node->last_child :
      node->first_child);

  u32 idx = 0;
  while (it) 
  {
    Item* child = it->data;

    $ local child = ui.createItemContext("Item", "child", true)

    @@child.style:lookup(
      display,
      positioning,
      pos,
      anchor,
      margin)

    if (@child.style.display.test(hidden))
    {
      idx += 1;
      assert(it != it->next);
      it = 
        (@style.display.test(reverse)? 
          it->prev :
          it->next);
      continue;
    }

    evalItemBranch(child->node);

$ local placeAnchorSwitch = function(var)
$   local style = child.style
    switch (@style.anchor)
    {
    case @schema.anchor.top_left:
      child->pos_local.x += @style.pos.x;
      child->pos_local.y += @style.pos.y;
      break;

    case @schema.anchor.top_right:
      if (!wauto)
        child->pos_local.x = 
          @item.getPaddedWidth - child->size.x - @style.pos.x;
      else
        ERROR("item's anchor was specified as top_right but the item's width "
              "is set to auto\n");
      child->pos_local.y += @style.pos.y;
      break;

    case @schema.anchor.bottom_right:
      if (!wauto)
        child->pos_local.x = 
          @item.getPaddedWidth - child->size.x - @style.pos.x;
      else
        ERROR("item's anchor was specified as bottom_right but the item's "
              "width is set to auto\n");
      if (!hauto)
        child->pos_local.y = 
          @item.getPaddedHeight - child->size.y - @style.pos.y;
      else
        ERROR("item's anchor was specified as bottom_right but the item's "
              "height is set to auto\n");
      break;

    case @schema.anchor.bottom_left:
      child->pos_local.x += @style.pos.x;
      if (!hauto)
        child->pos_local.y =
          @item.getPaddedHeight - child->size.y - @style.pos.y;
      else
        ERROR("item's anchor was specified as bottom_left but the item's "
              "height is set to auto\n");
      break;
    }
$ end

    switch (@child.style.positioning)
    {
    case @schema.positioning.static:
      child->pos_local = cursor;
      if (@style.display.test(horizontal))
        cursor.x = child->pos_local.x + child->size.x;
      else
        cursor.y = child->pos_local.y + child->size.y;

      @placeAnchorSwitch

      break;

    case @schema.positioning.relative:
      child->pos_local = 
        @child.style.margin.top_left +
        @style.border.top_left;

      if (@style.display.test(horizontal))
        cursor.x += child->pos_local.x + child->size.x;
      else
        cursor.y += child->pos_local.y + child->size.y;

      @placeAnchorSwitch

      break;

    case @schema.positioning.absolute:
      @placeAnchorSwitch
      break;

    // NOTE(sushi) fixed positioning is handled in gen item branch
    }

    child->pos_local = floor(child->pos_local);

    if (wauto)
      item->size.x = max(item->size.x, child->pos_local.x + child->size.x);
    if (hauto)
      item->size.y = max(item->size.y, child->pos_local.y + child->size.y);

    idx += 1;
    assert(it != it->next);
    it = 
      (@style.display.test(reverse)? 
        it->prev :
        it->next);
  }

  if (wauto)
  {
    item->size.x += 
      @style.padding.right +
      @style.margin.right +
      @style.border.right;
  }

  if (hauto)
  {
    item->size.y +=
      @style.padding.bottom +
      @style.margin.bottom +
      @style.border.bottom;
  }

  item->pos_local = floor(item->pos_local);
}

/* ----------------------------------------------------------------------------
 */
void Context::genItemBranch(ItemNode* node)
{
  Item* item = node->data;

  $ local item = ui.createItemContext("Item", "item")

  @@item.style:lookup(display)

  if (@item.style.display.test(hidden))
    return;

  if (item != root)
  {
    item->pos_screen = node->parent->data->pos_screen + item->pos_local;
  }

  if (item->drawcmds.len() != 0)
    item->generate(this);

  for (ItemNode* child = node->first_child; child; child = child->next)
    genItemBranch(child);
}

/* ----------------------------------------------------------------------------
 */
b8 Context::findHoveredItem(ItemTree::Node* node)
{
  Item* item = node->data;

  $ local item = ui.createItemContext("Item", "item")
  @@item.style:lookup(display)

  for (ItemTree::Node* child = node->last_child; child; child = child->prev)
  {
    if (!@item.style.display.test(hidden))
    {
      if (findHoveredItem(child))
        return true;
    }
  }

  if (item->containsPoint(eng->input.mouse.window))
  {
    hovered = item;
    return true;
  }

  return false;
}

/* ----------------------------------------------------------------------------
 */
void Context::onWindowResized(WindowResized& event)
{
  $ local root = ui.createItemContext("Item", "root")
  @root.style.set.size(event.size);
}

}
