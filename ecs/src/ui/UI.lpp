$ local lpp = require "lpp"
$ local reflect = require "reflection.Reflector"
$ local ui = require "ui.UI"

@@lpp.import "ui/UI.lh"
@@lpp.import "ui/Geo.lh"
@@lpp.import "Engine.lh"
@@lpp.import "graphics/Renderer.lh"
@@lpp.import "window/Window.lh"
@@lpp.import "window/WindowEvents.lh"
@@lpp.import "math/util.h"

#include "iro/logger.h"
#include "iro/containers/SmallArray.h"

using namespace iro;

namespace ui
{

static Logger logger = 
  Logger::create("ui"_str, Logger::Verbosity::Info);

/* ----------------------------------------------------------------------------
 */
b8 UI::initItem(str id, Item* item)
{
  item->name = id;
  item->node = &item_tree.addLast(item_stack.head->data->node, item);
  if (!item->style.init())
    return false;
  if (!item->drawcmds.init(1))
  {
    item->style.deinit();
    return false;
  }
  item->dirty = true;
  return true;
}

/* ----------------------------------------------------------------------------
 */
template<>
Item* UI::make<Item>(str id)
{
  Item* item = mem::stl_allocator.construct<Item>();
  if (!initItem(id, item))
  {
    mem::stl_allocator.free(item);
    return nullptr;
  }
    
  auto* dc = drawcmds.add();
  dc->alloc(this, putFilledRectCounts());
  item->drawcmds.push(dc);

  return item;
}

/* ----------------------------------------------------------------------------
 */
void UI::endItem()
{
  item_stack.pop();
}

/* ----------------------------------------------------------------------------
 */
b8 UI::init(Engine& engine)
{
  gfx::Renderer& renderer = engine.renderer;
  Window& window = engine.window;

  if (!item_stack.init())
    return ERROR("failed to init item stack\n");
  if (!item_tree.init())
    return ERROR("failed to init item tree\n");
  if (!drawcmds.init())
    return ERROR("failed to init drawcmd pool\n");
  if (!free_drawcmds.init())
    return ERROR("failed to init free drawcmds list\n");
  if (!free_drawcmds_vertex_sorted.init())
    return ERROR("failed to init vertex sorted free drawcmds array\n");
  if (!free_drawcmds_index_sorted.init())
    return ERROR("failed to init index sorted free drawcmds array\n");
  if (!fontlib.init())
    return ERROR("failed to init font library\n");
  
  buffer = renderer.createBuffer();
  if (!buffer)
    return ERROR("failed to create gfx::Buffer\n");
  if (!buffer->init(sizeof(ui::Vertex) * 1028, sizeof(ui::Index) * 512))
    return ERROR("failed to init gfx::Buffer\n");

  buffer->setF32AttribF32(
      0, 2, false, sizeof(ui::Vertex), offsetof(ui::Vertex, pos));
  buffer->setF32AttribF32(
      1, 2, false, sizeof(ui::Vertex), offsetof(ui::Vertex, uv));
  buffer->setF32AttribU8(
      2, 4, true,  sizeof(ui::Vertex), offsetof(ui::Vertex, color));

  // NOTE(sushi) I do not like making root manually here but in order
  //             to not have to put a branch in make just to handle this
  //             case we have to.
  root = mem::stl_allocator.construct<Item>();
  root->node = &item_tree.add(root);
  if (!root->style.init())
    return ERROR("failed to initialize root style\n");
  if (!root->drawcmds.init())
    return ERROR("failed to initialize root drawcmds\n");
  root->dirty = true;
  root->visible_start = {0,0};
  root->visible_size = root->size;
  root->name = "root"_str;

  $ local root = ui.createItemContext("Item", "root")

  @root.style.set.pos({0,0});
  @root.style.set.size(vec2f(window.size));

  item_stack.push(root);

  vertex_next = index_next = 0;

  engine.subscribeToBroadcast<WindowResized>(this, &UI::onWindowResized);

  // Store a reference to the engine incase widgets need to access 
  // information from it.
  eng = &engine;

  return true;
}

/* ----------------------------------------------------------------------------
 */
b8 UI::update(Engine& engine)
{
  TRACE("ui update\n");

  if (item_stack.head->data != root)
    return ERROR("items left on stack!\n");

  // TODO(sushi) only do this if the mouse moves by subscribing to the 
  //             MouseMoved event, maybe. A lot of other stuff will
  //             also make this need to be retriggered as well.
  findHoveredItem(item_tree.root);

  TRACE("  binding buffer ", buffer, "\n");
  engine.renderer.pushBindBuffer(buffer);

  engine.renderer.pushUniformVec2(
    "scale"_str,
    { 2.f / engine.window.size.x, -2.f / engine.window.size.y });

  engine.renderer.pushUniformVec2(
    "translation"_str,
    { -1.f, 1.f });

  TRACE("  mapping buffer\n");
  buffer->map();

  updateTree(root->node, engine);
  
  TRACE("  unmapping buffer\n");
  buffer->unmap();

  // idk
  buffer->num_indexes = buffer->index_size / sizeof(Index);
  
  return true;
}

/* ----------------------------------------------------------------------------
 */
static ItemNode* findStaticSizedParent(
    UI* ui, 
    ItemNode* node, 
    ItemNode* child)
{
  if (node == ui->root->node)
    return node;

  Item* item = node->data;

  $ local item = ui.createItemContext("Item", "item")
  @@item.style:lookup(sizing)

  if (child == nullptr)
    return findStaticSizedParent(ui, node->parent, node);
  if (@item.style.sizing.testAny(auto_x, auto_y, flex))
    return node;
  else
    return findStaticSizedParent(ui, node->parent, node);
}

/* ----------------------------------------------------------------------------
 */
void UI::updateTree(ItemNode* node, Engine& engine)
{
  gfx::Renderer& renderer = engine.renderer;
  Window& window = engine.window;
  InputMgr& input = engine.input;

  Item* item = node->data;
  Item* parent = (node->parent? node->parent->data : nullptr);

  $ local item = ui.createItemContext("Item", "item")
  $ local style = item.style

  // TODO(sushi) doing these look ups every frame for every item kinda
  //             sucks. Maybe try storing a map from item to cached 
  //             information about it that we need here? Sorta defeats the 
  //             purpose of the style map stuff though.
  @@style:lookup(margin, border, update_triggers)
  
$ local tryUpdate = function(reason, cond)
  if ($(style.update_triggers.test(reason)) && ($(cond or "true")))
    item->update(this, UpdateReason::$(reason));
$ end

  @tryUpdate(DirtyBeforeEval, item->dirty)

  if (item->isHovered(this, Item::HoverKind::Topmost))
  {
    // Only allow hover and pressed when item is topmost.
    @tryUpdate(MouseHover)
    @tryUpdate(MousePressed, input.anyMouseButtonPressed())
  }
  
  if (item->isHovered(this, Item::HoverKind::Area))
  {
    // Allow other mouse inputs if the item is hovered at all.
    @tryUpdate(MouseReleased, input.anyMouseButtonReleased())
    @tryUpdate(MouseDown, input.anyMouseButtonDown())
    @tryUpdate(MouseScroll, input.scroll != 0.f)
  }

  @tryUpdate(MouseHoverChild, item->isHovered(this, Item::HoverKind::Child))

  if (item->dirty)
  {
    item->dirty = false;
    ItemNode* sspar = findStaticSizedParent(this, node, nullptr);
    
    // TODO(sushi) store a temp allocator here and pass it along with a 
    //             void* to eval and gen functions to allow items 
    //             caching information calculated in evaluate to be 
    //             reused in generate.
    //             Also try to apply this idea to base item evaluation in 
    //             general.. surely there's some data cached on Item that
    //             doesn't need to be and could instead be put in temp 
    //             memory to be read here and in generate.
    // TODO(sushi) try working out a way to tell widgets what exactly 
    //             changed when they are marked dirty so that they can
    //             decide if they actually need to do work.
    // TODO(sushi) don't reevalute an item's branch when it is statically 
    //             sized and all that happened to it is it moved.

    evalItemBranch(sspar, nullptr);
    genItemBranch(sspar);
  }

  @tryUpdate(DirtyAfterEval)

  vec2f scoff;
  vec2f scext;

  if (parent)
  {
    vec2f cpos = 
      item->pos_screen + 
      @style.margin.top_left + 
      @style.border.top_left;
    vec2f csiz = @item.getBorderedArea;

    scoff = 
      max(
        vec2f(0,0), 
        max(
          parent->visible_start, 
          min(
            cpos,
            parent->visible_start + parent->visible_size)));
    vec2f br = 
      max(
        parent->visible_start,
        min(
          cpos + csiz,
          parent->visible_start + parent->visible_size));
    scext = max(vec2f(0,0), br - scoff);
    item->visible_start = 
      max(
        vec2f(0,0),
        max(
          parent->visible_start,
          min(
            cpos, 
            parent->visible_start + parent->visible_size)));
    br = 
      max(
        parent->visible_start, 
        min(
          cpos + csiz,
          parent->visible_start + parent->visible_size));

    item->visible_size = br - item->visible_start;
  }
  else
  {
    scoff = max(vec2f(0,0), item->pos_screen);
    scext = 
      max(
        vec2f(0,0), 
        min(
          item->pos_screen + item->size, 
          vec2f(window.size)));
    item->visible_start = item->pos_screen;
    item->visible_size = item->size;
  }

  TRACE("item ", item->name, ":",
    "\n     ps: ", item->pos_screen,
    "\n  scoff: ", scoff,
    "\n  scext: ", scext,
    "\n");

  // TODO(sushi) we can maybe pull some of these conditions into the 
  //             calculations above to stop doing work much earlier.
  if (scoff.x < window.size.x && scoff.y < window.size.y &&
      scext.x != 0.f          && scext.y != 0.f          && 
      scoff.x + scext.x > 0.f && scoff.y + scext.y > 0.f)
  {
    renderer.pushSetScissor(
      vec2i(scoff.x, window.size.y - (scoff.y+scext.y)), scext);

    TRACE("pushing draw cmds for item '", item->name, "'\n");

    for (DrawCmd* drawcmd : item->drawcmds)
    {
      if (drawcmd->tex)
      {
        TRACE("  drawcmd has tex ", drawcmd->tex, "\n");
        renderer.pushUniformBool("has_texture"_str, true);
        renderer.pushBindTexture(drawcmd->tex);
      }
      else
      {
        TRACE("  drawcmd has no tex\n");
        renderer.pushUniformBool("has_texture"_str, false);
      }

      if (drawcmd->counts_used.y == 0)
        continue;

      TRACE("  pushing draw \n",
            "    io: ", drawcmd->index_offset,
          "\n    ic: ", drawcmd->counts_used.y,
          "\n    vo: ", drawcmd->vertex_offset, "\n");
      renderer.pushDraw(
        drawcmd->index_offset,
        drawcmd->counts_used.y,
        drawcmd->vertex_offset);
    }
  }

  if (item->shouldPlaceChildren())
  {
    for (ItemNode* child = node->first_child; child; child = child->next)
      updateTree(child, engine);
  }
}

/* ----------------------------------------------------------------------------
 */
void UI::evalItemBranch(ItemNode* node, FlexContext* parent_flex)
{
  FlexContext flex = {};

  SmallArray<Item*, 16> already_evaluated;
  if (!already_evaluated.init())
  {
    ERROR("failed to initialize already evaluated array\n");
    return;
  }
  defer { already_evaluated.deinit(); };

  Item* item = node->data;
  Item* parent = (node->parent? node->parent->data : nullptr);

  item->dirty = false;

  $ local schema = ui.widgets.Item.schema
  $ local item = ui.createItemContext("Item", "item")
  $ local style = item.style
  $ local parent = ui.createItemContext("Item", "parent", true)

  @@style:lookup(
    margin,
    sizing,
    size,
    padding,
    border,
    display,
    alignment)

  // TODO(sushi) someway to reuse this information as the parent 
  //             will have already been passed at this point so 
  //             we're doing double lookups here.
  @@parent.style:lookup(
    sizing,
    size,
    padding,
    margin,
    border,
    display)

  vec2f area = @item.getMarginedArea;

  b8 hauto = @style.sizing.test(auto_y);
  b8 wauto = @style.sizing.test(auto_x);

  if (!hauto)
  {
    if (@style.sizing.test(flex) && 
        parent_flex && 
        parent_flex->is_container && 
        !parent_flex->disp_horizontal)
    {
      item->size.y = 
        @style.size.y / parent_flex->ratio_sum * parent_flex->effective_size;

      if (parent_flex->n_ceils)
      {
        item->size.y = ceil(item->size.y);
        parent_flex->n_ceils -= 1;
      }
      else
      {
        item->size.y = floor(item->size.y);
      }
    }
    else if (@style.sizing.test(percent_y))
    {
      if (@style.size.height < 0.f)
        ERROR("percent_y is set but height (", @style.size.height, ") is "
              "negative\n");
      else if (@parent.style.sizing.test(percent_y))
        item->size.y = @style.size.height/100.f * 
                       @parent.getPaddedHeight;
      else if (@parent.style.size.height >= 0.f)
        item->size.y = @style.size.height/100.f * 
                       @parent.getPaddedStyleHeight;
      else
      {
        ERROR("precent_y set is set but this item's parent's height is not "
              "explicitly sized\n");
        hauto = true;
      }
    }
    else
      item->size.y = 
        @style.size.y + 
        @style.margin.top + 
        @style.margin.bottom + 
        @style.border.top +
        @style.border.bottom;
  }
  else
    item->size.y = 0.f;

  if (!wauto)
  {
    if (@style.sizing.test(flex) &&
        parent_flex &&
        parent_flex->is_container &&
        parent_flex->disp_horizontal)
    {
      item->size.x = 
        @style.size.x / parent_flex->ratio_sum * parent_flex->effective_size;

      if (parent_flex->n_ceils)
      {
        item->size.x = ceil(item->size.x);
        parent_flex->n_ceils -= 1;
      }
      else
      {
        item->size.x = floor(item->size.x);
      }
    }
    else if (@style.sizing.test(percent_x))
    {
      if (@style.size.width < 0.f)
        ERROR("percent_x set but width set (", @style.size.width, ") is "
        "negative\n");
      else if (@parent.style.sizing.test(percent_x))
        item->size.x = @style.size.width/100.f * @parent.getPaddedWidth;
      else if (@parent.style.size.width >= 0.f)
        item->size.x = @style.size.width/100.f * @parent.getPaddedStyleWidth;
      else
      {
        ERROR("percent_x is set but this item's parent's width is not "
              "explicitly sized\n");
        wauto = true;
      }
    }
    else
      item->size.x = 
        @style.size.x +
        @style.margin.left +
        @style.margin.right +
        @style.border.left +
        @style.border.right;
  }
  else
    item->size.x = 0.f;

  // Determine info needed to flex children if this is a flex container.
  if (@style.display.test(flex))
  {
    b8 is_horizontal = @style.display.test(horizontal);

    flex.is_container = true;
    flex.effective_size = 
      (is_horizontal? 
        @item.getPaddedWidth :
        @item.getPaddedHeight);
    flex.ratio_sum = 0.f;
    flex.disp_horizontal = is_horizontal;

    if (is_horizontal && wauto)
    {
      ERROR("display set to flex and horizontal, but sizing is set to auto "
            "width\n");
      return;
    }
    else if (hauto)
    {
      ERROR("display set to flex and vertical, but sizing is set to auto "
            "height\n");
      return;
    }

    // Perform a first past to figure out the ratio sum.
    for (ItemNode* cnode = node->first_child; cnode; cnode = cnode->next)
    {
      Item* child = cnode->data;

      $ local child = ui.createItemContext("Item", "child")

      @@child.style:lookup(size, sizing, margin)

      if (@child.style.sizing.test(flex))
      {
        flex.ratio_sum += 
          (is_horizontal? @child.style.size.width : @child.style.size.height);
      }
      else
      {
        if ((is_horizontal && @child.style.sizing.test(auto_x)) ||
            @child.style.sizing.test(auto_y))
        {
          // If a child has automatic sizing we can still support using it in
          // flex containers by evaluating it early. When we do this we need
          // to tell the main child eval loop later that it has already been
          // evaluated and we do so by storing the child in already_evaluated.
          evalItemBranch(cnode, &flex);
          flex.effective_size -= 
            (is_horizontal? child->size.x : child->size.y);
          already_evaluated.push(child);
        }
        else if (is_horizontal)
        {
          if (@child.style.sizing.test(percent_x))
          {
            flex.effective_size -= 
              @child.style.size.width / 100.f * item->size.x;
          }
          else
          {
            flex.effective_size -= 
              @child.style.size.x +
              @child.style.margin.left +
              @child.style.margin.right;
          }
        }
        else
        {
          if (@child.style.sizing.test(percent_y))
          {
            flex.effective_size -= 
              @child.style.size.height / 100.f * item->size.y;
          }
          else
          {
            flex.effective_size -= 
              @child.style.size.y + 
              @child.style.margin.top +
              @child.style.margin.bottom;
          }
        }
      }
    }
  }

  // Call item's evaluate callback.
  item->evaluate(this);

  // Evaluate children if the item tells us we should.

  if (item->shouldPlaceChildren())
  {
    vec2f cursor = 
      @style.margin.top_left + 
      @style.padding.top_left + 
      @style.border.top_left;

    // Allow widgets to adjust where child placement should begin, eg. in the
    // case of a collapsing header. By default this doesn't move the cursor.
    cursor = item->adjustCursorStart(this, cursor);

    ItemNode* it = 
      (@style.display.test(reverse)? 
        node->last_child :
        node->first_child);

    u32 aeidx = 0;
    while (it) 
    {
      Item* child = it->data;

      $ local child = ui.createItemContext("Item", "child", true)

      @@child.style:lookup(
        display,
        positioning,
        pos,
        anchor,
        sizing,
        margin,
        alignment)

      if (@child.style.display.test(hidden))
      {
        assert(it != it->next);
        it = 
          (@style.display.test(reverse)? 
            it->prev :
            it->next);
        continue;
      }

      if (already_evaluated.len < aeidx && already_evaluated[aeidx] == child)
      {
        aeidx += 1;
      }
      else
      {
        evalItemBranch(child->node, &flex);
      }

$ local placeAnchorSwitch = function(var)
$   local style = child.style
    switch (@style.anchor)
    {
    case @schema.anchor.top_left:
      child->pos_local.x += @style.pos.x;
      child->pos_local.y += @style.pos.y;
      break;

    case @schema.anchor.top_right:
      if (!wauto)
        child->pos_local.x = 
          @item.getPaddedWidth - child->size.x - @style.pos.x;
      else
        ERROR("item's anchor was specified as top_right but the item's width "
              "is set to auto\n");
      child->pos_local.y += @style.pos.y;
      break;

    case @schema.anchor.bottom_right:
      if (!wauto)
        child->pos_local.x = 
          @item.getPaddedWidth - child->size.x - @style.pos.x;
      else
        ERROR("item's anchor was specified as bottom_right but the item's "
              "width is set to auto\n");
      if (!hauto)
        child->pos_local.y = 
          @item.getPaddedHeight - child->size.y - @style.pos.y;
      else
        ERROR("item's anchor was specified as bottom_right but the item's "
              "height is set to auto\n");
      break;

    case @schema.anchor.bottom_left:
      child->pos_local.x += @style.pos.x;
      if (!hauto)
        child->pos_local.y =
          @item.getPaddedHeight - child->size.y - @style.pos.y;
      else
        ERROR("item's anchor was specified as bottom_left but the item's "
              "height is set to auto\n");
      break;
    }
$ end

      switch (@child.style.positioning)
      {
      case @schema.positioning.static:
        if (@style.display.test(horizontal))
        {
          if (!hauto)
          {
            child->pos_local.y = cursor.y +
              @child.style.alignment.y * 
              (@item.getPaddedHeight - child->size.y);
          }
          else
          {
            child->pos_local.y = cursor.y;
          }
          child->pos_local.x = cursor.x;
        }
        else
        {
          if (!wauto)
          {
            child->pos_local.x = cursor.x +
              @child.style.alignment.x * 
              (@item.getPaddedWidth - child->size.x);
          }
          else
          {
            child->pos_local.x = cursor.x;
          }
          child->pos_local.y = cursor.y;
        }

        if (@style.display.test(horizontal))
          cursor.x = child->pos_local.x + child->size.x;
        else
          cursor.y = child->pos_local.y + child->size.y;

        @placeAnchorSwitch

        break;

      case @schema.positioning.relative:
        child->pos_local = 
          @child.style.margin.top_left +
          @style.border.top_left;

        if (@style.display.test(horizontal))
          cursor.x += child->pos_local.x + child->size.x;
        else
          cursor.y += child->pos_local.y + child->size.y;

        @placeAnchorSwitch

        break;

      case @schema.positioning.absolute:
        @placeAnchorSwitch
        break;

      // NOTE(sushi) fixed positioning is handled in gen item branch
      }

      child->pos_local = floor(child->pos_local);

      if (wauto)
        item->size.x = max(item->size.x, child->pos_local.x + child->size.x);
      if (hauto)
        item->size.y = max(item->size.y, child->pos_local.y + child->size.y);

      assert(it != it->next);
      it = 
        (@style.display.test(reverse)? 
          it->prev :
          it->next);
    }

  }

  if (wauto)
  {
    item->size.x += 
      @style.padding.right +
      @style.margin.right +
      @style.border.right;
  }

  if (hauto)
  {
    item->size.y +=
      @style.padding.bottom +
      @style.margin.bottom +
      @style.border.bottom;
  }

  item->size = max(item->size, item->getMinSize(this));

  item->pos_local = floor(item->pos_local);
}

/* ----------------------------------------------------------------------------
 */
void UI::genItemBranch(ItemNode* node)
{
  Item* item = node->data;

  $ local item = ui.createItemContext("Item", "item")

  @@item.style:lookup(display)

  if (@item.style.display.test(hidden))
    return;

  if (item != root)
  {
    item->pos_screen = node->parent->data->pos_screen + item->pos_local;
  }

  if (item->drawcmds.len() != 0)
    item->generate(this);

  if (item->shouldPlaceChildren())
  {
    for (ItemNode* child = node->first_child; child; child = child->next)
      genItemBranch(child);
  }
}

/* ----------------------------------------------------------------------------
 */
b8 UI::findHoveredItem(ItemTree::Node* node)
{
  Item* item = node->data;

  $ local item = ui.createItemContext("Item", "item")
  @@item.style:lookup(display)

  for (ItemTree::Node* child = node->last_child; child; child = child->prev)
  {
    if (!@item.style.display.test(hidden))
    {
      if (findHoveredItem(child))
        return true;
    }
  }

  if (item->containsPoint(eng->input.mouse.window))
  {
    hovered = item;
    return true;
  }

  return false;
}

/* ----------------------------------------------------------------------------
 */
void UI::onWindowResized(WindowResized& event)
{
  $ local root = ui.createItemContext("Item", "root")
  @root.style.set.size(event.size);
}

}
