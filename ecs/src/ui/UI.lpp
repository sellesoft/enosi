$ local cmn = require "common"
$ local ui = require "ui.UI"

@@lpp.import "ui/UI.lh"
@@lpp.import "graphics/CompiledShader.lh"
@@lpp.import "graphics/Renderer.lh"
@@lpp.import "graphics/Geo.lh"
@@lpp.import "math/util.h"

#include "iro/Logger.h"
#include "iro/containers/SmallArray.h"

$ require "Log"

using namespace iro;

namespace ui
{

@log.ger(ui, Info)

/* ----------------------------------------------------------------------------
 */
b8 UI::init(InitParams& params)
{
  renderer = &params.renderer;
  white_texture = params.white_texture;

  if (!frame_allocator.init())
    return ERROR("failed to initialize UI frame allocator\n");

  if (!params.loader.load(&pipeline_defref, "assets/shaders/UI"_str))
    return ERROR("failed to load UI pipeline def\n");

  if (!pipeline.init(*renderer, c_PushConstantSize, true, *pipeline_defref))
    return ERROR("failed to initialize UI pipeline\n");

  if (!vertex_buffer.init(
        *renderer,
        nullptr,
        sizeof(gfx::Vertex) * c_MaxVertices,
        gfx::Buffer::Usage::VertexBuffer,
        gfx::Buffer::MemoryProperty::DeviceMappable,
        gfx::Buffer::MappingBehavior::Occasional))
    return ERROR("failed to initialize ui vertex buffer\n");

  if (!index_buffer.init(
        *renderer,
        nullptr,
        sizeof(gfx::Index) * c_MaxIndices,
        gfx::Buffer::Usage::IndexBuffer,
        gfx::Buffer::MemoryProperty::DeviceMappable,
        gfx::Buffer::MappingBehavior::Occasional))
    return ERROR("failed to initialize ui index buffer\n");

  return true;
}

/* ----------------------------------------------------------------------------
 */
void UI::beginFrame(const FrameParams& params)
{
  assert(!in_frame && 
    "attempt to begin UI frame while one is already in progress");

  DEBUG("UI::beginFrame\n");

  in_frame = true;

  frame_input = params.input;
  viewport = params.viewport;

  draw_counts = {};

  // Initialize the root Layer and its initial Panel.
  root_layer = frame_allocator.construct<Layer>();

  Panel* root_panel = frame_allocator.construct<Panel>();

  root_panel->bounds = viewport;
  root_panel->transform = mat3x2::createTransform(viewport.pos(), 0.f);

  root_layer->current_panel = root_panel;
  root_layer->panels = root_layer->current_panel;

  current_layer = root_layer;

  pushPanelRenderState(root_panel);
}

/* ----------------------------------------------------------------------------
 */
void UI::pushConstantFromTransform(mat3x2 transform, gfx::Renderer& renderer)
{
  f32 push_constant[16];

  transform.toMat4(push_constant);
    
  f32 scale_x = 2.f / viewport.w;
  f32 scale_y = 2.f / viewport.h;
  push_constant[0] *= scale_x;
  push_constant[1] *= scale_x;
  push_constant[4] *= scale_y;
  push_constant[5] *= scale_y;

  push_constant[12] = push_constant[2] * scale_x;
  push_constant[13] = push_constant[6] * scale_y;
  push_constant[2] = 0.f;
  push_constant[6] = 0.f;

  renderer.pushConstant(push_constant, c_PushConstantSize);
}

/* ----------------------------------------------------------------------------
 */
void UI::endFrame()
{
  // Bind UI's gfx objects.
  renderer->bindPipeline(pipeline);
  renderer->bindVertexBuffer(vertex_buffer);
  renderer->bindIndexBuffer(index_buffer);

  // Map the draw info buffers.
  vertex_buffer.map(*renderer);
  index_buffer.map(*renderer);

  Layer* top_layer = nullptr;

  // Execute each layer's Cmds.
  for (Layer* layer = root_layer; layer; layer = layer->next)
  {
    for (Cmd* cmd = layer->first_cmd; cmd; cmd = cmd->next)
    {
      cmd->execute(*this, *renderer);
    }

    top_layer = layer;
  }

  for (Layer* layer = top_layer; layer; layer = layer->prev)
  {
    for (Panel* panel = layer->panels; panel; panel = panel->prev)
    {
      vec2f screen_translation = panel->transform.getTranslation();

      Rect screen_bounds = 
        Rect::from(screen_translation, panel->bounds.size());

      drawDebugBorder(screen_bounds, 0x00ffaaff);

      if (screen_bounds.containsPoint(frame_input.getCursorPos()))
      {
        next_focus_state.hovered_panel = panel->id;
        next_focus_state.hovered_layer_idx = layer->idx;

        for (FocusableBounds* fbounds = panel->fbounds; 
             fbounds; fbounds = fbounds->next)
        {
          vec2f screen_fbounds_translation = 
            screen_translation + fbounds->bounds.pos();

          Rect screen_fbounds = 
            Rect::from(screen_fbounds_translation, fbounds->bounds.size());

          drawDebugBorder(screen_fbounds, 0x335599ff);

          if (screen_fbounds.containsPoint(frame_input.getCursorPos()))
          {
            next_focus_state.hovered = fbounds->id;
          }
        }
      }
    }

    if (notnil(next_focus_state.hovered))
      break;
  }

  if (debug_cmds != nullptr)
  {
    mat3x2 screen_transform = mat3x2::createTransform(vec2f(0,0), 0.f);

    TransformCmd transform_cmd = {};
    transform_cmd.transform = &screen_transform;

    ScissorCmd scissor_cmd = {};
    scissor_cmd.bounds = viewport;

    transform_cmd.execute(*this, *renderer);
    scissor_cmd.execute(*this, *renderer);

    for (Cmd* cmd = debug_cmds; cmd; cmd = cmd->next)
    {
      cmd->execute(*this, *renderer);
    }
  }

  debug_cmds = nullptr;

  // Clean up the frame's memory.
  frame_allocator.clear();

  // Flush and unmap the buffers.
  vertex_buffer.flush(*renderer, 0, gfx::Buffer::FLUSH_WHOLE_BUFFER);
  index_buffer.flush(*renderer, 0, gfx::Buffer::FLUSH_WHOLE_BUFFER);
  vertex_buffer.unmap(*renderer);
  index_buffer.unmap(*renderer);

  // Reset layer states.
  root_layer = nullptr;
  current_layer = nullptr;

  if (notnil(next_focus_state.hovered) &&
      frame_input.wasMouseButtonPressed(MouseButton::Left))
  {
    next_focus_state.focused = next_focus_state.hovered;
    next_focus_state.focused_panel = next_focus_state.hovered_panel;
    next_focus_state.focused_layer_idx = next_focus_state.hovered_layer_idx;
  }
  else
  {
    next_focus_state.focused = focus_state.hovered;
    next_focus_state.focused_panel = focus_state.hovered_panel;
    next_focus_state.focused_layer_idx = focus_state.hovered_layer_idx;
  }

  prev_focus_state = focus_state;
  focus_state = next_focus_state;
  next_focus_state = {};

  TRACE("focus_state:",
      "\n            hovered: ", focus_state.hovered.val,
      "\n      hovered_panel: ", focus_state.hovered_panel.val,
      "\n  hovered_layer_idx: ", focus_state.hovered_layer_idx, "\n");

  in_frame = false;
}

/* ----------------------------------------------------------------------------
 */
void Layer::pushCmd(Cmd* cmd)
{
  if (last_cmd != nullptr)
  {
    last_cmd->next = cmd;
    last_cmd = cmd;
  }
  else
  {
    first_cmd = last_cmd = cmd;
  }
}

/* ----------------------------------------------------------------------------
 */
void UI::pushLayer(FocusableId id, Rect bounds, LayerFlags flags)
{
  DEBUG("UI::pushLayer\n");

  assert(notnil(id));

  // Push into the next layer. If we haven't already in this frame, allocate
  // a new one.
  Layer* next_layer = current_layer->next;

  if (next_layer == nullptr)
  {
    next_layer = frame_allocator.construct<Layer>();
    next_layer->prev = current_layer;
    current_layer->next = next_layer;
  }

  Panel* prev_panel = current_layer->current_panel;

  current_layer = next_layer;

  layer_idx += 1;

  current_layer->idx = layer_idx;

  beginPanel(id, bounds, prev_panel);
}

/* ----------------------------------------------------------------------------
 */
void UI::popLayer()
{
  DEBUG("UI::popLayer\n");

  assert(current_layer->prev != nullptr);

  current_layer = current_layer->prev;

  layer_idx -= 1;

  pushPanelRenderState(current_layer->current_panel);
}

/* ----------------------------------------------------------------------------
 */
void UI::beginPanel(FocusableId id, Rect bounds, Panel* prev)
{
  DEBUG("UI::beginPanel(", id.val, ")\n");

  assert(notnil(id));

  auto* next_panel = frame_allocator.construct<Panel>();
  next_panel->id = id;
  next_panel->bounds = bounds;

  if (prev != nullptr)
  {
    // Set the transform of this panel to be nested within the current panel.
    next_panel->transform = 
      prev->transform.mul(
        mat3x2::createTransform(bounds.pos(), 0.f));
  }
  else
  {
    // Otherwise, the panel is transformed in screen space.
    next_panel->transform = mat3x2::createTransform(bounds.pos(), 0.f);
  }

  next_panel->prev = current_layer->panels;
  current_layer->panels = next_panel;

  current_layer->current_panel = next_panel;

  pushPanelRenderState(next_panel);
}

/* ----------------------------------------------------------------------------
 */
void UI::beginPanel(FocusableId id, Rect bounds)
{
  beginPanel(id, bounds, current_layer->current_panel);
}

/* ----------------------------------------------------------------------------
 */
void UI::endPanel()
{
  DEBUG("UI::endPanel\n");

  Panel* current_panel = current_layer->current_panel;

  assert(current_panel && current_panel->prev != nullptr);

  current_layer->current_panel = current_panel->prev;

  pushPanelRenderState(current_layer->current_panel);
}

/* ----------------------------------------------------------------------------
 */
void UI::putItem(Rect bounds, const ItemSkinDef& skin)
{
  if (skin.color.a == 0)
    // Skip queuing commands for invisible items.
    return;

  gfx::Texture texture;
  vec4f uv;

  if (skin.texture.isValid())
  {
    // Compute the uvs. It would be nice to cache this, since we should 
    // know what the Texture is on load and it shouldn't change unless 
    // the skin is reloaded.
    const gfx::CompiledTexture& ctex = *skin.texture;
    const gfx::CompiledTextureData& cdata = ctex.getData();

    texture = ctex.gfx_texture;

    vec2f tl = skin.uv.pos();
    vec2f br = skin.uv.extent();

    uv.x = tl.x / cdata.width;
    uv.y = tl.y / cdata.height;
    uv.z = br.x / cdata.width;
    uv.w = br.y / cdata.height;
  }
  else
  {
    texture = white_texture;
    uv = {};
  }
  
  putQuad(bounds, texture, uv, skin.color);
}

/* ----------------------------------------------------------------------------
 */
void UI::putText(Rect bounds, String text, const TextSkinDef& skin)
{
  // TODO(sushi) add a null font so that this isn't fatal.
  assert(skin.font.isValid());

  const gfx::Font& font = *skin.font;

  gfx::PackedChar space_char;
  font.getPackedChar(&space_char, ' ');
  f32 space_width = space_char.xadvance;

  vec2f cursor = bounds.pos();
  const gfx::FontData& font_data = font.getData();

  while (!text.isEmpty())
  {
    utf8::Codepoint cp = text.advance();

    switch (cp.codepoint)
    {
    case '\n':
      cursor.y += skin.font_height;
      cursor.x = bounds.x;
      break;

    case '\t':
      cursor.x += skin.tab_spaces * space_width;
      break;

    default:
      {
        gfx::PackedChar pc;
        font.getPackedChar(&pc, cp.codepoint);
        
        vec4f uv = {};
        uv.x = f32(pc.x0) / font_data.size_x;
        uv.y = f32(pc.y0) / font_data.size_y;
        uv.z = f32(pc.x1) / font_data.size_x;
        uv.w = f32(pc.y1) / font_data.size_y;

        auto glyph_size = vec2f(pc.x1 - pc.x0, pc.y1 - pc.y0);

        // TODO(sushi) group quad commands so we aren't storing 
        //             the same texture and color over and over again.
        putQuad(
          Rect::from(cursor, glyph_size), 
          font.texture->gfx_texture,
          uv,
          skin.color);

        cursor.x += pc.xadvance;
      }
      break;
    }
  }
}

/* ----------------------------------------------------------------------------
 */
void UI::putTextItem(Rect bounds, String text, const TextItemSkinDef& skin)
{
  putItem(bounds, skin.item);
  putText(bounds, text, skin.text);
}

/* ----------------------------------------------------------------------------
 */
b8 UI::putButton(
    FocusableId id, 
    Rect bounds, 
    String text,
    const ButtonSkinDef& skin)
{
  FocusFlags focus = putFocusableBounds(id, bounds);

  const TextItemSkinDef* state_skin = &skin.normal;

  b8 clicked = false;

  if (focus.test(FocusFlag::Hovered))
  {
    state_skin = &skin.hovered;

    if (frame_input.wasMouseButtonPressed(MouseButton::Left))
    {
      state_skin = &skin.pressed;
      clicked = true;
    }
  }

  putTextItem(bounds, text, *state_skin);

  return clicked;
}

/* ----------------------------------------------------------------------------
 */
void UI::pushPanelRenderState(Panel* panel)
{
  auto* transform_cmd = frame_allocator.construct<TransformCmd>();
  transform_cmd->transform = &panel->transform;

  auto* scissor_cmd = frame_allocator.construct<ScissorCmd>();
  scissor_cmd->bounds = panel->bounds;

  current_layer->pushCmd(transform_cmd);
  current_layer->pushCmd(scissor_cmd);
}

/* ----------------------------------------------------------------------------
 */
void TransformCmd::execute(UI& ui, gfx::Renderer& renderer)
{
  TRACE("execute transform ", transform->getTranslation(), "\n");

  ui.pushConstantFromTransform(*transform, renderer);
}

/* ----------------------------------------------------------------------------
 */
void ScissorCmd::execute(UI& ui, gfx::Renderer& renderer)
{
  TRACE("execute scissor ", bounds.pos(), " ", bounds.size(), "\n");

  renderer.setScissor(bounds.pos(), bounds.size());
}

/* ----------------------------------------------------------------------------
 */
void UI::putQuad(Rect bounds, gfx::Texture texture, vec4f uv, Color color)
{
  assert(in_frame);

  auto* cmd = frame_allocator.construct<QuadDrawCmd>();

  cmd->texture = texture;
  cmd->bounds = bounds;
  cmd->uv = uv;
  cmd->color = color;

  current_layer->pushCmd(cmd);
}

/* ----------------------------------------------------------------------------
 */
void UI::putQuad(Rect bounds, gfx::Texture texture, Color color)
{
  putQuad(bounds, texture, vec4f(0,0,1,1), color); 
}

/* ----------------------------------------------------------------------------
 */
void UI::putQuad(Rect bounds, Color color)
{
  putQuad(bounds, white_texture, color);
}

/* ----------------------------------------------------------------------------
 */
void QuadDrawCmd::execute(UI& ui, gfx::Renderer& renderer)
{
  TRACE("execute draw quad ", bounds.pos(), " ", bounds.size(), 
        " ", color, "\n");

  renderer.bindTexture(texture);

  // TODO(sushi) use a special buffer for quads so that we can just instance
  //             the indexes, like we do in RenderSys (to be renamed 
  //             GameRenderer) and so we aren't sending so many drawcmds.

  // TODO(sushi) we can probably do the actual drawing earlier, though not 
  //             sure yet if its better to defer that to frame end to 
  //             not bog down the performance of UI code.
  vec2i drawn = 
    gfx::putFilledRect(
      (gfx::Vertex*)ui.vertex_buffer.mapped_data,
      (gfx::Index*)ui.index_buffer.mapped_data,
      ui.draw_counts,
      bounds.pos(),
      bounds.size(),
      { uv.x, uv.y },
      { uv.z, uv.y },
      { uv.z, uv.w },
      { uv.x, uv.w },
      color);

  TRACE("draw: ", ui.draw_counts.y, " ", drawn.y, " ", ui.draw_counts.x, "\n");

  renderer.draw(
    ui.draw_counts.y,
    drawn.y,
    0);

  ui.draw_counts += drawn;
}

/* ----------------------------------------------------------------------------
 */
FocusFlags UI::putFocusableBounds(FocusableId id, Rect bounds)
{
  TRACE("UI::putFocusableBounds(", id.val, ")\n");

  Panel* current_panel = current_layer->current_panel;

  auto* focusable = frame_allocator.construct<FocusableBounds>();
  focusable->id = id;
  focusable->bounds = bounds;

  focusable->next = current_panel->fbounds;
  current_panel->fbounds = focusable;
  
  // Check if these bounds were hovered or focused last frame.
  FocusFlags result = {};

  if (layer_idx == focus_state.hovered_layer_idx)
  {
    if (current_layer->current_panel->id == focus_state.hovered_panel)
    {
      if (focus_state.hovered == id)
        result.set(FocusFlag::Hovered);
    }
  }

  if (layer_idx == focus_state.focused_layer_idx)
  {
    if (current_layer->current_panel->id == focus_state.focused_panel)
    {
      if (focus_state.focused == id)
        result.set(FocusFlag::Focused);
    }
  }

  return result;
}

/* ----------------------------------------------------------------------------
 */
void BorderDrawCmd::execute(UI& ui, gfx::Renderer& renderer)
{
  renderer.bindTexture(ui.white_texture);

  vec2i drawn = 
    gfx::putBorders(
      (gfx::Vertex*)ui.vertex_buffer.mapped_data,
      (gfx::Index*)ui.index_buffer.mapped_data,
      ui.draw_counts,
      vec4f(1,1,1,1),
      bounds.pos(),
      bounds.size(),
      color);

  renderer.draw(ui.draw_counts.y, drawn.y, 0);
 
  ui.draw_counts += drawn;
}

/* ----------------------------------------------------------------------------
 */
void UI::drawDebugBorder(Rect bounds, Color color)
{
  auto* border_cmd = frame_allocator.construct<BorderDrawCmd>();

  border_cmd->bounds = bounds;
  border_cmd->color = color;

  border_cmd->next = debug_cmds;
  debug_cmds = border_cmd;
}

}
