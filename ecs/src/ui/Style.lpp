$ local lpp = require "lpp"
$ local reflect = require "reflection.Reflector"
$ local Style = require "ui.Style"

@@lpp.import "ui/Style.lh"
@@lpp.import "ui/Item.lh"

$$$

-- * --------------------------------------------------------------------------

local placePropKindMethods = function()
  Style.prop_kinds:each(function(pk)
$$$

/* ----------------------------------------------------------------------------
 */
template<>
$(pk.typename) StyleMap::getAs(u64 id, $(pk.typename) def)
{
  // TODO(sushi) maybe also add the elem to the map here? Not sure if that
  //             would be good behavior or not.
  Elem* elem = map.find(id);
  if (!elem)
    return def;
  assert(elem->kind == Elem::Kind::$(pk.kindname));
  return elem->value.$(pk.unionname);
}

/* ----------------------------------------------------------------------------
 */
template<>
void StyleMap::setAs(u64 id, $(pk.typename) val, Item* item)
{
  Elem* elem = map.find(id);
  if (!elem)
  {
    elem = pool.add();
    elem->hash = id;
    map.insert(elem);
  }
  elem->kind = Elem::Kind::$(pk.kindname);
  elem->value.$(pk.unionname) = val;
  // TODO(sushi) see if clang optimizes out this branch if it knows that
  //             item == nullptr.
  if (item)
    item->dirty = true;
}

/* ----------------------------------------------------------------------------
 */
template<>
$(pk.typename) StyleMap::getAs(str name, $(pk.typename) def)
{
  return getAs(name.hash(), def);
}

/* ----------------------------------------------------------------------------
 */
template<>
void StyleMap::setAs(str name, $(pk.typename) val, Item* item)
{
  return setAs(name.hash(), val, item);
}

$$$
  end)
end

$$$

namespace ui
{

/* ----------------------------------------------------------------------------
 */
@placePropKindMethods

/* ----------------------------------------------------------------------------
 */
b8 StyleMap::init()
{
  if (!map.init())
    return false;

  if (!pool.init())
    return false;

  return true;
}

}
