/*
 *  Definition of parameters for styling ui Items.
 *
 *  This can be thought of as the CSS of the ui system.
 */

$ local lpp = require "lpp"
$ local reflect = require "reflection.Reflector"
$ local ctx = reflect.ctx
$ local List = require "list"
$ local buffer = require "string.buffer"
$ local ui = require "ui.UI"
$ local Style = require "ui.Style"

#include "math/vec.h"
#include "Color.h"

#include "iro/flags.h"
#include "iro/memory/memory.h"
#include "iro/containers/pool.h"
#include "iro/containers/avl.h"

using namespace iro;

namespace ui
{

struct Item;

$$$

-- * --------------------------------------------------------------------------

local placePropKindEnums = function()
  Style.prop_kinds:each(function(pk)
$$$
    $(pk.kindname),
$$$
  end)
end

-- * --------------------------------------------------------------------------

local placePropKindUnionMembers = function()
  Style.prop_kinds:each(function(pk)
$$$
    $(pk.typename) $(pk.unionname);
$$$
  end)
end

$$$

/* ============================================================================
 */
struct StyleMap
{
  struct Elem
  {
    enum class Kind
    {
      Invalid,
    @placePropKindEnums
    };

    Kind kind;

    union
    {
    @placePropKindUnionMembers
    } value;

    u64 hash;
    str name;

    Elem() : hash(0), name(), kind(Kind::Invalid), value(0) {}
  };

  typedef AVL<Elem, [](const Elem* e) { return e->hash; }> ElemMap;
  typedef Pool<Elem> ElemPool;

  ElemMap map;
  ElemPool pool;

  b8   init();
  void deinit();

  template<typename T>
  T getAs(str name, T def = {});

  // Optionally passed an item to set dirty after set is used.
  template<typename T>
  void setAs(str name, T val, Item* item = nullptr);

  // Variants for compile time hashed strings, which should be the most 
  // likely case.

  template<typename T>
  T getAs(u64 id, T def = {});

  // Optionally passed an item to set dirty after set is used.
  template<typename T>
  void setAs(u64 id, T val, Item* item = nullptr);
};


}
