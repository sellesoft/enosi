/*
 *  The basis of all things in the UI system.
 */ 

$ local lpp = require "lpp"
$ local reflect = require "reflection.Reflector"
$ local ui = require "ui.UI"

#include "iro/unicode.h"
#include "math/vec.h"
#include "iro/containers/Tree.h"
#include "iro/containers/array.h"

@@lpp.import "ui/Style.lh"

@@ui.defineSchema(Item,
{
  pos: vec2f = {0, 0};

  positioning: enum
  {
    static,
    relative,
    absolute,
    fixed,
  } = static;

  size: vec2f = {0, 0}
    accessors
      width = "%.x",
      height = "%.y";

  sizing: flags
  {
    normal,
    auto_x,
    auto_y,
    percent_x,
    percent_y,
    square,
    flex,
  } = normal
    values
      auto = "auto_x | auto_y",
      percent = "percent_x | percent_y";

  margin: vec4f = { 0, 0, 0, 0 }
    accessors
      top_left = "%.xy",
      bottom_right = "%.wz",
      top = "%.y",
      left = "%.x",
      right = "%.z",
      bottom = "%.w";
  
  display: flags
  {
    vertical,
    horizontal,
    flex,
    reverse,
    hidden,
  } = vertical;

  padding: vec4f = { 0, 0, 0, 0 }
    accessors
      top_left = "%.xy",
      bottom_right = "%.zw",
      top = "%.y",
      left = "%.x",
      right = "%.z",
      bottom = "%.w";

  anchor: enum
  {
    top_left,
    top_right,
    bottom_right,
    bottom_left,
  } = top_left;

  border: vec4f = { 0, 0, 0, 0 }
    accessors
      top_left = "%.xy",
      bottom_right = "%.zw",
      top = "%.y",
      left = "%.x",
      right = "%.z",
      bottom = "%.w";

  border_color: Color = { 255, 255, 255, 255 };

  background_color: Color = { 0, 0, 0, 0 };

  func hasBorder 
  {
    %.border.left ||
    %.border.right ||
    %.border.top ||
    %.border.bottom
  }

  func getMarginedWidth 
    { $.size.x - %.margin.left - %.margin.right }
  func getMarginedHeight 
    { $.size.y - %.margin.top - %.margin.bottom }
  func getMarginedArea 
    { { $.getMarginedWidth, $.getMarginedHeight } }

  func getMarginedStyleWidth 
    { %.size.width - %.margin.left - %.margin.right }
  func getMarginedStyleHeight 
    { %.size.height - %.margin.top - %.margin.bottom }
  func getMarginedStyleArea 
    { { $.getMarginedStyleWidth, $.getMarginedStyleHeight } }

  func getBorderedWidth
    { $.getMarginedWidth - %.border.left - %.border.right }
  func getBorderedHeight
    { $.getMarginedHeight - %.border.top - %.border.bottom } 
  func getBorderedArea
    { { $.getBorderedWidth, $.getBorderedHeight } }

  func getBorderedStyleWidth 
    { %.size.width - %.border.left - %.border.right } 
  func getBorderedStyleHeight
    { %.size.height - %.border.top - %.border.bottom }
  func getBorderedStyleArea
    { { $.getBorderedStyleWidth, $.getBorderedStyleHeight } }

  func getPaddedWidth
    { $.getBorderedWidth - %.padding.left - %.padding.right }
  func getPaddedHeight
    { $.getBorderedHeight - %.padding.top - %.padding.bottom }
  func getPaddedArea
    { { $.getPaddedWidth, $.getPaddedHeight } }

  func getPaddedStyleWidth
    { %.size.width - %.padding.left - %.padding.right }
  func getPaddedStyleHeight
    { %.size.height - %.padding.top - %.padding.bottom }
  func getPaddedStyleArea
    { { $.getPaddedStyleWidth, $.getPaddedStyleHeight } }
    
})

using namespace iro;

namespace ui
{

struct Item;
struct DrawCmd;
struct Context;

typedef Tree<Item>::Node ItemNode;

enum class ActionTrigger
{
  Never,
  MouseHover,
  MouseHoverChildren,
  MousePressed,
  MouseReleased,
  MouseDown,
  MouseScroll,
  Always,
};

struct Item
{
  str name;
  StyleMap style;

  ItemNode* node;

  // TODO(sushi) implement something like SmallVector from llvm and 
  //             use that here.
  Array<DrawCmd> drawcmds;

  operator ItemNode*() { return node; }

  vec2f pos_local;
  vec2f pos_screen;

  // Size that the item visually takes up on the screen.
  vec2f size;

  vec2f visible_start;
  vec2f visible_size;

  b8 dirty;
  
  ActionTrigger update_trigger;

  // Called according to the update trigger.
  virtual void update() {}

  // Determines how this item is sized and positioned relative to other items.
  virtual void evaluate(Context* ctx) {}

  // Generates draw information for rendering this item.
  virtual void generate(Context* ctx);

  // Cleans up any dynamic memory this item may have allocated in its lifetime.
  virtual void cleanup() {}
};

// struct Text : public Item
// {
//   str text;
// 
//   virtual void generate() override;
// };

}
