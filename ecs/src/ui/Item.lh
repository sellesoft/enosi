/*
 *  The basis of all things in the UI system.
 */ 

$ local lpp = require "lpp"
$ local reflect = require "reflection.Reflector"


#include "iro/unicode.h"
#include "math/vec.h"
#include "iro/containers/Tree.h"
#include "iro/containers/array.h"
@lpp.import "ui/Style.lh"

using namespace iro;

namespace ui
{

struct Item;
struct DrawCmd;
struct Context;

typedef Tree<Item>::Node ItemNode;

enum class ActionTrigger
{
  Never,
  MouseHover,
  MouseHoverChildren,
  MousePressed,
  MouseReleased,
  MouseDown,
  MouseScroll,
  Always,
};

struct Item
{
  str name;
  Style style;

  ItemNode* node;

  // TODO(sushi) implement something like SmallVector from llvm and 
  //             use that here.
  Array<DrawCmd> drawcmds;

  operator ItemNode*() { return node; }

  vec2f pos_local;
  vec2f pos_screen;

  // Size that the item visually takes up on the screen.
  vec2f size;

  vec2f visible_start;
  vec2f visible_size;

  b8 dirty;
  
  ActionTrigger update_trigger;

  // Called according to the update trigger.
  virtual void update();

  // Determines how this item is sized and positioned relative to other items.
  virtual void evaluate();

  // Generates draw information for rendering this item.
  virtual void generate(Context* ctx);

  // Cleans up any dynamic memory this item may have allocated in its lifetime.
  virtual void cleanup();

  f32 getMarginedWidth() 
    { return size.x - style.margin_left - style.margin_right; }

  f32 getMarginedHeight()
    { return size.y - style.margin_top - style.margin_bottom; }

  vec2f getMarginedArea()
    { return { getMarginedWidth(), getMarginedHeight() }; }

  f32 getMarginedStyleWidth()
    { return style.size.x - style.margin_left - style.margin_right; }

  f32 getMarginedStyleHeight()
    { return style.size.y - style.margin_top - style.margin_bottom; }

  vec2f getMarginedStyleArea()
    { return { getMarginedStyleWidth(), getMarginedStyleHeight() }; }

  f32 getBorderedWidth()
    { return getMarginedWidth() - 
        (style.hasBorder()? style.border_left + style.border_right : 0.f); }

  f32 getBorderedHeight()
    { return getMarginedHeight() -
       ( style.hasBorder()? style.border_top + style.border_bottom : 0.f ); }

  vec2f getBorderedArea()
    { return { getBorderedWidth(), getBorderedHeight() }; }

  f32 getBorderedStyleWidth()
    { return style.size.x - 
        (style.hasBorder()? style.border_left + style.border_right : 0.f); }

  f32 getBorderedStyleHeight()
    { return style.size.y - 
        (style.hasBorder()? style.border_top + style.border_bottom : 0.f ); }

  vec2f getBorderedStyleArea()
    { return { getBorderedStyleWidth(), getBorderedStyleHeight() }; }

  f32 getPaddedWidth()
    { return getBorderedWidth() - style.padding_top - style.padding_bottom; }

  f32 getPaddedHeight()
    { return getBorderedHeight() - style.padding_left - style.padding_right; }

  vec2f getPaddedArea()
    { return { getPaddedWidth(), getPaddedHeight() }; }

  f32 getPaddedStyleWidth()
    { return style.size.x - style.padding_left - style.padding_right; }

  f32 getPaddedStyleHeight()
    { return style.size.y - style.padding_top - style.padding_bottom; }

  vec2f getPaddedStyleArea()
    { return { getPaddedStyleWidth(), getPaddedStyleHeight() }; }

};

// struct Text : public Item
// {
//   str text;
// 
//   virtual void generate() override;
// };

}
