/*
 *  The basis of all things in the UI system.
 */ 

$ local lpp = require "lpp"
$ local reflect = require "reflection.Reflector"
$ local ui = require "ui.UI"

#include "iro/unicode.h"
#include "math/vec.h"
#include "iro/containers/Tree.h"
#include "iro/containers/array.h"

@@lpp.import "ui/Style.lh"

using namespace iro;

namespace ui
{

struct Item;
struct DrawCmd;
struct UI;

typedef Tree<Item> ItemTree;
typedef ItemTree::Node ItemNode;

/* ============================================================================
 *  The reason an update callback was called on an item.
 */
enum class UpdateReason
{
  DirtyBeforeEval,
  DirtyAfterEval,

  AlwaysBeforeEval,
  AlwaysAfterEval,

  MouseHover,
  MouseHoverChild,

  MousePressed,
  MouseReleased,
  MouseDown,
  MouseScroll,
};

/* ============================================================================
 */
@ui.widget(Item,
schema
{
  pos: vec2f = {0, 0};

  positioning: enum
  {
    static,
    relative,
    absolute,
    fixed,
  } = static;

  size: vec2f = {0, 0}
    accessors
      width = "%.x",
      height = "%.y"
    parseValue
    {
      -- Special because we could encounter a percentage.
      local x = parser:expectNumber()
      local xperc = parser:checkToken "%%"

      local y = parser:expectNumber()
      local yperc = parser:checkToken "%%"

      if xperc and yperc then
        style.set.sizing "percent"
      elseif xperc then
        style.set.sizing "percent_x"
      elseif yperc then
        style.set.sizing "percent_y"
      end

      return "{"..x..","..y.."}"
    };

  sizing: flags
  {
    normal,
    auto_x,
    auto_y,
    percent_x,
    percent_y,
    square,
    flex,
  } = normal
    values
      auto = "auto_x | auto_y",
      percent = "percent_x | percent_y";

  margin: vec4f = { 0, 0, 0, 0 }
    accessors
      top_left = "%.xy",
      bottom_right = "%.zw",
      top = "%.y",
      left = "%.x",
      right = "%.z",
      bottom = "%.w";
  
  display: flags
  {
    horizontal,
    flex,
    reverse,
    hidden,
  };

  padding: vec4f = { 0, 0, 0, 0 }
    accessors
      top_left = "%.xy",
      bottom_right = "%.zw",
      top = "%.y",
      left = "%.x",
      right = "%.z",
      bottom = "%.w";

  anchor: enum
  {
    top_left,
    top_right,
    bottom_right,
    bottom_left,
  } = top_left;

  border: vec4f = { 0, 0, 0, 0 }
    accessors
      top_left = "%.xy",
      bottom_right = "%.zw",
      top = "%.y",
      left = "%.x",
      right = "%.z",
      bottom = "%.w";

  border_color: Color = { 255, 255, 255, 255 };

  background_color: Color = { 0, 0, 0, 0 };

  update_triggers: flags
  {
    DirtyBeforeEval,
    DirtyAfterEval,

    AlwaysBeforeEval,
    AlwaysAfterEval,

    MouseHover,
    MouseHoverChild,

    MousePressed,
    MouseReleased,
    MouseDown,
    MouseScroll,
  };

  font: str = "gohu";
  font_height: f32 = 11;

  alignment: vec2f = {0, 0};

  func hasBorder 
  {
    %.border.left ||
    %.border.right ||
    %.border.top ||
    %.border.bottom
  }

  func getMarginedWidth 
    { $.size.x - %.margin.left - %.margin.right }
  func getMarginedHeight 
    { $.size.y - %.margin.top - %.margin.bottom }
  func getMarginedArea 
    { { $.getMarginedWidth, $.getMarginedHeight } }

  func getMarginedStyleWidth 
    { %.size.width - %.margin.left - %.margin.right }
  func getMarginedStyleHeight 
    { %.size.height - %.margin.top - %.margin.bottom }
  func getMarginedStyleArea 
    { { $.getMarginedStyleWidth, $.getMarginedStyleHeight } }

  func getBorderedWidth
    { $.getMarginedWidth - %.border.left - %.border.right }
  func getBorderedHeight
    { $.getMarginedHeight - %.border.top - %.border.bottom } 
  func getBorderedArea
    { { $.getBorderedWidth, $.getBorderedHeight } }

  func getBorderedStyleWidth 
    { %.size.width - %.border.left - %.border.right } 
  func getBorderedStyleHeight
    { %.size.height - %.border.top - %.border.bottom }
  func getBorderedStyleArea
    { { $.getBorderedStyleWidth, $.getBorderedStyleHeight } }

  func getPaddedWidth
    { $.getBorderedWidth - %.padding.left - %.padding.right }
  func getPaddedHeight
    { $.getBorderedHeight - %.padding.top - %.padding.bottom }
  func getPaddedArea
    { { $.getPaddedWidth, $.getPaddedHeight } }

  func getPaddedStyleWidth
    { %.size.width - %.padding.left - %.padding.right }
  func getPaddedStyleHeight
    { %.size.height - %.padding.top - %.padding.bottom }
  func getPaddedStyleArea
    { { $.getPaddedStyleWidth, $.getPaddedStyleHeight } }
    
},
struct
{
  str name;
  StyleMap style;

  ItemNode* node;

  // TODO(sushi) implement something like SmallVector from llvm and 
  //             use that here.
  // NOTE(sushi) SmallArray is implemented now, but it might bloat
  //             Item a lot. Expertiment with it later.
  Array<DrawCmd*> drawcmds;

  operator ItemNode*() { return node; }

  vec2f pos_local;
  vec2f pos_screen;

  // Size that the item visually takes up on the screen.
  vec2f size;

  vec2f visible_start;
  vec2f visible_size;

  b8 dirty;
  
  // Called according to the update_trigger style property.
  virtual void update(UI* ui, UpdateReason reason) {}

  // Determines how this item is sized and positioned relative to other items.
  virtual void evaluate(UI* ui) {}

  // Generates draw information for rendering this item.
  virtual void generate(UI* ui);

  // Cleans up any dynamic memory this item may have allocated in its lifetime.
  virtual void cleanup() {}
  
  b8 containsPoint(vec2f point);

  enum class HoverKind
  {
    // The topmost hovered item.
    Topmost,

    // The mouse is over this item, no matter if it is topmost.
    Area,
    
    // This item or one of its children are hovered.
    Child,
  };

  b8 isHovered(UI* ui, HoverKind kind);
})

}
