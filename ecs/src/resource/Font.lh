/*
 *  A font loaded from disk.
 */

$ local lpp = require "lpp"
$ local reflect = require "reflect.Reflector"
$ local SourceData = require "resource.SourceData"

#include "iro/common.h"
#include "iro/unicode.h"
#include "iro/traits/nil.h"
#include "iro/containers/slice.h"
#include "math/vec.h"

using namespace iro;

@@lpp.import "resource/Resource.lh"
@@lpp.import "resource/Texture.lh"
@@lpp.import "resource/Font.schema.lh"

struct ResourceMgr;

namespace gfx { struct Renderer; }

/* ==========================================================================
 *  This mirrors stbtt_aligned_quad
 */
struct AlignedQuad
{
  f32 x0, y0, u0, v0;
  f32 x1, y1, u1, v1;
};

/* ==========================================================================
 *  This mirrors stbtt_packedchar
 */
struct PackedChar
{
  unsigned short x0, y0, x1, y1;
  f32 xoff, yoff, xadvance;
  f32 xoff2, yoff2;
};

/* ==========================================================================
 *  This mirrors stbtt_pack_range
 */
struct PackRange
{
  f32 font_size;
  s32 first_codepoint;
  s32 num_chars;
  PackedChar* chardata;
};

/* ============================================================================
 */
enum class FontKind
{
  BDF,
  TTF,
};

/* ============================================================================
 *  Compiled font data saved to disk. 
 */
struct FontData
{
  FontKind kind;

  u32 count;
  f32 height;
  s32 size_x;
  s32 size_y;
  f32 ascent;
  f32 descent;
  f32 line_gap;

  u32 num_ranges;
  PackRange* ranges;

  b8 serialize(io::IO* out);

  static b8 deserialize(FontData* out, void* data);
};

struct Font;

typedef TypedResourceRef<Font> FontRef;

/* ============================================================================
 *  Runtime representation of a loaded font.
 */
struct Font : public Resource
{
  FontData* data = nullptr;
  TextureRef r_texture = {};

  const FontData* getFontData() const
  {
    return data;
  }

  // It's recommended to use this to find the proper range for a given
  // codepoint and then passing it to getPackedChar() when you know what
  // ranges you'll be working with.
  // Returns nullptr if no range exists in this font for the given codepoint.
  PackRange* getRangeOfCodepoint(u32 codepoint) const;

  // Returns false if the given codepoint doesn't exist in any range 
  // stored by this font.
  b8 getPackedChar(PackedChar* out, u32 codepoint) const;

  // This ASSUMES that the given codepoint exists in the given range,
  // BE CAREFUL!
  // TODO(sushi) a safe alternative to this when we get to user input
  //             in text boxes and such. Especially since ECS is meant to 
  //             be played online, this could potentially be used to send
  //             arbitrary data via, say, a chat system or something.
  void getPackedChar(PackedChar* out, PackRange* range, u32 codepoint) const;

  static s64 writeAssetPath(
    io::IO* out, 
    String name, 
    String ext, 
    ResourceMgr& rsrcmgr);

  static s64 writeDataPath(
    io::IO* out, 
    String name, 
    ResourceMgr& rsrcmgr);

  static MovedResourceRef load(
    String name, 
    ResourceMgr& rsrcmgr,
    gfx::Renderer& renderer);

  struct CompileParams
  {
    String name;
    String asset_path;
    String data_path;
    CodepointRanges ranges;
    mem::Allocator* allocator;
    ResourceMgr* rsrcmgr;
  };

  static b8 compileTTF(CompileParams& params);
  static b8 compileBDF(CompileParams& params);
};

