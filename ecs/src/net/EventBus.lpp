/*
 *  Network event bus.
 */
$ require "common"
$ local clog = require "Logger" ("net.eventbus", Verbosity.Info)

$$$
local importer = require "reflect.Importer"
{
  patterns = { "src/**/*.events.lh" },
  filter = function(p, decl)
    return decl.metadata.netevent ~= nil
  end,
}
$$$
@@importer:get

$$$
local event_count = 1
local function eachEvent(f)
  importer:eachDecl(function(name, decl)
    local args = loadstring("return " .. decl.metadata.netevent)()
    local priority = args.priority and 1 or 0
    local max_subscribers = args.max_subscribers or 10
    f(name, event_count, decl, priority, args.broadcast, max_subscribers)
    event_count = event_count + 1
  end)
end
$$$

@@lpp.import "net/EventBus.lh"
@@lpp.import "net/Message.lh"

#include "iro/Common.h"
#include "iro/containers/Array.h"
#include "iro/containers/FixedPool.h"
#include "iro/containers/Pool.h"
#include "iro/Logger.h"
#include "iro/memory/Allocator.h"

@log.ger(net.eventbus, Info)

namespace net
{

/* ============================================================================
 */
union EventUnion
{
$ eachEvent(function(name, id, decl, priority, broadcast, max_subscribers)
  $(name) $(name)_data;
$ end)
}; // union EventUnion

/* ============================================================================
 */
struct EventEntry
{
  u16 type_id;
  EventUnion data;
};

/* ============================================================================
 */
struct EventBusData
{
  Array<EventEntry> queued_events;

$ eachEvent(function(name, id, decl, priority, broadcast, max_subscribers)
  struct $(name)Subscriber
  {
    static constexpr b8 PRIORITY = $(priority);
    void* subscriber;
    void (*callback)(void*, $(name)& event);
  };
  FixedPool<$(name)Subscriber, $(max_subscribers)> $(name)Subscriber_pool;

$ end)
}; // struct EventBusData

/* ----------------------------------------------------------------------------
 */
b8 EventBus::init(iro::mem::Allocator* allocator)
{
  data = allocator->allocateType<EventBusData>();
  if (!data->queued_events.init(200, allocator))
    return @log.error("Failed to initialize net event bus queued events.\n");
$ eachEvent(function(name, id, decl, priority, broadcast, max_subscribers)
  data->$(name)Subscriber_pool.init();
$ end)
  return true;
}

$ eachEvent(function(name, id, decl, priority, broadcast, max_subscribers)
/* ----------------------------------------------------------------------------
 */
template<>
void EventBus::subscribe<$(name)>(
  void* subscriber,
  void (*callback)(void*, $(name)&))
{
  for (auto& sub : data->$(name)Subscriber_pool)
  {
    if (sub.subscriber == subscriber && sub.callback == callback)
    {
      WARN("Duplicate subscription to $(name) event.\n");
      return;
    }
  }

  data->$(name)Subscriber_pool.add({
    .subscriber = subscriber,
    .callback = callback,
  });
}

/* ----------------------------------------------------------------------------
 */
template<>
void EventBus::unsubscribe<$(name)>(
  void* subscriber,
  void (*callback)(void*, $(name)&))
{
  for (auto& sub : data->$(name)Subscriber_pool)
  {
    if (sub.subscriber == subscriber && sub.callback == callback)
    {
      data->$(name)Subscriber_pool.remove(&sub);
      break;
    }
  }
}

/* ----------------------------------------------------------------------------
 */
template<>
void EventBus::queue<$(name)>($(name)& event) const
{
  auto* entry = data->queued_events.push();
  entry->type_id = $(id);
  entry->data.$(name)_data = event;

  for (auto& sub : data->$(name)Subscriber_pool)
    if (sub.callback != nullptr)
      sub.callback(sub.subscriber, event);
}
$ end)

/* ----------------------------------------------------------------------------
 */
void EventBus::packEvents(Message& message, void* session) const
{
  for (auto& entry : data->queued_events)
  {
    switch (entry.type_id)
    {
$ eachEvent(function(name, id, decl, priority, broadcast, max_subscribers)

    case $(id): // $(name)
    {
      auto& event = entry.data.$(name)_data;
$   if broadcast == false then
$     local found_session_field = false
$     for field in decl:eachFieldWithIndex() do
$       if field.name == "session" then
      if (event.session == nullptr)
      {
        ERROR("A queued $(name) did not specify a session despite"
              " being non-broadcast event.\n");
        continue;
      }
      if (session != event.session)
        continue;

$         found_session_field = true
$         break
$       end
$     end
$     if not found_session_field then
$       clog:error("non-broadcast netevent $(name) has no session field\n")
$     end
$   end
      message.writeU16($(id));
$   for field in decl:eachFieldWithIndex() do
$     if not field.metadata.netfield_ignore then
$       if field.metadata.netfield_blob then
      message.writeData(event.$(field.name), (u16)event.$(field.name)_length);
$       else
$         local type = field.type.name:gsub("([us])(%d+)", "%1%2")
      message.write$(type:gsub("^%l", string.upper))(event.$(field.name));
$       end
$     end
$   end
    }
    break;
$ end)

    }
  }

  data->queued_events.clear();
}

/* ----------------------------------------------------------------------------
 */
b8 EventBus::parseMessage(Message& message, void* session) const
{
  while (!message.readComplete())
  {
    u16 event_id = message.readU16();
    switch (event_id)
    {
$ eachEvent(function(name, id, decl, priority, broadcast, max_subscribers)

    case $(id): // $(name)
    {
      $(name) event;
      event.session = session;

$   for field in decl:eachFieldWithIndex() do
$     if not field.metadata.netfield_ignore then
$       if field.metadata.netfield_blob then
      message.readData(event.$(field.name), $(field.metadata.netfield_blob));
$       else
$         local type = field.type.name:gsub("([us])(%d+)", "%1%2")
      event.$(field.name) = message.read$(type:gsub("^%l", string.upper))();
$       end
$     end
$   end

      for (auto& sub : data->$(name)Subscriber_pool)
        if (sub.callback != nullptr)
          sub.callback(sub.subscriber, event);
    }
    break;
$ end)

    default:
      return @log.error("unknown netevent: ", event_id, "\n");

    }
  }

  assert(message.readComplete());
  assert(!message.readOverflowed());
  return true;
}

} // namespace net