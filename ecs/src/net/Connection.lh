/*
 * A connection for communicating sequenced messages with an address.
 */
$ require "common"

@@lpp.import "net/Address.lh"
@@lpp.import "net/Message.lh"

#include "iro/Common.h"
#include "iro/containers/StackArray.h"

namespace iro::mem{ struct Allocator; }

namespace net
{

struct QueuedMessage;

/* ============================================================================
 */
enum struct Source
{
  Client,
  Server,
};

/* ============================================================================
 */
// TODO(delle) networking data_size might be unnecessary
struct FragmentHeader
{
  u32 protocol; // validate this is a packet we care about
  u32 sequence_index; // sequence index of this message
  u32 ack_index; // sequence index of the last message received
  u32 ack_bitfield; // each bit acknowledges the indexes before ack_index
  u16 fragment_offset; // offset into the message
  u16 data_size; // number of bytes after this header
};

static constexpr u16 MAX_FRAGMENT_SIZE = 1200;
static constexpr u16 MAX_FRAGMENT_DATA_SIZE =
  MAX_FRAGMENT_SIZE - sizeof(FragmentHeader);

// Protocol ID: <3><C><dollar><version>
static constexpr u32 PROTOCOL_VERSION = 0;
static constexpr u32 PROTOCOL_ID = 0x33422400 + PROTOCOL_VERSION;
static constexpr u64 CONNECTIONLESS_PROTOCOL_ID =
  0xFFFFFFFF | (u64)PROTOCOL_ID << 32;
static constexpr u16 SERVER_PORT = 40230;

typedef iro::StackArray<u8, MAX_FRAGMENT_SIZE> Fragment;

/* ============================================================================
 */
struct Connection
{
  enum struct State
  {
    Disconnected,
    Connecting, // sending challenge request
    Challenging, // sending/receiving challenge response
    Connected,
  } state;

  Address address;

  u32 acknowledged_sequence;
  u32 acknowledged_bitfield;

  u32 incoming_message_sequence;
  u32 incoming_fragment_sequence;
  u16 incoming_message_size;
  b8 incoming_message_pending_fragments;
  u8 incoming_message_data[Message::MAX_SIZE];

  u32 outgoing_message_sequence;
  u16 outgoing_message_size;
  u16 outgoing_message_pending_offset;
  b8 outgoing_message_pending_fragments;
  u8 outgoing_message_data[Message::MAX_SIZE + sizeof(FragmentHeader)];

  QueuedMessage* message_queue_start;
  QueuedMessage** message_queue_end;
  iro::mem::Allocator* allocator;


  b8 init(Address address, iro::mem::Allocator* allocator);

  void deinit();

  // returns true if the message was sent, fragmented, or queued
  b8 send(Source source, const Message& message, b8 priority);
  b8 sendNextFragment();

  void receive(Source source, Fragment& fragment);
};

/* ----------------------------------------------------------------------------
 */
b8 init();

/* ----------------------------------------------------------------------------
 */
void deinit();

/* ----------------------------------------------------------------------------
 * Binds the socket to a specific port. Should only be called by servers.
 */
b8 bind(u16 port);

/* ----------------------------------------------------------------------------
 * Returns true if the packet was sent.
 */
b8 sendOnlinePacket(Address to_address, void* data, u16 size);

/* ----------------------------------------------------------------------------
 * Returns true if a packet was received.
 */
b8 receiveOnlinePacket(Address& address, Fragment& fragment);

/* ----------------------------------------------------------------------------
 * Returns true if the packet was sent.
 */
b8 sendOfflinePacket(Source source, void* data, u16 size);

/* ----------------------------------------------------------------------------
 * Returns true if a packet was received.
 */
b8 receiveOfflinePacket(Source source, Fragment& fragment);

/* ----------------------------------------------------------------------------
 * Locks the mutex for offline messages.
 */
void lockOfflinePacketMutex(Source source);

/* ----------------------------------------------------------------------------
 * Unlocks the mutex for offline messages.
 */
void unlockOfflinePacketMutex(Source source);

} // namespace net