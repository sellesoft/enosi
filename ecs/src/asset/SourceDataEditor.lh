/*
 *  Widget for editing some source data.
 */

$ require "common"
$ local ui = require "ui.UI"

@@lpp.import "ui/Item.lh"
@@lpp.import "ui/widgets/InputText.lh"
@@lpp.import "graphics/Font.lh"
@@lpp.import "asset/SourceDataFile.lh"

#include "iro/memory/Bump.h"

struct SourceData;

namespace ui
{

struct DatumState;

/* ============================================================================
 */
struct SourceDataEditor
{
  // The SourceData we are editing. This is not owned by the editor, and 
  // so is not cleaned up when setSourceData is called, and is expected to
  // be kept in memory until released from the editor.
  SourceData* sdata;
  SourceDataFile* sfile;

  SourceDataFile default_data;

  mem::Bump datum_allocator;

  u64 type_id;

  f32 max_name_width;

  DatumState* current_datum;
  DatumState* hovered;

  static const s32 input_text_buffer_size = 255;
  u8 input_text_buffer[input_text_buffer_size];
  s32 input_text_buffer_len = 0;

  TextEdit::Buffer beginEditText(String text);

  TextEdit::Buffer getTextEditBuffer()
  {
    return 
      { input_text_buffer, &input_text_buffer_len, input_text_buffer_size };
  }

  String copyTextEditBuffer() const
  {
    return String::from((u8*)input_text_buffer, input_text_buffer_len)
      .allocateCopy(&sfile->string_cache);
  }

  // An interface for recieving notifications when the source data editor does
  // certain things.
  struct Interface
  {
    // Called when some SourceData has been changed.
    virtual void onEdit(SourceData* data) = 0;
  };

  Interface* interface;

  b8 init(UI& ui);
  void deinit(UI& ui);

  void setSourceData(
      UI& ui, 
      SourceData* data, 
      SourceDataFile* file, 
      u64 type_id = 0);

  void update(ItemUpdateContext& ctx, Rect bounds);
  void reportDrawCmds(UI& ui, DrawCmdLists& lists);

  SourceData* parseDefaultData(String s);
};

}
