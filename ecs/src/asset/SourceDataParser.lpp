$ local cmn = require "common"

@@lpp.import "asset/SourceDataParser.lh"
@@lpp.import "asset/SourceDataFile.lh"

#include "iro/Logger.h"
#include "iro/Platform.h"

@cmn.defFileLogger(srcdata.parse, Trace)

/* ----------------------------------------------------------------------------
 */
void SourceDataParser::ScopedStage::onEnter(const char* funcname)
{
  String preview = 
    String::from(
      parser.scanner.cache.ptr + parser.scanner.cache_offset, 
      min<u64>(10, 
        parser.scanner.cache.len - parser.scanner.cache_offset));

  log("> ", funcname, ": '", io::SanitizeControlCharacters(preview), "' (",
      parser.scanner.line, ':', parser.scanner.column, ")\n");
}

/* ----------------------------------------------------------------------------
 */
void SourceDataParser::ScopedStage::onLeave()
{
  log("<\n");
}

/* ----------------------------------------------------------------------------
 */
template<typename... T>
void SourceDataParser::ScopedStage::log(T... args)
{
  for (u32 i = 0; i < parser.stage_depth; ++i)
    DEBUG(" ");
  DEBUG(args...);
}

#define PARSER_STAGE \
  ScopedStage stage(*this, __func__)

/* ----------------------------------------------------------------------------
 */
b8 SourceDataParser::init(SourceDataFile* file, io::IO* in, String in_name)
{
  this->file = file;
  this->in_name = in_name;

  if (!scanner.init(in))
    return ERROR("failed to init scanner\n");

  return true;
}

/* ----------------------------------------------------------------------------
 */
void SourceDataParser::deinit()
{
  scanner.deinit();
}

/* ============================================================================
 */
struct Token
{
$$$
  local tkinds =
  {
    "Invalid",

    "Return",
    "Identifier",
    "String",
    "Number",
    "True",
    "False",

    "LBrace",
    "RBrace",

    "Comma",
    "Equal",

    "Colon",

    "Eof",
  }
$$$

  enum class Kind
  {
$ for _,v in ipairs(tkinds) do
    $(v),
$ end
  };

  Kind kind;

  // When applicable. Strings are cached into the SourceDataFile.
  String raw;

  u64 line, column;
};

using TK = Token::Kind;

String getTokenKindString(TK tk)
{
  switch (tk)
  {
$ for _,v in ipairs(tkinds) do
  case TK::$(v): return "$(v)"_str;
$ end
  }
  return "** invalid token kind **"_str;
}

/* ----------------------------------------------------------------------------
 */
b8 SourceDataParser::parse()
{
  PARSER_STAGE;
  for (;;)
  {
    auto tok = nextToken();

    switch (tok.kind)
    {
    case TK::Return:
      if (!parseReturn())
        return false;
      return true;

    case TK::Identifier:
      if (!parseAuxData(tok))
        return false;
      break;

    default:
      return errorAt(tok, "expected auxillary data or return\n");
    }
  }
}

/* ----------------------------------------------------------------------------
 */
b8 SourceDataParser::parseAuxData(Token tok)
{
  PARSER_STAGE;
  SourceData* data = file->addAuxData();

  data->name = tok.raw;

  tok = nextToken();

  if (tok.kind != TK::Equal)
    return errorAt(tok, "expected '=' after aux data name\n");

  if (!parsePossiblyTypedOrDerivedData(data))
    return false;

  return true;
}

/* ----------------------------------------------------------------------------
 */
b8 SourceDataParser::parseReturn()
{
  PARSER_STAGE;
  SourceData* data = file->addReturnData();

  if (!parsePossiblyTypedData(data))
    return false;

  auto tok = nextToken();
  if (tok.kind != TK::Eof)
    return errorAt(tok, "expected eof after return data\n");

  return true;
}

/* ----------------------------------------------------------------------------
 */
b8 SourceDataParser::parsePossiblyNamedData(SourceData* data)
{
  return parsePossiblyNamedData(nextToken(), data);
}

/* ----------------------------------------------------------------------------
 */
b8 SourceDataParser::parsePossiblyNamedData(Token tok, SourceData* data)
{
  PARSER_STAGE;
  switch (tok.kind)
  {
  case TK::Identifier:
    {
      // This could be a name, type, or aux data to derive from.
      auto id = tok;
      tok = nextToken();

      switch (tok.kind)
      {
      case TK::Equal:
        {
          // This is some named data.
          data->name = id.raw;

          if (!parsePossiblyTypedOrDerivedData(data))
            return false;
        }
        break;

      default:
        // This is either a typename or some aux data to derive from.
        if (!parseTypedOrDerivedData(id, tok, data))
          return false;
      }
    }
    break;

  default:
    if (!parseValueOrUntypedObject(tok, data))
      return false;
  }

  return true;
}

/* ----------------------------------------------------------------------------
 */
b8 SourceDataParser::parsePossiblyTypedOrDerivedData(SourceData* data)
{
  PARSER_STAGE;

  auto tok = nextToken();

  switch (tok.kind)
  {
  case TK::Identifier:
    {
      // Parse the next token and disambiguate.
      auto id = tok;
      tok = nextToken();

      if (!parseTypedOrDerivedData(id, tok, data))
        return false;
    }
    break;

  default:
    if (!parseValueOrUntypedObject(tok, data))
      return false;
  }

  return true;
}

/* ----------------------------------------------------------------------------
 */
b8 SourceDataParser::parseTypedOrDerivedData(
    Token id, 
    Token tok, 
    SourceData* data)
{
  PARSER_STAGE;

  // Disambiguate whether this id is being used as a typename or aux data
  // id to derive from.

  switch (tok.kind)
  {
  case TK::Colon:
    {
      // We are deriving from some aux data, so look it up by name and set
      // it as base if it exists.
      for (SourceData& aux : file->aux_data_list)
      {
        if (aux.name == id.raw)
        {
          data->base = &aux;
          break;
        }
      }

      if (data->base == nullptr)
        return errorAt(id, "no aux data named '", id.raw, "'");

      stage.log("parsed base ", data->base->name, "\n");

      // Parse the following possibly typed data.
      if (!parsePossiblyTypedData(data))
        return false;
    }
    break;

  case TK::LBrace:
    {
      // The id is being used as a typename, so set type and parse the 
      // following object.
      data->type = id.raw;

      if (!parseObjectData(data))
        return false;
    }
    break;

  default:
    return errorAt(tok, 
      "expected ':' for inheritance or '{' for typed object");
  }
  
  return true;
}

/* ----------------------------------------------------------------------------
 */
b8 SourceDataParser::parsePossiblyTypedData(SourceData* data)
{
  PARSER_STAGE;
  auto tok = nextToken();

  if (tok.kind == TK::Identifier)
  {
    data->type = tok.raw;
    tok = nextToken();

    if (tok.kind != TK::LBrace)
      return errorAt(tok, "expected object data after typename\n");
  }
  else if (tok.kind != TK::LBrace)
    return errorAt(tok, "expected typename or object data\n");

  return parseObjectData(data);
}

/* ----------------------------------------------------------------------------
 */
b8 SourceDataParser::parseObjectData(SourceData* obj)
{
  PARSER_STAGE;
  SourceData* first = nullptr;

  obj->children.init();

  for (;;)
  {
    auto tok = nextToken();
    if (tok.kind == TK::RBrace)
      break;

    auto* data = file->allocateSourceData();

    if (!parsePossiblyNamedData(tok, data))
      return false;

    if (first == nullptr)
    {
      first = data;
    }
    else
    {
      if (isnil(first->name) != isnil(data->name))
        return errorAt(tok, "named and unnamed source data cannot be mixed in "
                            "objects\n");
    }

    obj->children.push(data);

    tok = nextToken();
    if (tok.kind != TK::Comma)
    {
      if (tok.kind != TK::RBrace)
        return errorAt(tok, "expected ',' or '}'\n");
      break;
    }
  }

  return true;
}

/* ----------------------------------------------------------------------------
 */
b8 SourceDataParser::parseValueOrUntypedObject(Token tok, SourceData* data)
{
  PARSER_STAGE;
  switch (tok.kind)
  {
  case TK::LBrace:
    if (!parseObjectData(data))
      return false;
    break;

  case TK::Number:
    data->val.kind = SourceData::Value::Kind::Number;
    data->val.str = tok.raw;
    break;

  case TK::String:
    data->val.kind = SourceData::Value::Kind::String;
    data->val.str = tok.raw;
    break;

  case TK::True:
    data->val.kind = SourceData::Value::Kind::True;
    break;

  case TK::False:
    data->val.kind = SourceData::Value::Kind::False;
    break;

  default:
    return errorAt(tok, "expected a value or object\n");
  }
  return true;
}

/* ----------------------------------------------------------------------------
 */
Token SourceDataParser::nextToken()
{
  PARSER_STAGE;
  using TK = Token::Kind;

  Token out = {};
  out.kind = TK::Invalid;
  out.raw = nil;

  scanner.skipWhitespaceAndComments();

  stage.log(io::SanitizeControlCharacters(
    String::fromCStr(scanner.cache.ptr + scanner.cache_offset)), "\n");


  out.line = scanner.line;
  out.column = scanner.column;

  if (scanner.eof())
  {
    out.kind = TK::Eof;
  }
  else if (scanner.atFirstIdentifierChar())
  {
    auto id = scanner.scanIdentifier();
    if (id == "return"_str)
    {
      out.kind = TK::Return;
    }
    else if (id == "true"_str)
    {
      // platform::debugBreak();
      out.kind = TK::True;
    }
    else if (id == "false"_str)
    {
      out.kind = TK::False;
    }
    else if (scanner.at(':'))
    {
      scanner.advance();

      io::SmallBuffer<255> fullid;
      io::formatv(&fullid, id);

      for (;;)
      {
        if (!scanner.at(':'))
        {
          errorAt(out, 
            "expected a ':' after ':' for scope resolution operator\n");
          return out;
        }

        scanner.advance();

        auto part = scanner.scanIdentifier();
        if (isnil(part))
        {
          errorAt(out, "expected an identifier after '::'\n");
          return out;
        }

        io::formatv(&fullid, "::", part);

        if (!scanner.at(':'))
          break;

        scanner.advance();
      }

      out.kind = TK::Identifier;
      out.raw = fullid.asStr().allocateCopy(&file->string_cache);
    }
    else
    {
      out.kind = TK::Identifier;
      out.raw = id.allocateCopy(&file->string_cache);
    }
  }
  else if (scanner.atDigit() || scanner.at('-'))
  {
    out.kind = TK::Number;
    out.raw = scanner.scanNumber().allocateCopy(&file->string_cache);
  }
  else if (scanner.at('"'))
  {
    out.kind = TK::String;
    out.raw = scanner.scanString().allocateCopy(&file->string_cache);
  }
  else
  {
    switch (scanner.current())
    {
$$$
local map =
{
  LBrace = "{",
  RBrace = "}",
  Comma = ",",
  Equal = "=",
  Colon = ":",
}
$$$
$ for k,v in pairs(map) do
    case '$(v)': out.kind = TK::$(k); scanner.advance(); break;
$ end
    }
  }

  stage.log("Token(", getTokenKindString(out.kind), ", ", out.raw, ")\n");

  return out;
}

template<typename... Args>
b8 SourceDataParser::errorAt(Token tok, Args... args)
{
  return ERROR(in_name,":",tok.line,":",tok.column,": ", args...);
}
