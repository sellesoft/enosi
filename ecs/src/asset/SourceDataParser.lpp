$ local cmn = require "common"

@@lpp.import "asset/SourceDataParser.lh"
@@lpp.import "asset/SourceDataFile.lh"

#include "iro/logger.h"

@cmn.defFileLogger(srcdata.parse, Info)

/* ----------------------------------------------------------------------------
 */
void SourceDataParser::ScopedStage::onEnter(const char* funcname)
{
  log("> ", funcname, "\n");
}

/* ----------------------------------------------------------------------------
 */
void SourceDataParser::ScopedStage::onLeave()
{
  log("<\n");
}

/* ----------------------------------------------------------------------------
 */
template<typename... T>
void SourceDataParser::ScopedStage::log(T... args)
{
  for (u32 i = 0; i < parser.stage_depth; ++i)
    DEBUG(" ");
  DEBUG(args...);
}

#define PARSER_STAGE \
  ScopedStage stage(*this, __func__)

/* ----------------------------------------------------------------------------
 */
b8 SourceDataParser::init(SourceDataFile* file, io::IO* in, String in_name)
{
  this->file = file;
  this->in_name = in_name;

  if (!cache.open())
    return ERROR("failed to open cache\n");

  if (!scanner.init(in))
    return ERROR("failed to init scanner\n");

  return true;
}

/* ----------------------------------------------------------------------------
 */
void SourceDataParser::deinit()
{
  cache.close();
}

/* ============================================================================
 */
struct Token
{
$$$
  local tkinds = 
  {
    "Invalid",

    "Return",
    "Identifier",
    "String",
    "Number",

    "LBrace",
    "RBrace",

    "Comma",
    "Equal",

    "Eof",
  }
$$$

  enum class Kind
  {
$ for _,v in ipairs(tkinds) do
    $(v),
$ end
  };

  Kind kind;

  // When applicable. Strings are cached into the SourceDataFile.
  String raw;

  u64 line, column;
};

using TK = Token::Kind;

String getTokenKindString(TK tk)
{
  switch (tk)
  {
$ for _,v in ipairs(tkinds) do
  case TK::$(v): return "$(v)"_str;
$ end
  }
  return "** invalid token kind **"_str;
}

/* ----------------------------------------------------------------------------
 */
b8 SourceDataParser::parse()
{
  PARSER_STAGE;
  for (;;)
  {
    auto tok = nextToken();

    switch (tok.kind)
    {
    case TK::Return:
      if (!parseReturn())
        return false;
      return true;

    case TK::Identifier:
      if (!parseAuxData(tok))
        return false;
      break;

    default:
      return errorAt(tok, "expected auxillary data or return\n");
    }
  }
}

/* ----------------------------------------------------------------------------
 */
b8 SourceDataParser::parseAuxData(Token tok)
{
  PARSER_STAGE;
  SourceData* data = file->addAuxData();

  if (!parseNamedOrPossiblyTypedData(data))
    return false;

  if (isnil(data->name))
    return errorAt(tok, "aux data must be named\n");

  return true;
}

/* ----------------------------------------------------------------------------
 */
b8 SourceDataParser::parseReturn()
{
  PARSER_STAGE;
  SourceData* data = file->addReturnData();
  
  if (!parsePossiblyTypedData(data))
    return false;

  auto tok = nextToken();
  if (tok.kind != TK::Eof)
    return errorAt(tok, "expected eof after return data\n");

  data->dump();

  return true;
}

/* ----------------------------------------------------------------------------
 */
b8 SourceDataParser::parsePossiblyTypedData(SourceData* data)
{
  PARSER_STAGE;
  auto tok = nextToken();
  switch (tok.kind)
  {
  case TK::Identifier:
    {
      auto obj = data->setAsObject();
      obj->type = tok.raw;

      tok = nextToken();
      if (tok.kind != TK::LBrace)
        return errorAt(tok, "expected object data after typename\n");

      if (!parseObjectData(obj))
        return false;
    }
    break;

  default:
    if (!parseValueOrUntypedObject(tok, data))
      return false;
    break;
  }
  return true;
}

/* ----------------------------------------------------------------------------
 */
b8 SourceDataParser::parseObjectData(SourceDataObject* obj)
{
  PARSER_STAGE;
  SourceData* first = nullptr;

  for (;;)
  {
    auto tok = nextToken();
    if (tok.kind == TK::RBrace)
      break;
  
    auto data = file->allocateSourceData();

    if (!parseNamedOrPossiblyTypedData(tok, data))
      return false;

    if (first == nullptr)
    {
      first = data;
    }
    else
    {
      if (isnil(first->name) != isnil(data->name))
        return errorAt(tok, "named and unnamed source data cannot be mixed in "
                     "objects\n");
    }

    obj->children.push(data);

    tok = nextToken();
    if (tok.kind != TK::Comma)
    {
      if (tok.kind != TK::RBrace)
        return errorAt(tok, "expected ',' or '}'\n");
      break;
    }
  }

  return true;
}

/* ----------------------------------------------------------------------------
 */
b8 SourceDataParser::parseNamedOrPossiblyTypedData(SourceData* data)
{
  return parseNamedOrPossiblyTypedData(nextToken(), data);
}

/* ----------------------------------------------------------------------------
 */
b8 SourceDataParser::parseNamedOrPossiblyTypedData(Token tok, SourceData* data)
{
  PARSER_STAGE;
  switch (tok.kind)
  {
  case TK::Identifier:
    {
      auto id = tok;
      tok = nextToken();
      switch (tok.kind)
      {
      case TK::Equal:
        data->name = id.raw;
        if (!parsePossiblyTypedData(data))
          return false;
        break;

      case TK::LBrace:
        {
          auto obj = data->setAsObject();
          obj->type = id.raw;

          if (!parseObjectData(obj))
            return false;
        }
        break;

      default: 
        return errorAt(tok, "expected named or typed data\n");
      }
    }
    break;

  default:
    if (!parseValueOrUntypedObject(tok, data))
      return false;
    break;
  }
  return true;
}

/* ----------------------------------------------------------------------------
 */
b8 SourceDataParser::parseValueOrUntypedObject(Token tok, SourceData* data)
{
  PARSER_STAGE;
  switch (tok.kind)
  {
  case TK::LBrace:
    {
      auto obj = data->setAsObject();

      if (!parseObjectData(obj))
        return false;
    }
    break;

  case TK::Number:
  case TK::String:
    {
      auto val = data->setAsValue();
      val->val = tok.raw;
      if (tok.kind == TK::Number)
        val->kind = SourceDataValue::Kind::Number;
      else
        val->kind = SourceDataValue::Kind::String;
    }
    break;

  default:
    return errorAt(tok, "expected a value or object\n");
  }
  return true;
}

/* ----------------------------------------------------------------------------
 */
Token SourceDataParser::nextToken()
{
  PARSER_STAGE;
  using TK = Token::Kind;

  Token out = {};
  out.kind = TK::Invalid;
  out.raw = nil;

  scanner.skipWhitespaceAndComments();

  out.line = scanner.line;
  out.column = scanner.column;

  if (scanner.eof())
  {
    out.kind = TK::Eof;
  }
  else if (scanner.atFirstIdentifierChar())
  {
    auto id = scanner.scanIdentifier();
    if (id == "return"_str)
    {
      out.kind = TK::Return;
    }
    else
    {
      out.kind = TK::Identifier;
      out.raw = id.allocateCopy(&file->string_cache);
    }
  }
  else if (scanner.atDigit())
  {
    out.kind = TK::Number;
    out.raw = scanner.scanNumber();
  }
  else if (scanner.at('"'))
  {
    out.kind = TK::String;
    out.raw = scanner.scanString().allocateCopy(&file->string_cache);
  }
  else
  {
    switch (scanner.current())
    {
$$$
local map = 
{
  LBrace = "{",
  RBrace = "}",
  Comma = ",",
  Equal = "=",
}
$$$
$ for k,v in pairs(map) do
    case '$(v)': out.kind = TK::$(k); scanner.advance(); break;  
$ end
    }
  }

  stage.log("Token(", getTokenKindString(out.kind), ", ", out.raw, ")\n");

  return out;
}

template<typename... Args>
b8 SourceDataParser::errorAt(Token tok, Args... args)
{
  return ERROR(in_name,":",tok.line,":",tok.column,": ", args...);
}
