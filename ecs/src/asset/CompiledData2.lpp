$ local cmn = require "common"
$ local glob = require "Glob"
$ local Processor = require "reflect.Processor"
$ local ast = require "reflect.AST"
$ local clog = require "Logger" ("compiledata", Verbosity.Debug)

#include "iro/Logger.h"
#include "iro/fs/File.h"
#include "iro/fs/Path.h"
#include "iro/containers/SmallArray.h"

using namespace iro;

@log.ger(compiledata, Debug);

$$$
local importer = require "reflect.Importer"
{
  patterns = 
  {
    "src/**/*.defs.lh",
    "src/**/*.comp.lh",
  },

  filter = function(p, decl)
    if decl.metadata.def then
      return true
    end

    local TComponent = p.processed_clang_objs["struct Component"]
    if TComponent and decl:is(ast.Record) and decl:isDerivedFrom(TComponent)
    then
      return true
    end
  end,
}
$$$
@importer:get

@@lpp.import "asset/CompiledData.lh"

@@lpp.import "asset/Packing.lh"
@@lpp.import "asset/AssetMgr.lh"
@@lpp.import "asset/SourceDataFileReg.lh"

/* ----------------------------------------------------------------------------
 *  Helper for searching for the proper source type of an asset when its 
 *  extension is not provided by the user. I think RTR handles this now,
 *  so maybe not needed and remove later!?!!?!!?
 */
String getSourceAssetType(String type)
{
  switch (type.hash())
  {
$ importer:eachDecl(function(name, decl)
$   if decl:is(ast.Struct) then
$     if decl.metadata.source_types then
  case "$(name)"_hashed:
    return "$(decl.metadata.source_types)"_str;
$     end
$   end
$ end)
  }

  return nil;
}

/* ----------------------------------------------------------------------------
 *  Helper for getting the proper data path of an asset, resolving its 
 *  extension if not provided by the user.
 */
static String getDataAssetPath(
    PathBuffer* out, 
    String data_dir,
    String name, 
    String type)
{
  using namespace fs;

  io::formatv(out, data_dir, '/', name);

  if (!Path::hasExtension(name))
  {
    auto srctype = getSourceAssetType(type);
    if (isnil(srctype))
    {
      ERROR("asset name passed '", name, "' does not contain an "
            "extension and there is no known source type for $(type)");
      return nil;
    }
    io::formatv(out, '.', srctype);
  }

  io::format(out, ".data"_str);

  return out->asStr();
}

/* ----------------------------------------------------------------------------
 *  Helper for getting the proper source path of an asset, resolving its 
 *  extension if not provided by the user.
 */
static String getSourceAssetPath(
    PathBuffer* out,
    String name,
    String type)
{
  using namespace fs;

  io::formatv(out, name);

  if (!Path::hasExtension(name))
  {
    auto srctype = getSourceAssetType(type);
    if (isnil(srctype))
    {
      ERROR("asset name passed '", name, "' does not contain an "
            "extension and there is no known source type for $(type)");
      return nil;
    }
    io::formatv(out, '.', srctype);
  }

  return out->asStr();
}

/* ============================================================================
 */
struct CompiledPtr
{
  u64 pointer_offset;
  u64 pointee_count;
  u64 pointee_size;
  String pointee_type;
};

typedef SmallArray<CompiledPtr, 64> CompiledPtrs;

struct CompiledString
{
  u64 string_offset;
  u64 data_offset;
  u64 data_len;
};

typedef SmallArray<CompiledString, 64> CompiledStrings;

/* ============================================================================
 *  Data compiler state and interface, this provides the actual implementations
 *  of compilation of different types.
 */
struct Compiler
{
  io::Memory* data_buffer;
  io::Memory* string_buffer;
  CompiledStrings* strings;
  CompiledPtrs* pointers;

  // Writes some raw data of type 'T' to the current data buffer.
  template<typename T>
  void writeData(const T& x)
  {
    data_buffer->write({(u8*)&x, sizeof(T)});
  }

  // Writes some raw data of type 'T' to the current data buffer, without
  // some data to copy. Will be filled with zeroes.
  template<typename T>
  void writeData()
  {
    u8* bytes = data_buffer->allocateBytes(sizeof(T));
    mem::zero(bytes, sizeof(T));
  }

  // Prototype for compilation functions, specialized for each type we may
  // compile below.
  template<typename T>
  b8 compile(const T& x);

  // Prototype for special handling of pointers WHICH SHOULD BE REMOVED
  // AND MADE AN ERROR EVENTUALLY!
  b8 compile(void* x);

  // Runtime type variant of the above function. Will select the correct 
  // function based on the type provided in the given String.
  b8 compile(String type, void* ptr);
};

$ -- * ------------------------------------------------------------------------

$ local placed = {}
$ local placed_list = cmn.List{}
$ local function recordPlaced(decl)
$   placed[decl.name] = decl
$   placed_list:push(decl)
$ end
$ -- Sort of hacky way to handle typedef stuff. We unwrap types to their 
$ -- declarations to place a compiler function for them, which loses the 
$ -- actual name the type may be referred to as in code. So we store types that
$ -- we place here, so that we may handle them properly.
$ local placed_types = {}
$ local placed_types_list = cmn.List{}
$ local function recordPlacedType(type)
$   placed_types[type.name] = type
$   placed_types_list:push(type)
$ end
$ local place_queue = cmn.List{}

$ local putCompiler
$ local putTypeCompiler
$ local TAssetRef = importer.p.processed_clang_objs["struct AssetRef"]
$ local TTextureRef = importer.p.processed_clang_objs["struct gfx::TextureRef"]

$ local function putNumberCompiler(name)
/* ----------------------------------------------------------------------------
 */
template<>
b8 Compiler::compile(const $(name)& x)
{
  writeData<$(name)>(x);

  return true;
}
$ end

@putNumberCompiler "u8"
@putNumberCompiler "u16"
@putNumberCompiler "u32"
@putNumberCompiler "u64"
@putNumberCompiler "s8"
@putNumberCompiler "s16"
@putNumberCompiler "s32"
@putNumberCompiler "s64"
@putNumberCompiler "f32"
@putNumberCompiler "f64"

/* ----------------------------------------------------------------------------
 *  Special implementation for void*'s. Since we dont attribute meaning to 
 *  plain pointers in SourceData, we just write the pointer value and don't
 *  handle it at all. This is not an error, because some types that may 
 *  appear here may store void* for internal purposes (eg. Component atm)
 *  and its likely that the type storing the pointer will never actually
 *  appear in CompiledData. 
 *
 *  This should be handled better though. The current case for this is 
 *  Component, which we never want to compile into data atm, since we 
 *  define Components using TypedStringMaps in source data. We can prob just
 *  explicitly mark the Component struct as not compiled, but I don't want 
 *  to fiddle with that atm.
 *
 *  Eventually, though, we need to make this an error, as we never want a 
 *  plain pointer appearing in data because its use is ambiguous.
 */
b8 Compiler::compile(void* x)
{
  writeData<void*>();
  return true;
}

/* ----------------------------------------------------------------------------
 *  Special implementation of compiling Strings, since we need to track them
 *  for the string table that will be output as part of the CompiledData.
 */
template<>
b8 Compiler::compile(const String& str)
{
  if (notnil(str))
  {
    strings->push(
    {
      // Mark where in the data the String is going to appear.
      .string_offset = data_buffer->len,
      // Mark where in the string table the String's content is going 
      // to appear.
      .data_offset = string_buffer->len,
      // Cache the length of the String (we can probably just put this in
      // the actual String data but whatever).
      .data_len = str.len,
    });
    
    // Copy the contents into the String table.
    string_buffer->allocateString(str);
  }

  // Write blank String data into the buffer.
  writeData<String>();
  return true;
}
$ recordPlaced(importer.p.processed_clang_objs["struct iro::utf8::String"])

$ -- * ------------------------------------------------------------------------
$ -- Place specializations of Compiler::compile for structure types.

$ local function putStructCompiler(name, decl)
$   -- Ensure that a compiler for each field type is defined before this 
$   -- struct.
$   for field in decl:eachFieldWithIndex() do
$     putTypeCompiler(field.type)
$   end
/* ----------------------------------------------------------------------------
 */
template<>
b8 Compiler::compile(const $(name)& x)
{
  // Cache start offset so we can assert that the data written matches the 
  // size of this type later.
  // TODO(sushi) this should only happen in debug.
  u64 start_offset = data_buffer->len;

$   if decl.bases then
$     for base in decl.bases:each() do
  // Compile base parts first.
  compile(*($(base.name)*)&x);
$     end
$   end

$ -- Compile out each field of this struct, keeping track of the last field
$ -- we compiled such that we may insert whatever padding may be there.
$   local last_field
$   for field in decl:eachFieldWithIndex() do
  // Field '$(field.name)' 
  //   offset: $(field.offset) 
  //     size: $(field.type.size)
  //     type: $(field.type:tostring())
$    if last_field then
$      -- Compute possible padding of the last field and insert it if needed.
$      local diff = field.offset - last_field.offset
$      if diff > last_field.type.size then
  // Allocate padded space.
  data_buffer->allocateBytes($(diff - last_field.type.size));
$      end
$    end
$    last_field = field
  if (!compile(x.$(field.name)))
    return ERROR("failed to compile field '$(field.name)' of $(name)\n");
$   end

$   -- Insert padding of final field if needed.
$   if last_field then
$     local this_size = decl.type.size
$     local last_ext = last_field.type.size + last_field.offset
$     if this_size > last_ext then
  // Trailing padding.
  data_buffer->allocateBytes($(this_size - last_ext));
$     end
$   end

$ if 0 ~= decl:getFieldCount() then
$   -- Check that the size of data we wrote matches the size of this type,
$   -- to catch improper compilation at runtime. Note that we do not do this
$   -- for empty structs as for whatever reason in C++ sizeof an empty type
$   -- results in 1, not 0. C++ is so fucking stupid!!!
  assert(data_buffer->len - start_offset == sizeof($(name)));
$ end

  return true;
}
$ end

$ -- * ------------------------------------------------------------------------

$ local function putStringMapCompiler(name, decl)
$   -- Ensure slots are compiled.
$   local slots_decl = decl.members.map["Slot"]
$   putCompiler(slots_decl)
template<>
b8 Compiler::compile(const $(name)& x)
{
  auto* p = pointers->push();
  p->pointer_offset = data_buffer->len;
  p->pointee_count = x.len;
  p->pointee_size = sizeof($(name)::Slot);
  p->pointee_type = "$(name)::Slot"_str;

  writeData(x);

  return true;
}
$ end

$ -- * ------------------------------------------------------------------------

$ local function putAssetRefCompiler(name, decl)
$   clog:debug(name, "\n")
$   if decl.template_args then
$     putTypeCompiler(decl.template_args[1])
$   end
template<>
b8 Compiler::compile(const $(name)& x)
{
  if (!compile(x.name))
    return false;

  writeData<void*>();

  return true;
}
$ end

$ -- * ------------------------------------------------------------------------

$ local function putEnumArrayCompiler(name, decl)
/* ----------------------------------------------------------------------------
 */
template<>
b8 Compiler::compile(const $(name)& x)
{
  for (auto& elem : x)
  {
    if (!compile(elem))
      return ERROR("failed to compile element ", &elem-x.arr, " of $(name)\n");
  }

  return true;
}
$ end

$ -- * ------------------------------------------------------------------------

$ local function putArrayDefCompiler(name, decl)
$   local subtype = decl.template_args[1]
$   local subdecl = subtype:getDecl()
$   if not subdecl then
$     print(subtype:tostring())
$     error("failed to get declaration of array subtype: "..name)
$   end
/* ----------------------------------------------------------------------------
 */
template<>
b8 Compiler::compile(const $(name)& x)
{
  auto* p = pointers->push();
  p->pointer_offset = data_buffer->len;
  p->pointee_count = x.len;
  p->pointee_size = sizeof($(subdecl.name));
  p->pointee_type = "$(importer.removeTag(subdecl.name))"_str;

  writeData(x);

  return true;
}
$ end

$ -- * ------------------------------------------------------------------------

$ local function putVec2Compiler(name, decl)
/* ----------------------------------------------------------------------------
 */
template<>
b8 Compiler::compile(const $(name)& x)
{
  writeData(x);
  return true;
}
$ end

$ -- * ------------------------------------------------------------------------

$ local function putFlagsCompiler(name, decl)
/* ----------------------------------------------------------------------------
 */
template<>
b8 Compiler::compile(const $(name)& x)
{
  writeData(x);
  return true;
}
$ end

$ -- * ------------------------------------------------------------------------

template<>
b8 Compiler::compile(const TypedPtr<void>& x);

$ local function putTypedPtrCompiler(name, decl)
$   local subtype = decl.template_args[1]
$   if subtype.name == "void" then
$     -- Explicitly specialized after normal functions have been placed.
$    return 
$   end
$   local subdecl = subtype:getDecl()
$   if not subdecl then
$     error("failed to get subdecl of "..name)
$   end
/* ----------------------------------------------------------------------------
 */
template<>
b8 Compiler::compile(const $(name)& x)
{
  if (!compile(x.name))
    return false;

  if (x.ptr == nullptr)
  {
    // Skip null pointers.
    writeData<void*>();
    return true;
  }

  auto* p = pointers->push();
  p->pointer_offset = data_buffer->len;
  p->pointee_count = 1;
  p->pointee_size = sizeof($(subdecl.name));
  p->pointee_type = x.type;

  writeData(x.ptr);

  return true;
}
$ end

$ -- * ------------------------------------------------------------------------

$ local function putTypedStringMapCompiler(name, decl)
/* ----------------------------------------------------------------------------
 */
template<>
b8 Compiler::compile(const $(name)& x)
{
  if (!compile(x.type))
    return false;

  if (!compile(x.map))
    return false;

  return true;
}
$ end

$ -- * ------------------------------------------------------------------------

$ local function putFlagsCompiler(name, decl)
/* ----------------------------------------------------------------------------
 */
template<>
b8 Compiler::compile(const $(name)& x)
{
  writeData(x);
  return true;
}
$ end

$ -- * ------------------------------------------------------------------------

$ local function putTemplateSpecializationCompiler(name, decl)
$   -- Ensure compilers for any type used as arguments to this template 
$   -- are placed.
$   for arg in decl.template_args:each() do
$     if arg:is(ast.Type) then
$       putTypeCompiler(arg)
$     end
$   end
$   
$   local spec = decl.specialized_name
$   if     "Array" == spec then
$     error("Arrays are not supported in compiled data! Use ArrayDef instead")
$   elseif decl:isDerivedFrom(TAssetRef) then
$     return (putAssetRefCompiler(name, decl))
$   elseif "TypedPtr" == spec then
$     return (putTypedPtrCompiler(name, decl))
$   elseif "ArrayDef" == spec then
$     return (putArrayDefCompiler(name, decl))
$   elseif "StringMap" == spec then
$     return (putStringMapCompiler(name, decl))
$   elseif "TypedStringMap" == spec then
$     return (putTypedStringMapCompiler(name, decl))
$   elseif "EnumArray" == spec then
$     return (putEnumArrayCompiler(name, decl))
$   elseif "vec2" == spec then
$     return (putVec2Compiler(name, decl))
$   elseif "Flags" == spec then
$     return (putFlagsCompiler(name, decl))
$   end
$   clog:warn("unhandled template spec used in data: ", name, "\n")
$ end

$ -- * ------------------------------------------------------------------------

$ local function putRecordCompiler(name, decl)
$   for base in decl.bases:each() do
$     putCompiler(base)
$   end
$ 
$   -- TODO(sushi) having to handle these as special cases kind of sucks.
$   --             Should eventually make a NameRef type or something that 
$   --             these and any new ref types may inherit from to be 
$   --             automatically handled as just compiling its name.
$   if decl == TAssetRef or decl:isDerivedFrom(TAssetRef) then
$     return (putAssetRefCompiler(name, decl))
$   end
$  
$   if decl:is(ast.TemplateSpecialization) then
$     return (putTemplateSpecializationCompiler(name, decl))
$   elseif decl:is(ast.Struct) and decl.is_complete then
$     return (putStructCompiler(name, decl))
$   end
$ end

$ -- * ------------------------------------------------------------------------
$ -- Place specializations of Compiler::compile for enum types. Just writes
$ -- out the raw data, which is probably ok.

$ local function putEnumCompiler(name, decl)
/* ----------------------------------------------------------------------------
 */
template<>
b8 Compiler::compile(const $(name)& x)
{
  // Write raw enum value.
  writeData(x);

  return true;
}
$ end

$ -- * ------------------------------------------------------------------------

$ putCompiler = function(decl, from_type)
$   if placed[decl.name] then return end
$  
$   for to_place in place_queue:each() do
$     if to_place == decl then
$       -- If we find that something we want to place depends on a type we 
$       -- are already going to place, forward declare its specialization 
$       -- to avoid explicit specialization after implicit errors.
template<>
b8 Compiler::compile(const $(decl.name)& x);
$       return
$     end
$   end
$
$   place_queue:push(decl)
$ 
$   if decl:is(ast.TagDecl) then
$     if decl:is(ast.Record) then
$       putRecordCompiler(importer.removeTag(decl.name), decl)
$     elseif decl:is(ast.Enum) then
$       putEnumCompiler(importer.removeTag(decl.name), decl)
$     end
$   elseif decl:is(ast.TypedefDecl) then
$     putTypeCompiler(decl.subtype)
$   end
$ 
$   place_queue:pop()
$   recordPlaced(decl)
$ end

$ -- * ------------------------------------------------------------------------

$ putTypeCompiler = function(type)
$   local desugared = type:getDesugared()
$   if desugared:is(ast.TagType) then
$     local decl = desugared:getDecl()
$     putCompiler(decl)
$   elseif desugared:is(ast.TypedefType) then
$     putCompiler(desugared.decl)
$   end
$   if type:is(ast.ElaboratedType) then
$     if not placed_types[type.name] then
$       recordPlacedType(type)
$     end
$   end
$ end

$ -- * ------------------------------------------------------------------------
$ -- Main loop for placing specializations of Compiler::compile

$ importer:eachDecl(function(name, decl)
$   putCompiler(decl)
$ end)

$ -- * ------------------------------------------------------------------------

$ local function eachPlacedName(f)
$   local placed_names = {}
$   for decl in placed_list:each() do
$     local name = importer.removeTag(decl.name)
$     placed_names[name] = true
$     f(name, decl)
$   end
$   for type in placed_types_list:each() do
$     if type:is(ast.ElaboratedType) and not placed_names[type.name] then
$       local desugared = type:getDesugared()
$       f(name, desugared:getDecl())
$     end
$   end
$ end

$ -- * ------------------------------------------------------------------------

$ if false then
$ local function placeRuntimeCases(f)
$   for decl in placed_list:each() do
$     print(decl)
$     local dname = importer.removeTag(decl.name)
$     if decl.types then
$       for name,type in pairs(decl.types) do
$        -- io.write("    ", dname, "\n", 
$        --          "    ", type.name, "\n", 
$        --          "    ", type:tostring(), "\n")
$         local can_place = false
$         if type:is(ast.ElaboratedType) then
$           -- Don't place elaborated type names when the type is a nested
$           -- type, because it will cause collisions.
$           if not decl.parent then
$             can_place = true
$           end
$         elseif type:is(ast.TagType) then
$           can_place = true
$         end
$         
$         if can_place then
$           if type.name ~= dname then
  case "$(type.name)"_hashed:
$           end
$         end
$       end
$     end
  case "$(dname)"_hashed:
$   f(decl)
    break;
$   end
$ end
$ end

$ local function placeRuntimeCases(f)
$   for decl in placed_list:each() do
  case "$(importer.removeTag(decl.name))"_hashed:
$   f(decl)
    break;
$   end
$ end

/* ----------------------------------------------------------------------------
 *  Explicit specialization of TypedPtr<void>, after we know all the types 
 *  we can compile.
 *
 *  TODO(sushi) the reason this is necessary is probably redundant itself, 
 *              as this is only here so we can store the size of the pointee
 *              which is used when we have a pointer to an array to properly
 *              iterate elements. Since we already have the typename, we could
 *              centralize the size lookup where we are iterating pointers,
 *              and remove the pointee size from the CompiledPointer type.
 *              Probably, I'm not doing it now cause im not sure yet.
 */
template<>
b8 Compiler::compile(const TypedPtr<void>& x)
{
  if (!compile(x.type))
    return false;

  if (x.ptr == nullptr)
  {
    // Skip this pointer.
    writeData<void*>();
    return true;
  }

  auto* p = pointers->push();
  p->pointer_offset = data_buffer->len;
  p->pointee_count = 1;
  p->pointee_type = x.type;

  switch (x.type.hash())
  {
  // Uhh yeah
  case "b8"_hashed:
    p->pointee_size = sizeof(b8);
    break;
$ placeRuntimeCases(function(decl)
    p->pointee_size = sizeof($(decl.name));
$ end)
  default:
    return ERROR("unhandled type used in TypedPtr: ", x.type, "\n");
  }

  writeData(x.ptr);

  return true;
}

/* ----------------------------------------------------------------------------
 */
b8 Compiler::compile(String type, void* ptr)
{
  switch (type.hash())
  {
$ placeRuntimeCases(function(decl)
    return compile(*($(decl.name)*)ptr);
$ end)
  }

  return ERROR("unhandled type ", type, " passed to Compiler::compile\n");
}

/* ----------------------------------------------------------------------------
 */
b8 CompiledData::compile(const CompileParams& params)
{
  using namespace fs;

  // Resolve source and output file paths.
  PathBuffer source_path_buffer;
  String source_path = 
    getSourceAssetPath(
      &source_path_buffer,
      params.name,
      params.type);

  if (isnil(source_path))
    return false;

 PathBuffer data_path_buffer;
  String data_path = 
    getDataAssetPath(
      &data_path_buffer, 
      params.assetmgr.getDataDir(),
      params.name,
      params.type);

  if (isnil(data_path))
    return false;

  // Don't compile if up-to-date.
  if (!AssetMgr::checkNeedsCompiled(source_path, data_path))
    return true;
  
  // Load source data that we are compiling.
  SourceDataFileHandle source_data_file = 
    params.sfile_reg.loadFromDisk(source_path);

  if (!source_data_file.isValid())
    return false;

  SourceDataFile* sfile = source_data_file.getFile();

  SourceData* root_data = sfile->returned_data;

  if (root_data->type != params.type)
    return ERROR(
      "returned type (", root_data->type, ") of ", source_path, 
      " differs from expected type ", params.type, "\n");

  // Pack the source data into binary data we can output.
  PackedData packed;
  defer { packed.clear(); };

  PackContext pack_context = 
  {
    nullptr, nullptr,
    &packed,
  };

  if (!packSourceDataFromType(*root_data, pack_context))
    return ERROR("failed to pack data of ", source_path, "\n");
 
  if (!platform::makeDir(Path::removeBasename(data_path), true))
    return @log.error("failed to make directories\n");

  // Create the buffer we are going to incrementally write into.
  io::Memory data_buffer;
  data_buffer.open();
  defer { data_buffer.close(); };

  // Allocate the header.
  data_buffer.writeType<CompiledData>({});

  // Set name and type early.
  {
    u64 name_offset = data_buffer.len;
    data_buffer.allocateString(params.name);

    u64 type_offset = data_buffer.len;
    data_buffer.allocateString(params.type);

    auto* compiled = (CompiledData*)data_buffer.ptr;

    compiled->name.setString(
      String::from(data_buffer.ptr + name_offset, params.name.len));

    compiled->type.setString(
      String::from(data_buffer.ptr + type_offset, params.type.len));
  }

  // Allocate the string table.
  io::Memory strings_buffer;
  strings_buffer.open();
  defer { strings_buffer.close(); };

  // Arrays for tracking important things we find in data.
  CompiledStrings strings;
  CompiledPtrs pointers;

  // Cache where we start writing actual data.
  u64 data_start = data_buffer.len;

  // Prep compiler for building data.
  Compiler compiler;
  compiler.data_buffer = &data_buffer;
  compiler.string_buffer = &strings_buffer;
  compiler.strings = &strings;
  compiler.pointers = &pointers;

  // Compile root data.
  if (!compiler.compile(params.type, packed.data.ptr))
    return false;

  // Cache off root size.
  u64 root_size = data_buffer.len - data_start;

  for (;;)
  {
    // Gather the next set of pointers we find in a separate buffer.
    CompiledPtrs next_pointers;
    compiler.pointers = &next_pointers;
    
    // Compile data that is pointed to by this type into their own blocks. 
    for (auto& ptr : pointers)
    {
      // Get the address of the pointer and what it points to.
      void** ptrptr = (void**)(data_buffer.ptr + ptr.pointer_offset);
      void* ptrdata = *ptrptr;

      // Set the pointer to be an offset to the data we're about to write.
      ((OffsetPtr<void>*)ptrptr)->set(data_buffer.ptr + data_buffer.len);

      INFO("compiling ", ptr.pointee_type, "\n");

      // Compile each pointee.
      for (u32 i = 0; i < ptr.pointee_count; ++i)
      {
        u64 offset = data_buffer.len;
        void* pointee = (u8*)ptrdata + i * ptr.pointee_size;
        
        if (!compiler.compile(ptr.pointee_type, pointee))
          return false;
      }
    }

    // If we got no more pointers, we're done compiling binary data.
    if (next_pointers.isEmpty())
      break;

    // Otherwise, swap the new pointers into the current list and 
    // compile them.
    next_pointers.move(&pointers);
  }

  // Cache off where the string table will be in data.
  u64 strings_start = data_buffer.len;

  // Repoint all Strings we found in data to point at their location
  // in the string table.
  // TODO(sushi) it would be nice to optimize for size with the string table,
  //             but going to leave that for later. Shouldn't be terribly
  //             difficult, will just slow down data compilation a bit.
  for (auto& str : strings)
  {
    // Get the String that we wrote into the buffer.
    auto* strptr = (String*)(data_buffer.ptr + str.string_offset);

    // Pun it as an OffsetString and point to its content. This will break 
    // if String ever becomes smaller than OffsetString but I believe that 
    // should never happen. If for whatever reason it does, we'll probably 
    // need a special String type used in data we expect to be compiled.
    OffsetString::setStringAsOffsetString(strptr, String::from(
      data_buffer.ptr + strings_start + str.data_offset,
      str.data_len));
  }

  // Set the header data (remember name and type are set early).
  auto* compiled = (CompiledData*)data_buffer.ptr;

  // Root data is the first block we place.
  compiled->root.setSlice(data_buffer.ptr + data_start, root_size);

  // Set the slice spanning all compiled data (remember this includes root).
  compiled->data.setSlice(
    data_buffer.ptr + data_start, data_buffer.len - data_start);

  // The string table will be placed directly after the binary data, so 
  // point its slice there.
  compiled->strings.setSlice(
    data_buffer.ptr + data_buffer.len, strings_buffer.len);

  // Finally open the data file and write out our result.
  auto data_file = 
    File::from(data_path,
        OpenFlag::Write
      | OpenFlag::Truncate
      | OpenFlag::Create);

  if (isnil(data_file))
    return ERROR(
      "failed to open data file for writing at '", data_path, "'\n");

  data_file.write(data_buffer.asBytes());
  data_file.write(strings_buffer.asBytes());
  data_file.close();

  return true;
}

/* ----------------------------------------------------------------------------
 */
CompiledData* CompiledData::load(
    String name, 
    String type, 
    AssetMgr& assetmgr,
    Asset** out_asset)
{
  using namespace fs;

  PathBuffer data_path_buffer;

  String data_path = 
    getDataAssetPath(
      &data_path_buffer, 
      assetmgr.getDataDir(),
      name,
      type);

  if (isnil(data_path))
    return nullptr;

  Asset* asset = assetmgr.findAsset(data_path);
  if (asset == nullptr)
  {
    asset = assetmgr.loadAssetFromDisk(data_path);
    if (asset == nullptr)
    {
      @log.error("failed to allocate compiled data asset\n");
      return nullptr;
    }
    ((CompiledData*)asset->data)->fixPointers();
  }

  if (out_asset)
    *out_asset = asset;

  return (CompiledData*)asset->data;
}

$ -- * ------------------------------------------------------------------------
$ -- Definitions of CompiledData auxillary methods.

/* ----------------------------------------------------------------------------
 */
template<typename T>
void getRefs(CompiledData::Refs* refs, T* ptr);

/* ----------------------------------------------------------------------------
 *  RTTI version.
 */
void getRefs(String type, CompiledData::Refs* refs, void* ptr);

/* ----------------------------------------------------------------------------
 *  Interface impl.
 */
void CompiledData::getRefs(Refs* refs)
{
  ::getRefs(type.getString(), refs, data.ptr.get());
}

$ -- * ------------------------------------------------------------------------
$ -- Used for types that we know will never contain refs.

$ local function putGetRefsNoop(name, decl)
/* ----------------------------------------------------------------------------
 */
template<>
void getRefs(CompiledData::Refs* refs, $(name)* ptr)
{
  // Noop case...
}
$ end

@putGetRefsNoop "u8"
@putGetRefsNoop "u16"
@putGetRefsNoop "u32"
@putGetRefsNoop "u64"
@putGetRefsNoop "s8"
@putGetRefsNoop "s16"
@putGetRefsNoop "s32"
@putGetRefsNoop "s64"
@putGetRefsNoop "f32"
@putGetRefsNoop "f64"
@putGetRefsNoop "void"
@putGetRefsNoop "void*"
@putGetRefsNoop "String"

$ -- * ------------------------------------------------------------------------

$ local function putGetStructRefs(name, decl)
/* ----------------------------------------------------------------------------
 */
template<>
void getRefs(CompiledData::Refs* refs, $(name)* ptr)
{
$ for field in decl:eachFieldWithIndex() do
  getRefs(refs, &ptr->$(field.name));
$ end
}
$ end

$ -- * ------------------------------------------------------------------------

$ local function putGetTypedPtrRefs(name, decl)
/* ----------------------------------------------------------------------------
 */
template<>
void getRefs(CompiledData::Refs* refs, $(name)* ptr)
{
  getRefs(refs, ptr->ptr);
}
$ end

$ -- * ------------------------------------------------------------------------

$ local function putGetArrayDefRefs(name, decl)
/* ----------------------------------------------------------------------------
 */
template<>
void getRefs(CompiledData::Refs* refs, $(name)* ptr)
{
  for (auto& elem : *ptr)
    getRefs(refs, &elem);
}
$ end

$ -- * ------------------------------------------------------------------------

$ local function putGetStringMapRefs(name, decl)
template<>
void getRefs(CompiledData::Refs* refs, $(name)* ptr)
{
  for (s32 i = 0; i < ptr->len; ++i)
    getRefs(refs, &ptr->slots[i].elem);
}
$ end

$ -- * ------------------------------------------------------------------------

$ local function putGetTypedStringMapRefs(name, decl)
/* ----------------------------------------------------------------------------
 */
template<>
void getRefs(CompiledData::Refs* refs, $(name)* ptr)
{
  getRefs(refs, &ptr->map);
}
$ end

$ -- * ------------------------------------------------------------------------

$ local function putGetEnumArrayRefs(name, decl)
/* ----------------------------------------------------------------------------
 */
template<>
void getRefs(CompiledData::Refs* refs, $(name)* ptr)
{
  for (auto& elem : *ptr)
    getRefs(refs, &elem);
}
$ end

$ -- * ------------------------------------------------------------------------

$ local function putGetTemplateSpecializationRefs(name, decl)
$   local spec = decl.specialized_name
$   if     "TypedPtr" == spec then
$     return (putGetTypedPtrRefs(name, decl))
$   elseif "ArrayDef" == spec then
$     return (putGetArrayDefRefs(name, decl))
$   elseif "StringMap" == spec then
$     return (putGetStringMapRefs(name, decl))
$   elseif "TypedStringMap" == spec then
$     return (putGetTypedStringMapRefs(name, decl))
$   elseif "EnumArray" == spec then
$     return (putGetEnumArrayRefs(name, decl))
$   elseif "vec2" == spec then
$     return (putGetRefsNoop(name, decl))
$   elseif "Flags" == spec then
$     return (putGetRefsNoop(name, decl))
$   end
$   clog:warn("unhandled template spec (getRefs): ", name, "\n")
$ end

$ -- * ------------------------------------------------------------------------

$ local function putGetAssetRefRefs(name, decl)
/* ----------------------------------------------------------------------------
 */
template<>
void getRefs(CompiledData::Refs* refs, $(name)* ptr)
{
  refs->push({"$(name)"_str, ptr});
}
$ end

$ -- * ------------------------------------------------------------------------

$ local function putGetRecordRefs(name, decl)
$   if decl == TAssetRef or decl:isDerivedFrom(TAssetRef) then
$     return (putGetAssetRefRefs(name, decl))
$   end
$   
$   if name == "iro::utf8::String" then
$     return -- Explicitly a noop.
$   end
$   
$   if decl:is(ast.TemplateSpecialization) then
$     return (putGetTemplateSpecializationRefs(name, decl))
$   elseif decl:is(ast.Struct) and decl.is_complete then
$     return (putGetStructRefs(name, decl))
$   end
$ end

$ -- * ------------------------------------------------------------------------

$ local function putGetRefs(decl)
$   if decl:is(ast.TagDecl) then
$     if decl:is(ast.Record) then
$       putGetRecordRefs(importer.removeTag(decl.name), decl)
$     else
$       putGetRefsNoop(importer.removeTag(decl.name), decl)
$     end
$   end
$ end

$ -- * ------------------------------------------------------------------------
$ -- Loop for placing specializations of getRefs. This uses the cached off
$ -- placement order of Compiler::compile specializations, so ideally 
$ -- we shouldn't run into issues with placement.

$ for decl in placed_list:each() do
$   putGetRefs(decl)
$ end

/* ----------------------------------------------------------------------------
 */
void getRefs(String type, CompiledData::Refs* refs, void* ptr)
{
  switch (type.hash())
  {
$ placeRuntimeCases(function(decl)
    getRefs(refs, ($(decl.name)*)ptr);
    return;
$ end)
  }

  ERROR("unhandled type ", type, " passed to getRefs\n");
}

$ -- * ------------------------------------------------------------------------
$ -- Pointer fixing stuff.

/* ----------------------------------------------------------------------------
 */
template<typename T>
void fixPointers(T* ptr);

/* ----------------------------------------------------------------------------
 *  RTTI version.
 */
void fixPointers(String type, void* ptr);

/* ----------------------------------------------------------------------------
 *  Interface impl.
 */
void CompiledData::fixPointers()
{
  ::fixPointers(type.getString(), data.ptr.get());
}

$ -- * ------------------------------------------------------------------------
$ -- Used for types that we know will never contain fixed pointers.

$ local function putFixPointersNoop(name, decl)
/* ----------------------------------------------------------------------------
 */
template<>
void fixPointers($(name)* ptr)
{
  // Noop case...
}
$ end

@putFixPointersNoop "u8"
@putFixPointersNoop "u16"
@putFixPointersNoop "u32"
@putFixPointersNoop "u64"
@putFixPointersNoop "s8"
@putFixPointersNoop "s16"
@putFixPointersNoop "s32"
@putFixPointersNoop "s64"
@putFixPointersNoop "f32"
@putFixPointersNoop "f64"
@putFixPointersNoop "void"
@putFixPointersNoop "void*"

/* ----------------------------------------------------------------------------
 *  Explicit specialization for fixing strings.
 */
template<>
void fixPointers(String* ptr)
{
  *ptr = OffsetString::getStringAsOffsetString(ptr);
}

$ -- * ------------------------------------------------------------------------

$ local function putFixStructPointers(name, decl)
/* ----------------------------------------------------------------------------
 */
template<>
void fixPointers($(name)* ptr)
{
$ for field in decl:eachFieldWithIndex() do
  fixPointers(&ptr->$(field.name));
$ end
}
$ end

$ -- * ------------------------------------------------------------------------

$ local function putFixTypedPtrPointers(name, decl)
/* ----------------------------------------------------------------------------
 */
template<>
void fixPointers($(name)* ptr)
{
  ptr->type = OffsetString::getStringAsOffsetString(&ptr->type);
  ptr->ptr = OffsetPtr<void>::getPtrAsOffsetPtr(&ptr->ptr);
  fixPointers(ptr->type, ptr->ptr);
}
$ end

$ -- * ------------------------------------------------------------------------

$ local function putFixArrayDefPointers(name, decl)
/* ----------------------------------------------------------------------------
 */
template<>
void fixPointers($(name)* ptr)
{
  ptr->arr = OffsetPtr<void>::getPtrAsOffsetPtr(&ptr->arr);
  for (auto& elem : *ptr)
    fixPointers(&elem);
}
$ end

$ -- * ------------------------------------------------------------------------

$ local function putFixStringMapPointers(name, decl)
/* ----------------------------------------------------------------------------
 */
template<>
void fixPointers($(name)* ptr)
{
  ptr->slots = OffsetPtr<void>::getPtrAsOffsetPtr(&ptr->slots);
  for (s32 i = 0; i < ptr->len; ++i)
  {
    auto& slot = ptr->slots[i];
    slot.key = OffsetString::getStringAsOffsetString(&slot.key);
    fixPointers(&slot.elem);
  }
}
$ end

$ -- * ------------------------------------------------------------------------

$ local function putFixTypedStringMapPointers(name, decl)
/* ----------------------------------------------------------------------------
 */
template<>
void fixPointers($(name)* ptr)
{
  ptr->type = OffsetString::getStringAsOffsetString(&ptr->type);
  fixPointers(&ptr->map);
}
$ end

$ -- * ------------------------------------------------------------------------

$ local function putFixEnumArrayPointers(name, decl)
/* ----------------------------------------------------------------------------
 */
template<>
void fixPointers($(name)* ptr)
{
  for (auto& elem : *ptr)
    fixPointers(&elem);
}
$ end

$ -- * ------------------------------------------------------------------------

$ local function putFixTemplateSpecializationPointers(name, decl)
$   local spec = decl.specialized_name
$   if     "TypedPtr" == spec then
$     return (putFixTypedPtrPointers(name, decl))
$   elseif "ArrayDef" == spec then
$     return (putFixArrayDefPointers(name, decl))
$   elseif "StringMap" == spec then
$     return (putFixStringMapPointers(name, decl))
$   elseif "TypedStringMap" == spec then
$     return (putFixTypedStringMapPointers(name, decl))
$   elseif "EnumArray" == spec then
$     return (putFixEnumArrayPointers(name, decl))
$   elseif "vec2" == spec then
$     return (putFixPointersNoop(name, decl))
$   elseif "Flags" == spec then
$     return (putFixPointersNoop(name, decl))
$   end
$   clog:warn("unhandled template spec (fixPointers): ", name, "\n")
$ end

$ -- * ------------------------------------------------------------------------

$ local function putFixAssetRefPointers(name, decl)
/* ----------------------------------------------------------------------------
 */
template<>
void fixPointers($(name)* ptr)
{
  ptr->name = OffsetString::getStringAsOffsetString(&ptr->name);
}
$ end

$ -- * ------------------------------------------------------------------------

$ local function putFixRecordPointers(name, decl)
$   if decl == TAssetRef or decl:isDerivedFrom(TAssetRef) then
$     return (putFixAssetRefPointers(name, decl))
$   end
$ 
$   if name == "iro::utf8::String" then
$     return -- Explicitly implemented.
$   end
$ 
$   if decl:is(ast.TemplateSpecialization) then
$     return (putFixTemplateSpecializationPointers(name, decl))
$   elseif decl:is(ast.Struct) and decl.is_complete then
$     return (putFixStructPointers(name, decl))
$   end
$ end

$ -- * ------------------------------------------------------------------------

$ local function putFixPointers(decl)
$   if decl:is(ast.TagDecl) then
$     if decl:is(ast.Record) then
$       putFixRecordPointers(importer.removeTag(decl.name), decl)
$     else
$       putFixPointersNoop(importer.removeTag(decl.name), decl)
$     end
$   end
$ end

$ -- * ------------------------------------------------------------------------
$ -- Loop for placing specializations of fixPointers. This uses the cached off
$ -- placement order of Compiler::compile specializations, so ideally 
$ -- we shouldn't run into issues with placement.

$ for decl in placed_list:each() do
$   putFixPointers(decl)
$ end

/* ----------------------------------------------------------------------------
 */
void fixPointers(String type, void* ptr)
{
  switch (type.hash())
  {
$ placeRuntimeCases(function(decl)
    fixPointers(($(decl.name)*)ptr);
    return;
$ end)
  }

  ERROR("unhandled type ", type, " passed to fixPointers\n");
}
