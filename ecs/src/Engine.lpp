$ local cmn = require "common"
$ local ui = require "ui.UI"
$ local Style = require "ui.Style"

@@lpp.import "Engine.lh"

#include "iro/fs/Glob.h"
#include "iro/Logger.h"
#include "iro/time/Time.h"
using namespace iro;

// Introduce events and the event bus definitions.
@@lpp.import "event/BroadcastEventBus.lh"

@@lpp.import "graphics/Font.lh"
@@lpp.import "graphics/CompiledShader.lh"
@@lpp.import "ui/widgets/Text.lh"
@@lpp.import "ui/widgets/Button.lh"
@@lpp.import "ui/widgets/Separator.lh"
@@lpp.import "ui/widgets/InputText.lh"
@@lpp.import "ui/widgets/CollapsingHeader.lh"

@@lpp.import "ui/Inspector.lh"

@@lpp.import "game/Transform.comp.lh"
@@lpp.import "game/entity/Entity.lh"
@@lpp.import "game/component/Component.lh"

@@lpp.import "asset/Packing.lh"
@@lpp.import "asset/SourceDataFile.lh"
@@lpp.import "asset/SourceDataParser.lh"

@@lpp.import "asset/SourceDataEditor.lh"

static Logger logger =
  Logger::create("ecs.eng"_str, Logger::Verbosity::Info);

ui::Item* base;
ui::SourceDataEditor* sdata_edit_test;

/* ----------------------------------------------------------------------------
 */
b8 Engine::init()
{
  INFO("initializing engine...\n");
  TimePoint start_time = TimePoint::monotonic();
  frame_start_time = TimeSpan::fromSeconds(start_time.s).toSeconds()
    + TimeSpan::fromNanoseconds(start_time.ns).toSeconds();

$ local initSystem = function(act, name)
    {
      INFO("initializing $(name)\n");
      auto start = TimePoint::monotonic();
      if (!$(act))
        return FATAL("failed to initialize $(name)\n");
      INFO("finished initializing $(name) in ",
           WithUnits(TimePoint::monotonic() - start), "\n");
    }
$ end

  @initSystem(source_data_file_reg.init(),              source data file reg);
  @initSystem(eventbus.broadcast.init(),                broadcast event bus);
  @initSystem(input.init(*this),                        input);
  @initSystem(Window::initializeBackend(),              window backend);
  @initSystem(window.init("ecs"_str,input),             window);
  @initSystem(renderer.init(*this, mem::stl_allocator), renderer);
  @initSystem(assetmgr.init(&mem::stl_allocator),       asset mgr);

  //TODO(delle) move initial asset compilation somewhere else
  TRACE("compiling white texture\n");
  {
    mem::LenientBump texture_compile_allocator;
    if (!texture_compile_allocator.init())
      return ERROR("failed to initialize texture compile allocator\n");

    gfx::CompiledTexture::CompileParams white_texture_params =
    {
      .name         = "assets/textures/white"_str,
      .width        = 4,
      .height       = 4,
      .format       = gfx::ImageFormat::BW,
      .filter       = gfx::ImageFilter::Nearest,
      .address_mode = gfx::ImageAddressMode::ClampToWhite,
      .allocator    = &texture_compile_allocator,
      .assetmgr     = &assetmgr,
    };

    u8 pixels[16] =
    {
      0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff,
    };

    b8 compiled = gfx::CompiledTexture::compileFromMemory(pixels, white_texture_params);
    if (!compiled)
      return ERROR("failed to compile the white texture\n");

    auto compiled_white_texture = gfx::CompiledTexture::load("white"_str, assetmgr, renderer);
    if (compiled_white_texture == nullptr)
      return ERROR("failed to load the white texture\n");

    white_texture = compiled_white_texture->gfx_texture;

    texture_compile_allocator.deinit();
  }

  TRACE("compiling textures\n");
  {
    io::StaticBuffer<511> texture_data_path_buffer;
    auto png_glob = fs::Globber::create("assets/textures/*.png"_str);
    png_glob.run([&](fs::Path& asset_path)
    {
      texture_data_path_buffer.len = 0;
      String name = fs::Path::removeExtension(asset_path.asStr());
      gfx::CompiledTexture::writeDataPath(
        &texture_data_path_buffer, name, assetmgr);

      gfx::CompiledTexture::CompileParams params =
      { //TODO(delle) add TextureDef for specifying these params
        .name         = name,
        .format       = gfx::ImageFormat::RGBA,
        .filter       = gfx::ImageFilter::Nearest,
        .address_mode = gfx::ImageAddressMode::ClampToWhite,
        .allocator    = &mem::stl_allocator,
        .assetmgr     = &assetmgr,
      };

      gfx::CompiledTexture::compilePNG(params);
      return true;
    });
    png_glob.destroy();
  }

  TRACE("compiling shaders\n");
  {
    gfx::CompiledShader::CompileParams scene_vertex_shader_params =
    {
      .name         = "scene.vertex"_str,
      .asset_path   = "assets/shaders/scene.vertex.glsl"_str,
      .data_path    = "data/shaders/scene.vertex.shader"_str,
      .type         = gfx::ShaderType::Vertex,
      .allocator    = &mem::stl_allocator,
      .assetmgr     = &assetmgr,
    };
    gfx::CompiledShader::compileGLSL(scene_vertex_shader_params);

    gfx::CompiledShader::CompileParams scene_fragment_shader_params =
    {
      .name         = "scene.fragment"_str,
      .asset_path   = "assets/shaders/scene.fragment.glsl"_str,
      .data_path    = "data/shaders/scene.fragment.shader"_str,
      .type         = gfx::ShaderType::Fragment,
    };
    gfx::CompiledShader::compileGLSL(scene_fragment_shader_params);

    gfx::CompiledShader::CompileParams fullscreen_vertex_shader_params =
    {
      .name         = "fullscreen.vertex"_str,
      .asset_path   = "assets/shaders/fullscreen.vertex.glsl"_str,
      .data_path    = "data/shaders/fullscreen.vertex.shader"_str,
      .type         = gfx::ShaderType::Vertex,
      .allocator    = &mem::stl_allocator,
      .assetmgr     = &assetmgr,
    };
    gfx::CompiledShader::compileGLSL(fullscreen_vertex_shader_params);

    gfx::CompiledShader::CompileParams stars_fragment_shader_params =
    {
      .name         = "stars.fragment"_str,
      .asset_path   = "assets/shaders/stars.fragment.glsl"_str,
      .data_path    = "data/shaders/stars.fragment.shader"_str,
      .type         = gfx::ShaderType::Fragment,
    };
    gfx::CompiledShader::compileGLSL(stars_fragment_shader_params);

    gfx::CompiledShader::CompileParams ui_vertex_shader_params =
    {
      .name         = "ui.vertex"_str,
      .asset_path   = "assets/shaders/ui.vertex.glsl"_str,
      .data_path    = "data/shaders/ui.vertex.shader"_str,
      .type         = gfx::ShaderType::Vertex,
      .allocator    = &mem::stl_allocator,
      .assetmgr     = &assetmgr,
    };
    gfx::CompiledShader::compileGLSL(ui_vertex_shader_params);

    gfx::CompiledShader::CompileParams ui_fragment_shader_params =
    {
      .name         = "ui.fragment"_str,
      .asset_path   = "assets/shaders/ui.fragment.glsl"_str,
      .data_path    = "data/shaders/ui.fragment.shader"_str,
      .type         = gfx::ShaderType::Fragment,
    };
    gfx::CompiledShader::compileGLSL(ui_fragment_shader_params);
  }

  TRACE("compiling gohu font\n");
  {
    CodepointRange ascii =
    {
      .first_codepoint = 32,
      .num_codepoints = 94,
    };

  gfx::Font::CompileParams params =
  {
    .name       = "assets/fonts/gohu"_str,
    .ranges     = CodepointRanges::from(&ascii, 1),
    .allocator  = &mem::stl_allocator,
    .assetmgr   = &assetmgr,
  };

    gfx::Font::compileBDF(params);
  }

  @initSystem(ui.init(*this),              ui);
  @initSystem(gamemgr.init(this),          gamemgr);

#if ECS_HOT_RELOAD
  reloader = hr::createReloader();
  if (reloader == nullptr)
    return ERROR("failed to create hot reloader\n");
#endif

  INFO("done initializing in ",
    WithUnits(TimePoint::monotonic() - start_time), "\n");

$ if true then

  base = ui::Item::begin(ui, "base"_str);
  {
    @ui.style(base, Item, | size: 400 400)

    sdata_edit_test = ui::SourceDataEditor::create(ui);

    h_test =
     source_data_file_reg.loadFromDisk("assets/maps/Test.map"_str);

    sdata_edit_test->setSourceData(
      ui, 
      h_test.getFile()->returned_data,
      h_test.getFile(),
      "MapDef"_hashed);
  }
  ui.endItem();

$ else

  base = ui::Item::begin(ui, "base"_str);
  {
    @ui.style(base, Item, 
    | size: 200 200
    | display: flex
    | background_color: 0xff0000ff)

    auto* a = ui::Item::make(ui, "a"_str);
    @ui.style(a, Item,
    | size: 100% flex(1)
    | background_color: 0x00ff00ff)

    auto* c = ui::Item::make(ui, "c"_str);
    @ui.style(c, Item,
    | size: 100% 10
    | background_color: 0xee00eeff)

    auto* b = ui::Item::make(ui, "b"_str);
    @ui.style(b, Item,
    | size: 100% flex(2)
    | background_color: 0x0000ffff)
  }
  ui.endItem();

$ end


  INFO("done!\n");

  return true;
}

/* ----------------------------------------------------------------------------
 */
b8 Engine::checkReload()
{
#if ECS_HOT_RELOAD
  if (!input.wasKeyPressed(Key::R))
    return true;

  eventbus.broadcast.raise<PreReload>({});

  io::StaticBuffer<32> patchnumbuf;
  patchnumbuf.open();
  io::format(&patchnumbuf, getPatchNumber(reloader));

  String args[2] =
  {
    "patch"_str,
    patchnumbuf.asStr(),
  };

  Process::Stream streams[3] =
  {
    { false, nullptr },
    { false, nullptr },
    { false, nullptr },
  };

  auto lake =
    Process::spawn(
      "/home/sushi/src/enosi/bin/lake"_str,
      Slice<String>::from(args, 2),
      streams,
      "/home/sushi/src/enosi"_str);

  while (lake.status == Process::Status::Running)
    lake.checkStatus();

  void* dlhandle = dlopen(nullptr, RTLD_LAZY);

  hr::ReloadContext context;
  context.hrfpath = "build/debug/ecs.hrf"_str;
  context.exepath = "build/debug/ecs"_str;
  context.reloadee_handle = dlhandle;

  hr::ReloadResult result;

  if (!hr::doReload(reloader, context, &result))
    return ERROR("failed to reload symbols\n");

  eventbus.broadcast.raise<PostReload>({});
#endif
  return true;
}

/* ----------------------------------------------------------------------------
 */
b8 Engine::update()
{
  iro::TimePoint time_point = iro::TimePoint::monotonic();
  frame_start_time = TimeSpan::fromSeconds(time_point.s).toSeconds()
    + TimeSpan::fromNanoseconds(time_point.ns).toSeconds();

  if (!checkReload())
    return ERROR("error occured while reloading\n");

  if (!window.update(*this))
    return ERROR("failed to update window\n");

  if (!renderer.update())
    return ERROR("failed to update renderer\n");

  if (!input.update(*this))
    return ERROR("failed to update input\n");

  gamemgr.render();

  if (!ui.update(*this))
    return ERROR("failed to update ui\n");

  gamemgr.update();

  // inspector->fps->dirty = true;
  //
  // io::StaticBuffer<255> fps;
  // io::format(&fps, 1.f / (TimePoint::now() - start).toSeconds());
  // inspector->fps->set(fps.asStr());

  // ui.root->dirty = true;

  return true;
}
